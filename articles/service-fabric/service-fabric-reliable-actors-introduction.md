---
title: "aaaService — omówienie sieci szkieletowej niezawodnej podmiotów | Dokumentacja firmy Microsoft"
description: "Wprowadzenie toohello usługi sieć szkieletowa modelu programowania Reliable Actors."
services: service-fabric
documentationcenter: .net
author: vturecek
manager: timlt
editor: 
ms.assetid: 7fdad07f-f2d6-4c74-804d-e0d56131f060
ms.service: service-fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 06/29/2017
ms.author: vturecek
ms.openlocfilehash: ab010cbf936c6cf723b3d453ef95a9bf51f76c95
ms.sourcegitcommit: 523283cc1b3c37c428e77850964dc1c33742c5f0
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 10/06/2017
---
# <a name="introduction-tooservice-fabric-reliable-actors"></a><span data-ttu-id="bd074-103">Wprowadzenie tooService sieci szkieletowej Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="bd074-103">Introduction tooService Fabric Reliable Actors</span></span>
<span data-ttu-id="bd074-104">Reliable Actors to platforma aplikacji sieci szkieletowej usług w oparciu hello [aktora wirtualnego](http://research.microsoft.com/en-us/projects/orleans/) wzorca.</span><span class="sxs-lookup"><span data-stu-id="bd074-104">Reliable Actors is a Service Fabric application framework based on hello [Virtual Actor](http://research.microsoft.com/en-us/projects/orleans/) pattern.</span></span> <span data-ttu-id="bd074-105">Hello niezawodnej API złośliwych użytkowników zapewnia jednowątkowe model programowania oparty na powitania skalowalność i niezawodność gwarancje udostępniane przez usługi sieć szkieletowa usług.</span><span class="sxs-lookup"><span data-stu-id="bd074-105">hello Reliable Actors API provides a single-threaded programming model built on hello scalability and reliability guarantees provided by Service Fabric.</span></span>

## <a name="what-are-actors"></a><span data-ttu-id="bd074-106">Co to są złośliwych użytkowników?</span><span class="sxs-lookup"><span data-stu-id="bd074-106">What are Actors?</span></span>
<span data-ttu-id="bd074-107">Aktor jest jednostką izolowanym, niezależnie od zasobów obliczeniowych i stanu z jednowątkowego wykonywania.</span><span class="sxs-lookup"><span data-stu-id="bd074-107">An actor is an isolated, independent unit of compute and state with single-threaded execution.</span></span> <span data-ttu-id="bd074-108">Witaj [wzorca aktora](https://en.wikipedia.org/wiki/Actor_model) to model obliczeniową dla systemów równoczesnych lub rozproszone, w którym dużej liczby uczestników te mogą być wykonywane jednocześnie i niezależnie od siebie nawzajem.</span><span class="sxs-lookup"><span data-stu-id="bd074-108">hello [actor pattern](https://en.wikipedia.org/wiki/Actor_model) is a computational model for concurrent or distributed systems in which a large number of these actors can execute simultaneously and independently of each other.</span></span> <span data-ttu-id="bd074-109">Złośliwych użytkowników może komunikować się ze sobą i mogą utworzyć więcej złośliwych użytkowników.</span><span class="sxs-lookup"><span data-stu-id="bd074-109">Actors can communicate with each other and they can create more actors.</span></span>

### <a name="when-toouse-reliable-actors"></a><span data-ttu-id="bd074-110">Gdy toouse Reliable Actors</span><span class="sxs-lookup"><span data-stu-id="bd074-110">When toouse Reliable Actors</span></span>
<span data-ttu-id="bd074-111">Usługa sieci szkieletowej Reliable Actors jest implementacją wzorca projektowego hello aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-111">Service Fabric Reliable Actors is an implementation of hello actor design pattern.</span></span> <span data-ttu-id="bd074-112">Podobnie jak w przypadku dowolnego wzorcu projektowym oprogramowania hello decyzję, czy toouse określony wzorzec jest wykonywana w oparciu czy oprogramowania projektowania problem pasuje do wzorca hello.</span><span class="sxs-lookup"><span data-stu-id="bd074-112">As with any software design pattern, hello decision whether toouse a specific pattern is made based on whether or not a software design problem fits hello pattern.</span></span>

<span data-ttu-id="bd074-113">Chociaż wzorca projektowego aktora hello może być dobrym tooa dopasowania liczba systemów rozproszonych problemy i scenariusze, dokładne rozważenie hello ograniczenia wzorca hello i wdrażanie framework hello, które muszą być wprowadzane.</span><span class="sxs-lookup"><span data-stu-id="bd074-113">Although hello actor design pattern can be a good fit tooa number of distributed systems problems and scenarios, careful consideration of hello constraints of hello pattern and hello framework implementing it must be made.</span></span> <span data-ttu-id="bd074-114">Stanowią ogólne wskazówki należy wziąć pod uwagę toomodel wzorca aktora hello problemów lub scenariuszu jeśli:</span><span class="sxs-lookup"><span data-stu-id="bd074-114">As general guidance, consider hello actor pattern toomodel your problem or scenario if:</span></span>

* <span data-ttu-id="bd074-115">Obszar problem obejmuje dużą liczbą (tysięcy lub więcej) jednostek mały, niezależne i izolowane stanu i logiki.</span><span class="sxs-lookup"><span data-stu-id="bd074-115">Your problem space involves a large number (thousands or more) of small, independent, and isolated units of state and logic.</span></span>
* <span data-ttu-id="bd074-116">Ma toowork z jednowątkowego obiektów, które nie wymagają znaczących interakcji z zewnętrznego składników, w tym badania stanu zestawu podmiotów.</span><span class="sxs-lookup"><span data-stu-id="bd074-116">You want toowork with single-threaded objects that do not require significant interaction from external components, including querying state across a set of actors.</span></span>
* <span data-ttu-id="bd074-117">Swoich wystąpień aktora nie zablokuje wywołań nieprzewidywalne opóźnień wysyłając operacji We/Wy.</span><span class="sxs-lookup"><span data-stu-id="bd074-117">Your actor instances won't block callers with unpredictable delays by issuing I/O operations.</span></span>

## <a name="actors-in-service-fabric"></a><span data-ttu-id="bd074-118">Złośliwych użytkowników w sieci szkieletowej usług</span><span class="sxs-lookup"><span data-stu-id="bd074-118">Actors in Service Fabric</span></span>
<span data-ttu-id="bd074-119">W sieci szkieletowej usług, złośliwych użytkowników zostały wdrożone w ramach Reliable Actors hello: struktura aplikacji na podstawie wzorca aktora wbudowane nad [niezawodne usługi sieć szkieletowa usług](service-fabric-reliable-services-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="bd074-119">In Service Fabric, actors are implemented in hello Reliable Actors framework: An actor-pattern-based application framework built on top of [Service Fabric Reliable Services](service-fabric-reliable-services-introduction.md).</span></span> <span data-ttu-id="bd074-120">Każdej usługi niezawodnego aktora, jaki jest rzeczywiście podzielonym na partycje, stanowe niezawodnej usługi.</span><span class="sxs-lookup"><span data-stu-id="bd074-120">Each Reliable Actor service you write is actually a partitioned, stateful Reliable Service.</span></span>

<span data-ttu-id="bd074-121">Każdy aktora jest zdefiniowany jako wystąpienie typu aktora, sposób identyczne toohello obiektu .NET jest wystąpieniem typu .NET.</span><span class="sxs-lookup"><span data-stu-id="bd074-121">Every actor is defined as an instance of an actor type, identical toohello way a .NET object is an instance of a .NET type.</span></span> <span data-ttu-id="bd074-122">Na przykład może to być typ aktora, która implementuje funkcje hello kalkulatora i może istnieć wiele podmiotów tego typu rozproszonych w różnych węzłach w klastrze.</span><span class="sxs-lookup"><span data-stu-id="bd074-122">For example, there may be an actor type that implements hello functionality of a calculator and there could be many actors of that type that are distributed on various nodes across a cluster.</span></span> <span data-ttu-id="bd074-123">Każdy taki aktora jest unikatowo identyfikowana przez identyfikator aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-123">Each such actor is uniquely identified by an actor ID.</span></span>

### <a name="actor-lifetime"></a><span data-ttu-id="bd074-124">Okres istnienia aktora</span><span class="sxs-lookup"><span data-stu-id="bd074-124">Actor Lifetime</span></span>
<span data-ttu-id="bd074-125">Sieć szkieletowa usług podmiotów są wirtualnych, co oznacza, że ich istnienia nie jest związany tootheir reprezentacji w pamięci.</span><span class="sxs-lookup"><span data-stu-id="bd074-125">Service Fabric actors are virtual, meaning that their lifetime is not tied tootheir in-memory representation.</span></span> <span data-ttu-id="bd074-126">W związku z tym nie potrzebują oni toobe jawnie utworzone lub zniszczenia.</span><span class="sxs-lookup"><span data-stu-id="bd074-126">As a result, they do not need toobe explicitly created or destroyed.</span></span> <span data-ttu-id="bd074-127">środowisko uruchomieniowe Reliable Actors Hello automatycznie aktywuje hello aktora po raz pierwszy odbierze żądanie dla danego identyfikatora aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-127">hello Reliable Actors runtime automatically activates an actor hello first time it receives a request for that actor ID.</span></span> <span data-ttu-id="bd074-128">Jeśli aktora nie jest używany w danym okresie czasu, środowisko uruchomieniowe Reliable Actors hello pamięci zbiera hello obiektów w pamięci.</span><span class="sxs-lookup"><span data-stu-id="bd074-128">If an actor is not used for a period of time, hello Reliable Actors runtime garbage-collects hello in-memory object.</span></span> <span data-ttu-id="bd074-129">Również zachowa wiedzy istnienia aktora hello konieczne toobe uaktywnić ponownie później.</span><span class="sxs-lookup"><span data-stu-id="bd074-129">It will also maintain knowledge of hello actor's existence should it need toobe reactivated later.</span></span> <span data-ttu-id="bd074-130">Aby uzyskać więcej informacji, zobacz [aktora cykl życia i odzyskiwanie pamięci](service-fabric-reliable-actors-lifecycle.md).</span><span class="sxs-lookup"><span data-stu-id="bd074-130">For more details, see [Actor lifecycle and garbage collection](service-fabric-reliable-actors-lifecycle.md).</span></span>

<span data-ttu-id="bd074-131">Ta warstwa abstrakcji okres istnienia aktora wirtualnego zawiera niektóre zastrzeżenia wyniku hello aktora wirtualnego modelu, a w rzeczywistości hello implementacji Reliable Actors w czasie odbiega od tego modelu.</span><span class="sxs-lookup"><span data-stu-id="bd074-131">This virtual actor lifetime abstraction carries some caveats as a result of hello virtual actor model, and in fact hello Reliable Actors implementation deviates at times from this model.</span></span>

* <span data-ttu-id="bd074-132">Aktor jest uaktywniany automatycznie (co powoduje aktora toobe obiektu skonstruowany) hello po raz pierwszy komunikat jest wysyłany identyfikator tooits aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-132">An actor is automatically activated (causing an actor object toobe constructed) hello first time a message is sent tooits actor ID.</span></span> <span data-ttu-id="bd074-133">Po pewnym opóźnieniem od czasu obiekt aktora hello jest bezużytecznych.</span><span class="sxs-lookup"><span data-stu-id="bd074-133">After some period of time, hello actor object is garbage collected.</span></span> <span data-ttu-id="bd074-134">W hello przyszłości ponownie, używając Identyfikatora aktora hello powoduje aktora nowego obiektu toobe skonstruowany.</span><span class="sxs-lookup"><span data-stu-id="bd074-134">In hello future, using hello actor ID again, causes a new actor object toobe constructed.</span></span> <span data-ttu-id="bd074-135">Okres istnienia obiektu hello outlives stanu aktora, gdy przechowywana w hello Menedżer stanu.</span><span class="sxs-lookup"><span data-stu-id="bd074-135">An actor's state outlives hello object's lifetime when stored in hello state manager.</span></span>
* <span data-ttu-id="bd074-136">Wywołaniem jakiejkolwiek jego metody aktora o identyfikatorze aktora aktywuje tego aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-136">Calling any actor method for an actor ID activates that actor.</span></span> <span data-ttu-id="bd074-137">Z tego powodu aktora typy mają ich Konstruktor wywoływany niejawnie przez hello środowiska wykonawczego.</span><span class="sxs-lookup"><span data-stu-id="bd074-137">For this reason, actor types have their constructor called implicitly by hello runtime.</span></span> <span data-ttu-id="bd074-138">Kod klienta nie można przekazać konstruktora typu parametry toohello aktora, mimo że parametry mogą być przekazywane konstruktora toohello aktora przez usługę hello.</span><span class="sxs-lookup"><span data-stu-id="bd074-138">Therefore, client code cannot pass parameters toohello actor type's constructor, although parameters may be passed toohello actor's constructor by hello service itself.</span></span> <span data-ttu-id="bd074-139">wynik Hello jest czy uczestników, mogą być zbudowane w stanie częściowo zainicjowany przez hello razem, gdy inne metody są wywoływane, jeśli aktora hello wymaga parametrów inicjowania z powitania klienta.</span><span class="sxs-lookup"><span data-stu-id="bd074-139">hello result is that actors may be constructed in a partially-initialized state by hello time other methods are called on it, if hello actor requires initialization parameters from hello client.</span></span> <span data-ttu-id="bd074-140">Brak punktu wejścia jednym aktywacji hello aktora z powitania klienta.</span><span class="sxs-lookup"><span data-stu-id="bd074-140">There is no single entry point for hello activation of an actor from hello client.</span></span>
* <span data-ttu-id="bd074-141">Mimo że Reliable Actors niejawnie Tworzenie obiektów aktora; masz tooexplicitly możliwości hello usunąć aktora i jego stan.</span><span class="sxs-lookup"><span data-stu-id="bd074-141">Although Reliable Actors implicitly create actor objects; you do have hello ability tooexplicitly delete an actor and its state.</span></span>

### <a name="distribution-and-failover"></a><span data-ttu-id="bd074-142">Dystrybucji i trybu failover</span><span class="sxs-lookup"><span data-stu-id="bd074-142">Distribution and failover</span></span>
<span data-ttu-id="bd074-143">tooprovide skalowalność i niezawodność sieci szkieletowej usług dystrybuuje złośliwych użytkowników w całej hello klastra i automatycznie migruje węzłów toohealthy te zgodnie z potrzebami.</span><span class="sxs-lookup"><span data-stu-id="bd074-143">tooprovide scalability and reliability, Service Fabric distributes actors throughout hello cluster and automatically migrates them from failed nodes toohealthy ones as required.</span></span> <span data-ttu-id="bd074-144">Jest to Abstrakcja za pośrednictwem [podzielonym na partycje, stanowe niezawodnej usługi](service-fabric-concepts-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="bd074-144">This is an abstraction over a [partitioned, stateful Reliable Service](service-fabric-concepts-partitioning.md).</span></span> <span data-ttu-id="bd074-145">Dystrybucji, skalowalności, niezawodności i automatycznej pracy awaryjnej są dostarczane ze względu na fakt hello podmiotów działają wewnątrz stanowe niezawodnej usługi o nazwie hello *usługi aktora*.</span><span class="sxs-lookup"><span data-stu-id="bd074-145">Distribution, scalability, reliability, and automatic failover are all provided by virtue of hello fact that actors are running inside a stateful Reliable Service called hello *Actor Service*.</span></span>

<span data-ttu-id="bd074-146">Podmioty są rozproszone na partycji hello hello usługi aktora, a te partycje są rozproszone na powitania węzłów w klastrze usługi sieć szkieletowa usług.</span><span class="sxs-lookup"><span data-stu-id="bd074-146">Actors are distributed across hello partitions of hello Actor Service, and those partitions are distributed across hello nodes in a Service Fabric cluster.</span></span> <span data-ttu-id="bd074-147">Każda partycja usługi zawiera zestaw złośliwych użytkowników.</span><span class="sxs-lookup"><span data-stu-id="bd074-147">Each service partition contains a set of actors.</span></span> <span data-ttu-id="bd074-148">Usługa Service Fabric zarządza dystrybucji i pracy awaryjnej hello partycji usługi.</span><span class="sxs-lookup"><span data-stu-id="bd074-148">Service Fabric manages distribution and failover of hello service partitions.</span></span>

<span data-ttu-id="bd074-149">Na przykład wdrożenie usługi aktora z partycjami dziewięć toothree, który węzłów za pomocą hello domyślne aktora partycji umieszczania może być dystrybuowane thusly:</span><span class="sxs-lookup"><span data-stu-id="bd074-149">For example, an actor service with nine partitions deployed toothree nodes using hello default actor partition placement would be distributed thusly:</span></span>

![Niezawodne dystrybucji złośliwych użytkowników][2]

<span data-ttu-id="bd074-151">Witaj Framework aktora zarządza ustawieniami partycji schemat i klawisz zakresu dla Ciebie.</span><span class="sxs-lookup"><span data-stu-id="bd074-151">hello Actor Framework manages partition scheme and key range settings for you.</span></span> <span data-ttu-id="bd074-152">Upraszcza niektóre opcje, ale również zajmuje kilka brany pod uwagę:</span><span class="sxs-lookup"><span data-stu-id="bd074-152">This simplifies some choices but also carries some consideration:</span></span>

* <span data-ttu-id="bd074-153">Niezawodne usługi umożliwia toochoose schemat partycjonowania klucza zakresu (w przypadku używania zakres schemat partycjonowania), a liczba partycji.</span><span class="sxs-lookup"><span data-stu-id="bd074-153">Reliable Services allows you toochoose a partitioning scheme, key range (when using a range partitioning scheme), and partition count.</span></span> <span data-ttu-id="bd074-154">Reliable Actors jest schemat partycjonowania toohello ograniczony zakres (hello jednolity schemat Int64) i wymaga się, że używasz pełnego zakresu klucza hello Int64.</span><span class="sxs-lookup"><span data-stu-id="bd074-154">Reliable Actors is restricted toohello range partitioning scheme (hello uniform Int64 scheme) and requires you use hello full Int64 key range.</span></span>
* <span data-ttu-id="bd074-155">Domyślnie podmiotów losowo są umieszczane w partycji co uniform dystrybucji.</span><span class="sxs-lookup"><span data-stu-id="bd074-155">By default, actors are randomly placed into partitions resulting in uniform distribution.</span></span>
* <span data-ttu-id="bd074-156">Ponieważ podmiotów losowo znajdują się, powinien oczekiwano, że operacje aktora zawsze wymagają komunikacji w sieci, w tym serializacji i deserializacji obiektu danych wywołania metody, ponoszenia opóźnienia i koszty.</span><span class="sxs-lookup"><span data-stu-id="bd074-156">Because actors are randomly placed, it should be expected that actor operations will always require network communication, including serialization and deserialization of method call data, incurring latency and overhead.</span></span>
* <span data-ttu-id="bd074-157">W zaawansowanych scenariuszach jest możliwe toocontrol aktora partycji umieszczania przy użyciu aktora Int64 identyfikatorów, które mapują toospecific partycji.</span><span class="sxs-lookup"><span data-stu-id="bd074-157">In advanced scenarios, it is possible toocontrol actor partition placement by using Int64 actor IDs that map toospecific partitions.</span></span> <span data-ttu-id="bd074-158">Jednak to tak może spowodować niezrównoważonej dystrybucji podmiotów na partycje.</span><span class="sxs-lookup"><span data-stu-id="bd074-158">However, doing so can result in an unbalanced distribution of actors across partitions.</span></span>

<span data-ttu-id="bd074-159">Więcej informacji dotyczących sposobu usługi aktora są podzielone na partycje, można znaleźć zbyt[partycjonowania pojęcia osób](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span><span class="sxs-lookup"><span data-stu-id="bd074-159">For more information on how actor services are partitioned, refer too[partitioning concepts for actors](service-fabric-reliable-actors-platform.md#service-fabric-partition-concepts-for-actors).</span></span>

### <a name="actor-communication"></a><span data-ttu-id="bd074-160">Komunikacja aktora</span><span class="sxs-lookup"><span data-stu-id="bd074-160">Actor communication</span></span>
<span data-ttu-id="bd074-161">Interakcje aktora są definiowane w interfejs, który jest współużytkowany przez aktora hello, który implementuje interfejs hello i powitania klienta, który pobiera serwer proxy aktora tooan za pośrednictwem hello tego samego interfejsu.</span><span class="sxs-lookup"><span data-stu-id="bd074-161">Actor interactions are defined in an interface that is shared by hello actor that implements hello interface, and hello client that gets a proxy tooan actor via hello same interface.</span></span> <span data-ttu-id="bd074-162">Ponieważ ten interfejs jest używane tooinvoke metody aktora asynchronicznie, co metoda w interfejsie hello musi być zwracanie zadań.</span><span class="sxs-lookup"><span data-stu-id="bd074-162">Because this interface is used tooinvoke actor methods asynchronously, every method on hello interface must be Task-returning.</span></span>

<span data-ttu-id="bd074-163">Wywołań metod i ich odpowiedzi ostatecznie spowodować żądania sieciowe klastra hello, tak hello argumentów i typy wyników hello zadań hello czy zwracają muszą umożliwiać serializację za pomocą platformy hello.</span><span class="sxs-lookup"><span data-stu-id="bd074-163">Method invocations and their responses ultimately result in network requests across hello cluster, so hello arguments and hello result types of hello tasks that they return must be serializable by hello platform.</span></span> <span data-ttu-id="bd074-164">W szczególności muszą być [serializacji kontraktu danych](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="bd074-164">In particular, they must be [data contract serializable](service-fabric-reliable-actors-notes-on-actor-type-serialization.md).</span></span>

#### <a name="hello-actor-proxy"></a><span data-ttu-id="bd074-165">Serwer proxy aktora Hello</span><span class="sxs-lookup"><span data-stu-id="bd074-165">hello actor proxy</span></span>
<span data-ttu-id="bd074-166">Interfejs API klienta Reliable Actors Hello zapewnia komunikację między wystąpieniem aktora i klienta aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-166">hello Reliable Actors client API provides communication between an actor instance and an actor client.</span></span> <span data-ttu-id="bd074-167">toocommunicate z aktorem, klient tworzy aktora obiekt serwera proxy, który implementuje interfejs aktora hello.</span><span class="sxs-lookup"><span data-stu-id="bd074-167">toocommunicate with an actor, a client creates an actor proxy object that implements hello actor interface.</span></span> <span data-ttu-id="bd074-168">powitania klienta współdziała z aktora hello za wywoływanie metod na powitania obiekt serwera proxy.</span><span class="sxs-lookup"><span data-stu-id="bd074-168">hello client interacts with hello actor by invoking methods on hello proxy object.</span></span> <span data-ttu-id="bd074-169">Serwer proxy aktora Hello może służyć do komunikacji klient aktora i aktora aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-169">hello actor proxy can be used for client-to-actor and actor-to-actor communication.</span></span>

```csharp
// Create a randomly distributed actor ID
ActorId actorId = ActorId.CreateRandom();

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
IMyActor myActor = ActorProxy.Create<IMyActor>(actorId, new Uri("fabric:/MyApp/MyActorService"));

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
await myActor.DoWorkAsync();
```

```java
// Create actor ID with some name
ActorId actorId = new ActorId("Actor1");

// This only creates a proxy object, it does not activate an actor or invoke any methods yet.
MyActor myActor = ActorProxyBase.create(actorId, new URI("fabric:/MyApp/MyActorService"), MyActor.class);

// This will invoke a method on hello actor. If an actor with hello given ID does not exist, it will be activated by this method call.
myActor.DoWorkAsync().get();
```


<span data-ttu-id="bd074-170">Należy pamiętać, że hello dwóch rodzajów informacji używane obiekt serwera proxy aktora hello toocreate są hello aktora identyfikator i nazwa aplikacji hello.</span><span class="sxs-lookup"><span data-stu-id="bd074-170">Note that hello two pieces of information used toocreate hello actor proxy object are hello actor ID and hello application name.</span></span> <span data-ttu-id="bd074-171">Identyfikator aktora Hello unikatowo identyfikuje aktora hello, podczas gdy nazwa aplikacji hello identyfikuje hello [aplikacji usługi Service Fabric](service-fabric-reliable-actors-platform.md#application-model) wdrożonym hello aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-171">hello actor ID uniquely identifies hello actor, while hello application name identifies hello [Service Fabric application](service-fabric-reliable-actors-platform.md#application-model) where hello actor is deployed.</span></span>

<span data-ttu-id="bd074-172">Witaj `ActorProxy`(C#) / `ActorProxyBase`klasy (Java) po stronie klienta hello wykonuje hello niezbędne rozpoznawania toolocate hello aktora według Identyfikatora i otwórz kanał komunikacji z nim.</span><span class="sxs-lookup"><span data-stu-id="bd074-172">hello `ActorProxy`(C#) / `ActorProxyBase`(Java) class on hello client side performs hello necessary resolution toolocate hello actor by ID and open a communication channel with it.</span></span> <span data-ttu-id="bd074-173">Ponowną toolocate hello aktora w przypadku hello błędy komunikacji oraz tryb failover.</span><span class="sxs-lookup"><span data-stu-id="bd074-173">It also retries toolocate hello actor in hello cases of communication failures and failovers.</span></span> <span data-ttu-id="bd074-174">W związku z tym dostarczanie komunikatów ma hello następujące cechy:</span><span class="sxs-lookup"><span data-stu-id="bd074-174">As a result, message delivery has hello following characteristics:</span></span>

* <span data-ttu-id="bd074-175">Dostarczanie komunikatów to optymalne rozwiązanie.</span><span class="sxs-lookup"><span data-stu-id="bd074-175">Message delivery is best effort.</span></span>
* <span data-ttu-id="bd074-176">Złośliwych użytkowników może odbierać komunikaty zduplikowane z hello tego samego klienta.</span><span class="sxs-lookup"><span data-stu-id="bd074-176">Actors may receive duplicate messages from hello same client.</span></span>

### <a name="concurrency"></a><span data-ttu-id="bd074-177">Współbieżność</span><span class="sxs-lookup"><span data-stu-id="bd074-177">Concurrency</span></span>
<span data-ttu-id="bd074-178">środowisko uruchomieniowe Reliable Actors Hello udostępnia model prosty dostęp za pośrednictwem Włącz do uzyskiwania dostępu do metody aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-178">hello Reliable Actors runtime provides a simple turn-based access model for accessing actor methods.</span></span> <span data-ttu-id="bd074-179">Oznacza to, że nie więcej niż jeden wątek może być aktywny wewnątrz kodu obiektu aktora w dowolnym momencie.</span><span class="sxs-lookup"><span data-stu-id="bd074-179">This means that no more than one thread can be active inside an actor object's code at any time.</span></span> <span data-ttu-id="bd074-180">Włącz dostęp przez Internet jest znacznie ułatwione równoczesnych systemów jako nie istnieje potrzeba mechanizmów synchronizacji dla dostępu do danych.</span><span class="sxs-lookup"><span data-stu-id="bd074-180">Turn-based access greatly simplifies concurrent systems as there is no need for synchronization mechanisms for data access.</span></span> <span data-ttu-id="bd074-181">Ponadto oznacza to, że systemy musi zostać zaprojektowana z uwagi dotyczące hello jednowątkowym dostępu charakter każdego wystąpienia aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-181">It also means systems must be designed with special considerations for hello single-threaded access nature of each actor instance.</span></span>

* <span data-ttu-id="bd074-182">Aktora pojedynczego wystąpienia nie może przetworzyć więcej niż jedno żądanie naraz.</span><span class="sxs-lookup"><span data-stu-id="bd074-182">A single actor instance cannot process more than one request at a time.</span></span> <span data-ttu-id="bd074-183">Wystąpienie aktora może spowodować wąskie gardło przepływności, jeżeli jest oczekiwany toohandle równoczesnych żądań.</span><span class="sxs-lookup"><span data-stu-id="bd074-183">An actor instance can cause a throughput bottleneck if it is expected toohandle concurrent requests.</span></span>
* <span data-ttu-id="bd074-184">Złośliwych użytkowników można zakleszczenie od siebie wzajemnie, jeśli żądanie cykliczne między dwoma uczestnikami podczas zewnętrznych żądań tooone hello złośliwych użytkowników jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="bd074-184">Actors can deadlock on each other if there is a circular request between two actors while an external request is made tooone of hello actors simultaneously.</span></span> <span data-ttu-id="bd074-185">Hello aktora środowiska uruchomieniowego zostanie automatycznie czas na aktora wywołuje i zgłosić wyjątek toohello wywołującego toointerrupt sytuacji możliwe zakleszczenie.</span><span class="sxs-lookup"><span data-stu-id="bd074-185">hello actor runtime will automatically time out on actor calls and throw an exception toohello caller toointerrupt possible deadlock situations.</span></span>

![Niezawodna komunikacja złośliwych użytkowników][3]

#### <a name="turn-based-access"></a><span data-ttu-id="bd074-187">Włącz dostęp przez Internet</span><span class="sxs-lookup"><span data-stu-id="bd074-187">Turn-based access</span></span>
<span data-ttu-id="bd074-188">Włącz składa się z hello ukończenie metodę aktora w żądaniu tooa odpowiedzi od innych uczestników lub klientów lub hello ukończenie [czasomierza/monitu](service-fabric-reliable-actors-timers-reminders.md) wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="bd074-188">A turn consists of hello complete execution of an actor method in response tooa request from other actors or clients, or hello complete execution of a [timer/reminder](service-fabric-reliable-actors-timers-reminders.md) callback.</span></span> <span data-ttu-id="bd074-189">Mimo że te metody i wywołania zwrotne są asynchroniczne, hello złośliwych użytkowników w czasie wykonywania nie interleave je.</span><span class="sxs-lookup"><span data-stu-id="bd074-189">Even though these methods and callbacks are asynchronous, hello Actors runtime does not interleave them.</span></span> <span data-ttu-id="bd074-190">Włącz muszą być całkowicie przed Włącz nowe jest dozwolone.</span><span class="sxs-lookup"><span data-stu-id="bd074-190">A turn must be fully finished before a new turn is allowed.</span></span> <span data-ttu-id="bd074-191">Innymi słowy aktora metody lub czasomierza/monitu wywołania zwrotnego, które jest aktualnie wykonywany musi być w pełni ukończone przed metodą tooa wywołania lub wywołania zwrotnego jest dozwolone.</span><span class="sxs-lookup"><span data-stu-id="bd074-191">In other words, an actor method or timer/reminder callback that is currently executing must be fully finished before a new call tooa method or callback is allowed.</span></span> <span data-ttu-id="bd074-192">Metoda lub wywołania zwrotnego jest uważany za toohave Zakończono wykonanie hello zwrócił z metody hello lub wywołania zwrotnego i hello zadań zwróconych przez metodę hello lub wywołanie zwrotne zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="bd074-192">A method or callback is considered toohave finished if hello execution has returned from hello method or callback and hello task returned by hello method or callback has finished.</span></span> <span data-ttu-id="bd074-193">Warto akcentowania się, że ten współbieżności opartej na włączanie jest przestrzegana nawet między różnymi metodami, czasomierze i wywołania zwrotne.</span><span class="sxs-lookup"><span data-stu-id="bd074-193">It is worth emphasizing that turn-based concurrency is respected even across different methods, timers, and callbacks.</span></span>

<span data-ttu-id="bd074-194">Hello złośliwych użytkowników w czasie wykonywania wymusza współbieżności opartej na ruch przez uzyskiwanie blokady dla aktora początku hello Włącz i zwalniania blokady hello na końcu hello hello włączyć.</span><span class="sxs-lookup"><span data-stu-id="bd074-194">hello Actors runtime enforces turn-based concurrency by acquiring a per-actor lock at hello beginning of a turn and releasing hello lock at hello end of hello turn.</span></span> <span data-ttu-id="bd074-195">W związku z tym współbieżności opartej na włączanie są wymuszane na podstawie na aktora, a nie przez złośliwych użytkowników.</span><span class="sxs-lookup"><span data-stu-id="bd074-195">Thus, turn-based concurrency is enforced on a per-actor basis and not across actors.</span></span> <span data-ttu-id="bd074-196">Metody aktora i wywołania zwrotne czasomierza/monitu mogą być wykonywane jednocześnie imieniu uczestników.</span><span class="sxs-lookup"><span data-stu-id="bd074-196">Actor methods and timer/reminder callbacks can execute simultaneously on behalf of different actors.</span></span>

<span data-ttu-id="bd074-197">Witaj poniższy przykład przedstawia hello powyżej pojęcia.</span><span class="sxs-lookup"><span data-stu-id="bd074-197">hello following example illustrates hello above concepts.</span></span> <span data-ttu-id="bd074-198">Należy wziąć pod uwagę aktora typu, który implementuje dwóch metod asynchronicznych (powiedzieć *metoda1* i *metoda2*), a czasomierza oraz monitu.</span><span class="sxs-lookup"><span data-stu-id="bd074-198">Consider an actor type that implements two asynchronous methods (say, *Method1* and *Method2*), a timer, and a reminder.</span></span> <span data-ttu-id="bd074-199">Hello poniższym diagramie przedstawiono oś czasu wykonywania hello tych metod i wywołania zwrotne w imieniu dwóch uczestników (*ActorId1* i *ActorId2*) należących toothis typ aktora.</span><span class="sxs-lookup"><span data-stu-id="bd074-199">hello diagram below shows an example of a timeline for hello execution of these methods and callbacks on behalf of two actors (*ActorId1* and *ActorId2*) that belong toothis actor type.</span></span>

![Niezawodne podmiotów środowiska uruchomieniowego Włącz współbieżności opartej i dostępem][1]

<span data-ttu-id="bd074-201">Ten diagram jest zgodna z konwencjami te:</span><span class="sxs-lookup"><span data-stu-id="bd074-201">This diagram follows these conventions:</span></span>

* <span data-ttu-id="bd074-202">Każdy pionowym wierszem przedstawia przepływ logiczny hello wykonania metody lub wywołania zwrotnego w imieniu aktora określonego.</span><span class="sxs-lookup"><span data-stu-id="bd074-202">Each vertical line shows hello logical flow of execution of a method or a callback on behalf of a particular actor.</span></span>
* <span data-ttu-id="bd074-203">zdarzenia Hello oznaczone w każdym wierszu pionowy wystąpić w kolejności chronologicznej z nowszych zdarzeń występujących poniżej starsze.</span><span class="sxs-lookup"><span data-stu-id="bd074-203">hello events marked on each vertical line occur in chronological order, with newer events occurring below older ones.</span></span>
* <span data-ttu-id="bd074-204">Różne kolory odpowiednich osób toodifferent osi czasu.</span><span class="sxs-lookup"><span data-stu-id="bd074-204">Different colors are used for timelines corresponding toodifferent actors.</span></span>
* <span data-ttu-id="bd074-205">Wyróżnianie to używane tooindicate hello duration, dla których hello blokady dla aktora jest przechowywany w imieniu metody lub wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="bd074-205">Highlighting is used tooindicate hello duration for which hello per-actor lock is held on behalf of a method or callback.</span></span>

<span data-ttu-id="bd074-206">Niektóre tooconsider ważne kwestie:</span><span class="sxs-lookup"><span data-stu-id="bd074-206">Some important points tooconsider:</span></span>

* <span data-ttu-id="bd074-207">Gdy *metoda1* jest wykonywane dla *ActorId2* w żądaniu tooclient odpowiedzi *xyz789*, inne żądanie klienta (*abc123*) dociera, który wymaga także *metoda1* toobe wykonywane przez *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="bd074-207">While *Method1* is executing on behalf of *ActorId2* in response tooclient request *xyz789*, another client request (*abc123*) arrives that also requires *Method1* toobe executed by *ActorId2*.</span></span> <span data-ttu-id="bd074-208">Jednak hello drugiego wykonywania *metoda1* nie zaczyna się przed zakończeniem wykonywania wcześniejsze hello.</span><span class="sxs-lookup"><span data-stu-id="bd074-208">However, hello second execution of *Method1* does not begin until hello prior execution has finished.</span></span> <span data-ttu-id="bd074-209">Podobnie, przypomnienia zarejestrowany przez *ActorId2* uruchamiany podczas *metoda1* jest wykonywana w żądaniu tooclient odpowiedzi *xyz789*.</span><span class="sxs-lookup"><span data-stu-id="bd074-209">Similarly, a reminder registered by *ActorId2* fires while *Method1* is being executed in response tooclient request *xyz789*.</span></span> <span data-ttu-id="bd074-210">Witaj monitu wywołania zwrotnego jest wykonywany tylko po obu wykonania *metoda1* są spełnione.</span><span class="sxs-lookup"><span data-stu-id="bd074-210">hello reminder callback is executed only after both executions of *Method1* are complete.</span></span> <span data-ttu-id="bd074-211">Wszystko to jest ze względu na podstawie tooturn współbieżności wymuszany dla *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="bd074-211">All of this is due tooturn-based concurrency being enforced for *ActorId2*.</span></span>
* <span data-ttu-id="bd074-212">Podobnie, współbieżności opartej na ruch jest również wymuszane dla *ActorId1*, jak to pokazano przez wykonanie hello *metoda1*, *metoda2*, i hello wywołanie zwrotne czasomierza zastępczy *ActorId1* wykonywane w sposób szeregowego.</span><span class="sxs-lookup"><span data-stu-id="bd074-212">Similarly, turn-based concurrency is also enforced for *ActorId1*, as demonstrated by hello execution of *Method1*, *Method2*, and hello timer callback on behalf of *ActorId1* happening in a serial fashion.</span></span>
* <span data-ttu-id="bd074-213">Wykonywanie *metoda1* zastępczy *ActorId1* pokrywa się z jej wykonanie w imieniu *ActorId2*.</span><span class="sxs-lookup"><span data-stu-id="bd074-213">Execution of *Method1* on behalf of *ActorId1* overlaps with its execution on behalf of *ActorId2*.</span></span> <span data-ttu-id="bd074-214">Jest to spowodowane współbieżności opartej na włączanie są wymuszane tylko w obrębie aktora, a nie przez złośliwych użytkowników.</span><span class="sxs-lookup"><span data-stu-id="bd074-214">This is because turn-based concurrency is enforced only within an actor and not across actors.</span></span>
* <span data-ttu-id="bd074-215">W niektórych wykonania metody/wywołania zwrotnego hello hello `Task`(C#) / `CompletableFuture`(Java) zwracane przez zakończenie metody/wywołania zwrotnego hello, po powrocie hello metody.</span><span class="sxs-lookup"><span data-stu-id="bd074-215">In some of hello method/callback executions, hello `Task`(C#) / `CompletableFuture`(Java) returned by hello method/callback finishes after hello method returns.</span></span> <span data-ttu-id="bd074-216">W niektórych innych hello asynchronicznej operacji zostało już zakończone przez czas hello zwraca metody hello/wywołania zwrotnego.</span><span class="sxs-lookup"><span data-stu-id="bd074-216">In some others, hello asynchronous operation has already finished by hello time hello method/callback returns.</span></span> <span data-ttu-id="bd074-217">W obu przypadkach blokady dla aktora hello jest zwalniany dopiero po zwraca zarówno hello metody/wywołania zwrotnego i zakończeniu operacji asynchronicznej hello.</span><span class="sxs-lookup"><span data-stu-id="bd074-217">In both cases, hello per-actor lock is released only after both hello method/callback returns and hello asynchronous operation finishes.</span></span>

#### <a name="reentrancy"></a><span data-ttu-id="bd074-218">Wielobieżność</span><span class="sxs-lookup"><span data-stu-id="bd074-218">Reentrancy</span></span>
<span data-ttu-id="bd074-219">środowisko uruchomieniowe podmiotów Hello umożliwia ponowne wejście domyślnie.</span><span class="sxs-lookup"><span data-stu-id="bd074-219">hello Actors runtime allows reentrancy by default.</span></span> <span data-ttu-id="bd074-220">Oznacza to, że jeśli metoda aktora *aktora A* wywołuje metodę dla *B aktora*, który z kolei wywołuje innej metody w *aktora A*, że metoda jest dozwolona toorun.</span><span class="sxs-lookup"><span data-stu-id="bd074-220">This means that if an actor method of *Actor A* calls a method on *Actor B*, which in turn calls another method on *Actor A*, that method is allowed toorun.</span></span> <span data-ttu-id="bd074-221">Jest to, ponieważ jest ona częścią hello tego samego kontekstu logicznej łańcuch wywołań.</span><span class="sxs-lookup"><span data-stu-id="bd074-221">This is because it is part of hello same logical call-chain context.</span></span> <span data-ttu-id="bd074-222">Wszystkie wywołania zegara i monitu rozpoczynać hello nowy kontekst wywołania logiczne.</span><span class="sxs-lookup"><span data-stu-id="bd074-222">All timer and reminder calls start with hello new logical call context.</span></span> <span data-ttu-id="bd074-223">Zobacz hello [wielobieżność Reliable Actors](service-fabric-reliable-actors-reentrancy.md) więcej szczegółów.</span><span class="sxs-lookup"><span data-stu-id="bd074-223">See hello [Reliable Actors reentrancy](service-fabric-reliable-actors-reentrancy.md) for more details.</span></span>

#### <a name="scope-of-concurrency-guarantees"></a><span data-ttu-id="bd074-224">Zakres gwarancji współbieżności</span><span class="sxs-lookup"><span data-stu-id="bd074-224">Scope of concurrency guarantees</span></span>
<span data-ttu-id="bd074-225">środowisko uruchomieniowe podmiotów Hello zapewnia te gwarancje współbieżności w sytuacjach, w którym kontroluje hello wywołania tych metod.</span><span class="sxs-lookup"><span data-stu-id="bd074-225">hello Actors runtime provides these concurrency guarantees in situations where it controls hello invocation of these methods.</span></span> <span data-ttu-id="bd074-226">Na przykład zapewnia te gwarancje dla wywołań metod hello, które są wykonywane w żądaniu klienta tooa odpowiedzi, a także wywołania zwrotne czasomierza i przypomnienia.</span><span class="sxs-lookup"><span data-stu-id="bd074-226">For example, it provides these guarantees for hello method invocations that are done in response tooa client request, as well as for timer and reminder callbacks.</span></span> <span data-ttu-id="bd074-227">Jeśli jednak hello aktora kodu bezpośrednio wywołuje tych metod poza mechanizmów hello udostępnianych przez hello złośliwych użytkowników w czasie wykonywania, następnie hello środowiska uruchomieniowego nie zawiera żadnej gwarancji współbieżności.</span><span class="sxs-lookup"><span data-stu-id="bd074-227">However, if hello actor code directly invokes these methods outside of hello mechanisms provided by hello Actors runtime, then hello runtime cannot provide any concurrency guarantees.</span></span> <span data-ttu-id="bd074-228">Na przykład jeśli hello metoda jest wywoływana w kontekście hello niektórych zadań, która nie jest skojarzona z zadaniem hello zwracane przez metody aktora hello, następnie hello runtime nie może zagwarantować współbieżności.</span><span class="sxs-lookup"><span data-stu-id="bd074-228">For example, if hello method is invoked in hello context of some task that is not associated with hello task returned by hello actor methods, then hello runtime cannot provide concurrency guarantees.</span></span> <span data-ttu-id="bd074-229">Jeśli metoda hello jest wywoływana z wątku tego aktora hello tworzy na jego własnej, a następnie środowiska uruchomieniowego hello także nie może zagwarantować współbieżności.</span><span class="sxs-lookup"><span data-stu-id="bd074-229">If hello method is invoked from a thread that hello actor creates on its own, then hello runtime also cannot provide concurrency guarantees.</span></span> <span data-ttu-id="bd074-230">W związku z tym operacje w tle tooperform złośliwych użytkowników należy używać [aktora czasomierze i przypomnieniami aktora](service-fabric-reliable-actors-timers-reminders.md) który przestrzegać współbieżności opartej na ruch.</span><span class="sxs-lookup"><span data-stu-id="bd074-230">Therefore, tooperform background operations, actors should use [actor timers and actor reminders](service-fabric-reliable-actors-timers-reminders.md) that respect turn-based concurrency.</span></span>

## <a name="next-steps"></a><span data-ttu-id="bd074-231">Następne kroki</span><span class="sxs-lookup"><span data-stu-id="bd074-231">Next steps</span></span>
* <span data-ttu-id="bd074-232">Rozpoczynanie pracy przez utworzenie pierwszej usługi Reliable Actors:</span><span class="sxs-lookup"><span data-stu-id="bd074-232">Get started by building your first Reliable Actors service:</span></span>
   * [<span data-ttu-id="bd074-233">Wprowadzenie do korzystania z Reliable Actors na platformie .NET</span><span class="sxs-lookup"><span data-stu-id="bd074-233">Getting started with Reliable Actors on .NET</span></span>](service-fabric-reliable-actors-get-started.md)
   * [<span data-ttu-id="bd074-234">Wprowadzenie do korzystania z Reliable Actors na języku Java</span><span class="sxs-lookup"><span data-stu-id="bd074-234">Getting started with Reliable Actors on Java</span></span>](service-fabric-reliable-actors-get-started-java.md)

<!--Image references-->
[1]: ./media/service-fabric-reliable-actors-introduction/concurrency.png
[2]: ./media/service-fabric-reliable-actors-introduction/distribution.png
[3]: ./media/service-fabric-reliable-actors-introduction/actor-communication.png
