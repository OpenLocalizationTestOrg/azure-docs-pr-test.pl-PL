---
title: "Przegląd cyklu życia Azure Usługa sieci szkieletowej niezawodnej usługi | Dokumentacja firmy Microsoft"
description: "Więcej informacji na temat zdarzeń różnych cyklu życia w sieci szkieletowej usług niezawodne usługi"
services: Service-Fabric
documentationcenter: .net
author: masnider
manager: timlt
editor: vturecek;
ms.assetid: 
ms.service: Service-Fabric
ms.devlang: dotnet
ms.topic: article
ms.tgt_pltfrm: NA
ms.workload: NA
ms.date: 08/18/2017
ms.author: masnider
ms.openlocfilehash: 16021ca72a2f10070b6409417ff0d88009591331
ms.sourcegitcommit: 50e23e8d3b1148ae2d36dad3167936b4e52c8a23
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 08/18/2017
---
# <a name="reliable-services-lifecycle-overview"></a><span data-ttu-id="7de31-103">Przegląd cyklu życia niezawodne usługi</span><span class="sxs-lookup"><span data-stu-id="7de31-103">Reliable services lifecycle overview</span></span>
> [!div class="op_single_selector"]
> * [<span data-ttu-id="7de31-104">C# w systemie Windows</span><span class="sxs-lookup"><span data-stu-id="7de31-104">C# on Windows</span></span>](service-fabric-reliable-services-lifecycle.md)
> * [<span data-ttu-id="7de31-105">Java w systemie Linux</span><span class="sxs-lookup"><span data-stu-id="7de31-105">Java on Linux</span></span>](service-fabric-reliable-services-lifecycle-java.md)
>
>

<span data-ttu-id="7de31-106">Rozważania na temat cykli niezawodnych usług, podstawowe informacje o cyklu życia są najważniejsze.</span><span class="sxs-lookup"><span data-stu-id="7de31-106">When thinking about the lifecycles of Reliable Services, the basics of the lifecycle are the most important.</span></span> <span data-ttu-id="7de31-107">Ogólnie rzecz biorąc:</span><span class="sxs-lookup"><span data-stu-id="7de31-107">In general:</span></span>

- <span data-ttu-id="7de31-108">Podczas uruchamiania</span><span class="sxs-lookup"><span data-stu-id="7de31-108">During Startup</span></span>
  - <span data-ttu-id="7de31-109">Usługi są wykonane</span><span class="sxs-lookup"><span data-stu-id="7de31-109">Services are constructed</span></span>
  - <span data-ttu-id="7de31-110">Mają możliwość utworzenia i zwraca zero lub więcej obiektów nasłuchujących</span><span class="sxs-lookup"><span data-stu-id="7de31-110">They have an opportunity to construct and return zero or more listeners</span></span>
  - <span data-ttu-id="7de31-111">Wszystkie zwracane obiekty nasłuchujące są otwarte, zezwolenie na komunikację z usługą</span><span class="sxs-lookup"><span data-stu-id="7de31-111">Any returned listeners are opened, allowing communication with the service</span></span>
  - <span data-ttu-id="7de31-112">Wywoływana jest metoda RunAsync usługi, dzięki czemu usługa długo działa lub pracy w tle</span><span class="sxs-lookup"><span data-stu-id="7de31-112">The Service's RunAsync method is called, allowing the service to do long running or background work</span></span>
- <span data-ttu-id="7de31-113">Podczas zamykania</span><span class="sxs-lookup"><span data-stu-id="7de31-113">During shutdown</span></span>
  - <span data-ttu-id="7de31-114">Token anulowania przekazany do RunAsync została anulowana, a odbiorniki są zamknięte</span><span class="sxs-lookup"><span data-stu-id="7de31-114">The cancellation token passed to RunAsync is canceled, and the listeners are closed</span></span>
  - <span data-ttu-id="7de31-115">To znaczy po zakończeniu sam obiekt usługi jest niszczone</span><span class="sxs-lookup"><span data-stu-id="7de31-115">Once that is complete, the service object itself is destructed</span></span>

<span data-ttu-id="7de31-116">Brak szczegółów wokół dokładne kolejność tych zdarzeń.</span><span class="sxs-lookup"><span data-stu-id="7de31-116">There are details around the exact ordering of these events.</span></span> <span data-ttu-id="7de31-117">W szczególności kolejność zdarzeń mogą się nieznacznie zmieniać w zależności od tego, czy usługa niezawodnej jest Stateless lub Stateful.</span><span class="sxs-lookup"><span data-stu-id="7de31-117">In particular, the order of events may change slightly depending on whether the Reliable Service is Stateless or Stateful.</span></span> <span data-ttu-id="7de31-118">Ponadto usługi stanowej, zostały radzenia sobie z scenariusz podstawowy wymiany.</span><span class="sxs-lookup"><span data-stu-id="7de31-118">In addition, for stateful services, we have to deal with the Primary swap scenario.</span></span> <span data-ttu-id="7de31-119">Podczas tej sekwencji rolę podstawową jest przenoszona do innej repliki (lub wróci) bez zamknięcie usługi.</span><span class="sxs-lookup"><span data-stu-id="7de31-119">During this sequence, the role of Primary is transferred to another replica (or comes back) without the service shutting down.</span></span> <span data-ttu-id="7de31-120">Na koniec mamy Pomyśl o warunkach błędu lub niepowodzenie.</span><span class="sxs-lookup"><span data-stu-id="7de31-120">Finally, we have to think about error or failure conditions.</span></span>

## <a name="stateless-service-startup"></a><span data-ttu-id="7de31-121">Uruchamianie usługi bezstanowej</span><span class="sxs-lookup"><span data-stu-id="7de31-121">Stateless service startup</span></span>
<span data-ttu-id="7de31-122">Cykl życia usługi bezstanowej jest bardzo prosta.</span><span class="sxs-lookup"><span data-stu-id="7de31-122">The lifecycle of a stateless service is fairly straightforward.</span></span> <span data-ttu-id="7de31-123">Poniżej przedstawiono kolejność zdarzeń:</span><span class="sxs-lookup"><span data-stu-id="7de31-123">Here's the order of events:</span></span>

1. <span data-ttu-id="7de31-124">Usługa jest tworzony</span><span class="sxs-lookup"><span data-stu-id="7de31-124">The Service is constructed</span></span>
2. <span data-ttu-id="7de31-125">Następnie w dwie czynności równoległe stanie:</span><span class="sxs-lookup"><span data-stu-id="7de31-125">Then, in parallel two things happen:</span></span>
    - <span data-ttu-id="7de31-126">`StatelessService.CreateServiceInstanceListeners()`jest wywoływany i wszystkie zwracane obiekty nasłuchujące są otwarte.</span><span class="sxs-lookup"><span data-stu-id="7de31-126">`StatelessService.CreateServiceInstanceListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="7de31-127">`ICommunicationListener.OpenAsync()`jest wywoływane dla każdego odbiornika</span><span class="sxs-lookup"><span data-stu-id="7de31-127">`ICommunicationListener.OpenAsync()` is called on each listener</span></span>
    - <span data-ttu-id="7de31-128">Usługi `StatelessService.RunAsync()` metoda jest wywoływana</span><span class="sxs-lookup"><span data-stu-id="7de31-128">The service's `StatelessService.RunAsync()` method is called</span></span>
3. <span data-ttu-id="7de31-129">Jeśli jest obecny, usługi `StatelessService.OnOpenAsync()` metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7de31-129">If present, the service's `StatelessService.OnOpenAsync()` method is called.</span></span> <span data-ttu-id="7de31-130">Jest to rzadko zastąpienia, ale jest ona dostępna.</span><span class="sxs-lookup"><span data-stu-id="7de31-130">This is an uncommon override, but it is available.</span></span>

<span data-ttu-id="7de31-131">Należy koniecznie należy pamiętać, że nie kolejność nie między wywołaniami do tworzenia i otwierania odbiorników i RunAsync.</span><span class="sxs-lookup"><span data-stu-id="7de31-131">It is important to note that there is no ordering between the calls to create and open the listeners and RunAsync.</span></span> <span data-ttu-id="7de31-132">Przed rozpoczęciem RunAsync odbiorniki może zostać otwarty.</span><span class="sxs-lookup"><span data-stu-id="7de31-132">The listeners may open before RunAsync is started.</span></span> <span data-ttu-id="7de31-133">Podobnie RunAsync może się okazać wywoływane przed odbiorników komunikacji są otwarte lub nawet zostały wykonane.</span><span class="sxs-lookup"><span data-stu-id="7de31-133">Similarly, RunAsync may end up invoked before the communication listeners are open or have even been constructed.</span></span> <span data-ttu-id="7de31-134">Jeśli wymagana jest każdej synchronizacji, jest pozostawiany bez jako wykonywania do implementujący.</span><span class="sxs-lookup"><span data-stu-id="7de31-134">If any synchronization is required, it is left as an exercise to the implementer.</span></span> <span data-ttu-id="7de31-135">Typowe rozwiązania:</span><span class="sxs-lookup"><span data-stu-id="7de31-135">Common solutions:</span></span>

  - <span data-ttu-id="7de31-136">Czasami odbiorników nie może działać, dopóki niektóre informacje o utworzeniu lub pracy wykonanej.</span><span class="sxs-lookup"><span data-stu-id="7de31-136">Sometimes listeners can't function until some other information is created or work done.</span></span> <span data-ttu-id="7de31-137">Dla usług bezstanowych, które pracy zwykle można zrobić w innych lokalizacjach, takich jak:</span><span class="sxs-lookup"><span data-stu-id="7de31-137">For stateless services that work can usually be done in other locations, such as:</span></span> 
    - <span data-ttu-id="7de31-138">w Konstruktorze tej usługi</span><span class="sxs-lookup"><span data-stu-id="7de31-138">in the service's constructor</span></span>
    - <span data-ttu-id="7de31-139">Podczas `CreateServiceInstanceListeners()` wywołania</span><span class="sxs-lookup"><span data-stu-id="7de31-139">during the `CreateServiceInstanceListeners()` call</span></span>
    - <span data-ttu-id="7de31-140">jako część konstrukcji samego odbiornika</span><span class="sxs-lookup"><span data-stu-id="7de31-140">as a part of the construction of the listener itself</span></span>
  - <span data-ttu-id="7de31-141">Czasami kod w RunAsync nie ma się rozpocząć, dopóki odbiorniki są otwarte.</span><span class="sxs-lookup"><span data-stu-id="7de31-141">Sometimes the code in RunAsync does not want to start until the listeners are open.</span></span> <span data-ttu-id="7de31-142">W takim przypadku niezbędne jest dodatkowe koordynacji.</span><span class="sxs-lookup"><span data-stu-id="7de31-142">In this case additional coordination is necessary.</span></span> <span data-ttu-id="7de31-143">Jednym z typowych rozwiązań jest niektórych flagi w odbiorników wskazujący po zakończeniu.</span><span class="sxs-lookup"><span data-stu-id="7de31-143">One common solution is some flag within the listeners indicating when they have completed.</span></span> <span data-ttu-id="7de31-144">Ta flaga jest sprawdzany w RunAsync przed kontynuowaniem pracy rzeczywistej.</span><span class="sxs-lookup"><span data-stu-id="7de31-144">This flag is then checked in RunAsync before continuing to actual work.</span></span>

## <a name="stateless-service-shutdown"></a><span data-ttu-id="7de31-145">Zamykanie usługi bezstanowej</span><span class="sxs-lookup"><span data-stu-id="7de31-145">Stateless service shutdown</span></span>
<span data-ttu-id="7de31-146">Podczas zamykania usługi bezstanowej, tego samego wzorca jest wykonać tylko w odwrotnej:</span><span class="sxs-lookup"><span data-stu-id="7de31-146">When shutting down a stateless service, the same pattern is followed, just in reverse:</span></span>

1. <span data-ttu-id="7de31-147">Równoległe</span><span class="sxs-lookup"><span data-stu-id="7de31-147">In parallel</span></span>
    - <span data-ttu-id="7de31-148">Są zamykane wszystkie otwarte odbiorników.</span><span class="sxs-lookup"><span data-stu-id="7de31-148">Any open listeners are Closed.</span></span> <span data-ttu-id="7de31-149">`ICommunicationListener.CloseAsync()`jest wywoływana na każdym odbiornika.</span><span class="sxs-lookup"><span data-stu-id="7de31-149">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="7de31-150">Token anulowania przekazany do `RunAsync()` zostało anulowane.</span><span class="sxs-lookup"><span data-stu-id="7de31-150">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="7de31-151">Sprawdzanie token anulowania `IsCancellationRequested` właściwość zwraca wartość true i wywołuje tokenu `ThrowIfCancellationRequested` metoda zgłasza `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="7de31-151">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="7de31-152">Raz `CloseAsync()` uzupełnia w każdym odbiornika i `RunAsync()` również zakończeniu usługi `StatelessService.OnCloseAsync()` metoda jest wywoływana, jeśli jest obecny.</span><span class="sxs-lookup"><span data-stu-id="7de31-152">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatelessService.OnCloseAsync()` method is called, if present.</span></span> <span data-ttu-id="7de31-153">Jest rzadko do przesłonięcia `StatelessService.OnCloseAsync()`.</span><span class="sxs-lookup"><span data-stu-id="7de31-153">It is uncommon to override `StatelessService.OnCloseAsync()`.</span></span>
3. <span data-ttu-id="7de31-154">Po `StatelessService.OnCloseAsync()` zakończeniu obiekt usługi jest niszczone</span><span class="sxs-lookup"><span data-stu-id="7de31-154">After `StatelessService.OnCloseAsync()` completes, the service object is destructed</span></span>

## <a name="stateful-service-startup"></a><span data-ttu-id="7de31-155">Uruchamianie usługi stanowej</span><span class="sxs-lookup"><span data-stu-id="7de31-155">Stateful service Startup</span></span>
<span data-ttu-id="7de31-156">Usługi stanowej mają podobnego wzorca do usług bezstanowych, kilka zmian.</span><span class="sxs-lookup"><span data-stu-id="7de31-156">Stateful services have a similar pattern to stateless services, with a few changes.</span></span> <span data-ttu-id="7de31-157">Podczas uruchamiania usługi stanowej, kolejność zdarzeń wygląda następująco:</span><span class="sxs-lookup"><span data-stu-id="7de31-157">When starting up a stateful service, the order of events is as follows:</span></span>

1. <span data-ttu-id="7de31-158">Usługa jest tworzony</span><span class="sxs-lookup"><span data-stu-id="7de31-158">The Service is constructed</span></span>
2. <span data-ttu-id="7de31-159">`StatefulServiceBase.OnOpenAsync()`jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7de31-159">`StatefulServiceBase.OnOpenAsync()` is called.</span></span> <span data-ttu-id="7de31-160">To jest zastępowany uncommonly w usłudze.</span><span class="sxs-lookup"><span data-stu-id="7de31-160">This is uncommonly overridden in the service.</span></span>
3. <span data-ttu-id="7de31-161">Stanie następujących czynności równoległe</span><span class="sxs-lookup"><span data-stu-id="7de31-161">The following things happen in parallel</span></span>
    - <span data-ttu-id="7de31-162">`StatefulServiceBase.CreateServiceReplicaListeners()`jest wywoływany</span><span class="sxs-lookup"><span data-stu-id="7de31-162">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked</span></span> 
      - <span data-ttu-id="7de31-163">Jeśli usługa jest podstawowym wszystkich odbiorników zwracane są otwarte.</span><span class="sxs-lookup"><span data-stu-id="7de31-163">If the service is a Primary all returned listeners are Opened.</span></span> <span data-ttu-id="7de31-164">`ICommunicationListener.OpenAsync()`jest wywoływana na każdym odbiornika.</span><span class="sxs-lookup"><span data-stu-id="7de31-164">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
      - <span data-ttu-id="7de31-165">Jeśli usługa jest pomocniczego, tylko te odbiorniki oznaczona jako `ListenOnSecondary = true` są otwarte.</span><span class="sxs-lookup"><span data-stu-id="7de31-165">If the service is a Secondary, only those listeners marked as `ListenOnSecondary = true` are opened.</span></span> <span data-ttu-id="7de31-166">Odbiorniki otwarte na pomocnicze bazy danych jest mniej typowych.</span><span class="sxs-lookup"><span data-stu-id="7de31-166">Having listeners that are open on Secondaries is less common.</span></span>
    - <span data-ttu-id="7de31-167">Jeśli usługa jest obecnie podstawowym, usługa firmy `StatefulServiceBase.RunAsync()` metoda jest wywoływana</span><span class="sxs-lookup"><span data-stu-id="7de31-167">The if the Service is currently a Primary, the service's `StatefulServiceBase.RunAsync()` method is called</span></span>
4. <span data-ttu-id="7de31-168">Raz wszystkie repliki odbiornika dla `OpenAsync()` ukończenia wywołania i `RunAsync()` jest nazywany `StatefulServiceBase.OnChangeRoleAsync()` jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7de31-168">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` is called, `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="7de31-169">To jest zastępowany uncommonly w usłudze.</span><span class="sxs-lookup"><span data-stu-id="7de31-169">This is uncommonly overridden in the service.</span></span>

<span data-ttu-id="7de31-170">Podobnie do usług bezstanowych, nie zachodzi koordynacja między kolejności, w której odbiorniki są tworzone i otworzyć i gdy jest wywoływana RunAsync.</span><span class="sxs-lookup"><span data-stu-id="7de31-170">Similarly to stateless services, there's no coordination between the order in which the listeners are created and opened and when RunAsync is called.</span></span> <span data-ttu-id="7de31-171">Jeśli potrzebujesz koordynacji rozwiązania są znacznie takie same.</span><span class="sxs-lookup"><span data-stu-id="7de31-171">If you need coordination, the solutions are much the same.</span></span> <span data-ttu-id="7de31-172">Istnieje jeden przypadek dodatkowe: powiedzieć, że wywołania otrzymywanych odbiorników komunikacji wymaga informacje przechowywane w niektórych [niezawodnej kolekcje](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="7de31-172">THere is one additional case: say that the calls arriving at the communication listeners require information kept inside some [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="7de31-173">Ponieważ odbiorników komunikacji może otworzyć przed niezawodnej kolekcje są do odczytu lub zapisu, a przed RunAsync można uruchomić, niektóre dodatkowe koordynacji jest konieczne.</span><span class="sxs-lookup"><span data-stu-id="7de31-173">Because the communication listeners could open before the reliable collections are readable or writeable, and before RunAsync could start, some additional coordination is necessary.</span></span> <span data-ttu-id="7de31-174">Rozwiązanie najprostszym i najczęściej jest w przypadku odbiorników komunikacji do zwrócenia kodu błędu używanego przez klienta do ponowić żądanie.</span><span class="sxs-lookup"><span data-stu-id="7de31-174">The simplest and most common solution is for the communication listeners to return some error code that the client uses to know to retry the request.</span></span>

## <a name="stateful-service-shutdown"></a><span data-ttu-id="7de31-175">Zamknięcie usługi stanowej</span><span class="sxs-lookup"><span data-stu-id="7de31-175">Stateful service Shutdown</span></span>
<span data-ttu-id="7de31-176">Podobnie jak usługi bezstanowej zdarzenia cyklu życia podczas zamykania są takie same jak podczas uruchamiania, ale wycofane.</span><span class="sxs-lookup"><span data-stu-id="7de31-176">Similarly to Stateless services, the lifecycle events during shutdown are the same as during startup, but reversed.</span></span> <span data-ttu-id="7de31-177">Gdy trwa zamykanie usługi stanowej, wykonywane są następujące zdarzenia:</span><span class="sxs-lookup"><span data-stu-id="7de31-177">When a stateful service is being shut down, the following events occur:</span></span>

1. <span data-ttu-id="7de31-178">Równoległe</span><span class="sxs-lookup"><span data-stu-id="7de31-178">In parallel</span></span>
    - <span data-ttu-id="7de31-179">Są zamykane wszystkie otwarte odbiorników.</span><span class="sxs-lookup"><span data-stu-id="7de31-179">Any open listeners are Closed.</span></span> <span data-ttu-id="7de31-180">`ICommunicationListener.CloseAsync()`jest wywoływana na każdym odbiornika.</span><span class="sxs-lookup"><span data-stu-id="7de31-180">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="7de31-181">Token anulowania przekazany do `RunAsync()` zostało anulowane.</span><span class="sxs-lookup"><span data-stu-id="7de31-181">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="7de31-182">Sprawdzanie token anulowania `IsCancellationRequested` właściwość zwraca wartość true i wywołuje tokenu `ThrowIfCancellationRequested` metoda zgłasza `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="7de31-182">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="7de31-183">Raz `CloseAsync()` uzupełnia w każdym odbiornika i `RunAsync()` również zakończeniu usługi `StatefulServiceBase.OnChangeRoleAsync()` jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7de31-183">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="7de31-184">(To jest uncommonly zastąpiona w usłudze.)</span><span class="sxs-lookup"><span data-stu-id="7de31-184">(This is uncommonly overridden in the service.)</span></span>
    - <span data-ttu-id="7de31-185">Oczekiwanie na RunAsync ukończyć jest konieczne tylko wtedy, jeśli podstawowy został tej repliki usługi.</span><span class="sxs-lookup"><span data-stu-id="7de31-185">Waiting for RunAsync to complete is only necessary if this service replica was a Primary.</span></span>
3. <span data-ttu-id="7de31-186">Raz `StatefulServiceBase.OnChangeRoleAsync()` metody zakończeniu `StatefulServiceBase.OnCloseAsync()` metoda jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7de31-186">Once the `StatefulServiceBase.OnChangeRoleAsync()` method completes, the `StatefulServiceBase.OnCloseAsync()` method is called.</span></span> <span data-ttu-id="7de31-187">Jest to rzadko zastąpienia, ale jest ona dostępna.</span><span class="sxs-lookup"><span data-stu-id="7de31-187">This is an uncommon override, but it is available.</span></span>
3. <span data-ttu-id="7de31-188">Po `StatefulServiceBase.OnCloseAsync()` zakończeniu obiekt usługi jest niszczone.</span><span class="sxs-lookup"><span data-stu-id="7de31-188">After `StatefulServiceBase.OnCloseAsync()` completes, the service object is destructed.</span></span>

## <a name="stateful-service-primary-swaps"></a><span data-ttu-id="7de31-189">Zamienia głównej usługi stanowej</span><span class="sxs-lookup"><span data-stu-id="7de31-189">Stateful service primary swaps</span></span>
<span data-ttu-id="7de31-190">Uruchomionej usługi stanowej replik podstawowych tej usługi stanowej mają ich odbiorników komunikacji otwarty i ich wywołano metodę RunAsync.</span><span class="sxs-lookup"><span data-stu-id="7de31-190">While a stateful service is running, only the Primary replicas of that stateful services have their communication listeners opened and their RunAsync method called.</span></span> <span data-ttu-id="7de31-191">Pomocniczy są wykonane, ale Zobacz nie kolejne wywołania.</span><span class="sxs-lookup"><span data-stu-id="7de31-191">Secondary are constructed but see no further calls.</span></span> <span data-ttu-id="7de31-192">Po uruchomieniu usługi stanowej jednak repliki, który jest obecnie podstawową można zmienić.</span><span class="sxs-lookup"><span data-stu-id="7de31-192">While a stateful service is running however, which replica is currently the Primary can change.</span></span> <span data-ttu-id="7de31-193">Co to znaczy w kategoriach zdarzenia cyklu życia, które można wyświetlić repliki</span><span class="sxs-lookup"><span data-stu-id="7de31-193">What does this mean in terms of the lifecycle events that a replica can see?</span></span> <span data-ttu-id="7de31-194">Zachowanie, które widzi stanowe repliki zależy od tego, czy jest repliki trwa obniżyć poziom jest podwyższany podczas wymiany.</span><span class="sxs-lookup"><span data-stu-id="7de31-194">The behavior the stateful replica sees depends on whether it is the replica being demoted or promoted during the swap.</span></span>

### <a name="for-the-primary-being-demoted"></a><span data-ttu-id="7de31-195">Dla podstawowego jest obniżenie poziomu</span><span class="sxs-lookup"><span data-stu-id="7de31-195">For the primary being demoted</span></span>
<span data-ttu-id="7de31-196">Sieć szkieletowa usług musi tę replikę, aby zatrzymać przetwarzanie komunikatów i zakończyć pracę tła, których wykonywanie operacji.</span><span class="sxs-lookup"><span data-stu-id="7de31-196">Service Fabric needs this replica to stop processing messages and quit any background work it is doing.</span></span> <span data-ttu-id="7de31-197">W związku z tym ten krok jest podobny do gdy trwa zamykanie usługi.</span><span class="sxs-lookup"><span data-stu-id="7de31-197">As a result, this step looks similar to when the service is being shut down.</span></span> <span data-ttu-id="7de31-198">Jeden różnica polega na czy usługi nie jest niszczone lub zamknięte, ponieważ pozostaje pomocniczego.</span><span class="sxs-lookup"><span data-stu-id="7de31-198">One difference is that the Service isn't destructed or closed since it remains as a Secondary.</span></span> <span data-ttu-id="7de31-199">Następujące interfejsy API są nazywane:</span><span class="sxs-lookup"><span data-stu-id="7de31-199">The following APIs are called:</span></span>

1. <span data-ttu-id="7de31-200">Równoległe</span><span class="sxs-lookup"><span data-stu-id="7de31-200">In parallel</span></span>
    - <span data-ttu-id="7de31-201">Są zamykane wszystkie otwarte odbiorników.</span><span class="sxs-lookup"><span data-stu-id="7de31-201">Any open listeners are Closed.</span></span> <span data-ttu-id="7de31-202">`ICommunicationListener.CloseAsync()`jest wywoływana na każdym odbiornika.</span><span class="sxs-lookup"><span data-stu-id="7de31-202">`ICommunicationListener.CloseAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="7de31-203">Token anulowania przekazany do `RunAsync()` zostało anulowane.</span><span class="sxs-lookup"><span data-stu-id="7de31-203">The cancellation token passed to `RunAsync()` is canceled.</span></span> <span data-ttu-id="7de31-204">Sprawdzanie token anulowania `IsCancellationRequested` właściwość zwraca wartość true i wywołuje tokenu `ThrowIfCancellationRequested` metoda zgłasza `OperationCanceledException`.</span><span class="sxs-lookup"><span data-stu-id="7de31-204">Checking the cancellation token's `IsCancellationRequested` property returns true, and if called the token's `ThrowIfCancellationRequested` method throws an `OperationCanceledException`.</span></span>
2. <span data-ttu-id="7de31-205">Raz `CloseAsync()` uzupełnia w każdym odbiornika i `RunAsync()` również zakończeniu usługi `StatefulServiceBase.OnChangeRoleAsync()` jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7de31-205">Once `CloseAsync()` completes on each listener and `RunAsync()` also completes, the service's `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="7de31-206">To jest zastępowany uncommonly w usłudze.</span><span class="sxs-lookup"><span data-stu-id="7de31-206">This is uncommonly overridden in the service.</span></span>

### <a name="for-the-secondary-being-promoted"></a><span data-ttu-id="7de31-207">Na serwerze pomocniczym, której poziom jest podwyższany</span><span class="sxs-lookup"><span data-stu-id="7de31-207">For the secondary being promoted</span></span>
<span data-ttu-id="7de31-208">Podobnie sieci szkieletowej usług wymaga tej repliki rozpocząć nasłuchiwania dla wiadomości w sieci i uruchomić wszystkie zadania w tle, który go dba o.</span><span class="sxs-lookup"><span data-stu-id="7de31-208">Similarly, Service Fabric needs this replica to start listening for messages on the wire and start any background tasks it cares about.</span></span> <span data-ttu-id="7de31-209">W związku z tym ten proces jest podobny do utworzenia usługi, z wyjątkiem tego samego repliki już istnieje.</span><span class="sxs-lookup"><span data-stu-id="7de31-209">As a result, this process looks similar to when the service is created, except that the replica itself already exists.</span></span> <span data-ttu-id="7de31-210">Następujące interfejsy API są nazywane:</span><span class="sxs-lookup"><span data-stu-id="7de31-210">The following APIs are called:</span></span>

1. <span data-ttu-id="7de31-211">Równoległe</span><span class="sxs-lookup"><span data-stu-id="7de31-211">In parallel</span></span>
    - <span data-ttu-id="7de31-212">`StatefulServiceBase.CreateServiceReplicaListeners()`jest wywoływany i wszystkie zwracane obiekty nasłuchujące są otwarte.</span><span class="sxs-lookup"><span data-stu-id="7de31-212">`StatefulServiceBase.CreateServiceReplicaListeners()` is invoked and any returned listeners are Opened.</span></span> <span data-ttu-id="7de31-213">`ICommunicationListener.OpenAsync()`jest wywoływana na każdym odbiornika.</span><span class="sxs-lookup"><span data-stu-id="7de31-213">`ICommunicationListener.OpenAsync()` is called on each listener.</span></span>
    - <span data-ttu-id="7de31-214">Usługi `StatefulServiceBase.RunAsync()` metoda jest wywoływana</span><span class="sxs-lookup"><span data-stu-id="7de31-214">The service's `StatefulServiceBase.RunAsync()` method is called</span></span>
2. <span data-ttu-id="7de31-215">Raz wszystkie repliki odbiornika dla `OpenAsync()` ukończenia wywołania i `RunAsync()` została wywołana, `StatefulServiceBase.OnChangeRoleAsync()` jest wywoływana.</span><span class="sxs-lookup"><span data-stu-id="7de31-215">Once all the replica listener's `OpenAsync()` calls complete and `RunAsync()` has been called,  `StatefulServiceBase.OnChangeRoleAsync()` is called.</span></span> <span data-ttu-id="7de31-216">To jest zastępowany uncommonly w usłudze.</span><span class="sxs-lookup"><span data-stu-id="7de31-216">This is uncommonly overridden in the service.</span></span>

### <a name="common-issues-during-stateful-service-shutdown-and-primary-demotion"></a><span data-ttu-id="7de31-217">Typowe problemy podczas zamykania usługi stanowej i obniżania poziomu podstawowego</span><span class="sxs-lookup"><span data-stu-id="7de31-217">Common issues during stateful service shutdown and primary demotion</span></span>
<span data-ttu-id="7de31-218">Sieć szkieletowa usług zmienia podstawowej usługi stanowej z różnych przyczyn.</span><span class="sxs-lookup"><span data-stu-id="7de31-218">Service Fabric changes the Primary of a stateful service for a variety of reasons.</span></span> <span data-ttu-id="7de31-219">Najbardziej typowe są [klastra, ponowne równoważenie](service-fabric-cluster-resource-manager-balancing.md) i [uaktualniania aplikacji](service-fabric-application-upgrade.md).</span><span class="sxs-lookup"><span data-stu-id="7de31-219">The most common are [cluster rebalancing](service-fabric-cluster-resource-manager-balancing.md) and [application upgrade](service-fabric-application-upgrade.md).</span></span> <span data-ttu-id="7de31-220">Podczas tych czynności (a także podczas zamykania normalnego użytkowania, np. zostanie wyświetlony, jeśli usługa została usunięta), należy pamiętać, że usługa przestrzegać `CancellationToken`.</span><span class="sxs-lookup"><span data-stu-id="7de31-220">During these operations (as well as during normal service shutdown, like you'd see if the service was deleted), it is important that the service respect the `CancellationToken`.</span></span> <span data-ttu-id="7de31-221">Usługi, które nie obsługują anulowania prawidłowo może wystąpić pewne problemy.</span><span class="sxs-lookup"><span data-stu-id="7de31-221">Services that do not handle cancellation cleanly will experience several issues.</span></span> <span data-ttu-id="7de31-222">W szczególności tych operacji będzie zajmować dużo czasu, ponieważ sieć szkieletowa usług czeka na usługi do zatrzymania bezpiecznie.</span><span class="sxs-lookup"><span data-stu-id="7de31-222">In particular, these operations will be slow since Service Fabric waits for the services to stop gracefully.</span></span> <span data-ttu-id="7de31-223">Ostatecznie to prowadzić do uaktualnienia nie powiodło się tego limitu czasu i wycofać.</span><span class="sxs-lookup"><span data-stu-id="7de31-223">This can ultimately lead to failed upgrades that time out and roll back.</span></span> <span data-ttu-id="7de31-224">Niepowodzenie uwzględnić token anulowania również może powodować imbalanced klastrów, ponieważ węzły uzyskiwanie dostępu, ale nie można rebalanced usługi, ponieważ trwa zbyt długo, aby przenieść je w innym miejscu.</span><span class="sxs-lookup"><span data-stu-id="7de31-224">Failure to honor the cancellation token can also cause imbalanced clusters because nodes get hot but the services can't be rebalanced since it takes too long to move them elsewhere.</span></span> 

<span data-ttu-id="7de31-225">Ponieważ usługi stanowej, również jest prawdopodobne, że używają [niezawodnej kolekcje](service-fabric-reliable-services-reliable-collections.md).</span><span class="sxs-lookup"><span data-stu-id="7de31-225">Since the services are stateful, it is also likely that they are using the [Reliable Collections](service-fabric-reliable-services-reliable-collections.md).</span></span> <span data-ttu-id="7de31-226">W sieci szkieletowej usług podczas obniżania poziomu podstawowego jedną pierwszy co się stanie, jest odebraniu podstawowy stan do zapisu.</span><span class="sxs-lookup"><span data-stu-id="7de31-226">In Service Fabric, when a Primary is demoted, one of the first things that happens is that write access to the underlying state is revoked.</span></span> <span data-ttu-id="7de31-227">Prowadzi to do drugiego zestawu problemy, które mogą mieć wpływ na cyklem życia usługi.</span><span class="sxs-lookup"><span data-stu-id="7de31-227">This leads to a second set of issues that can impact the service lifecycle.</span></span> <span data-ttu-id="7de31-228">Kolekcje zwracany wyjątki oparte na czas i czy jest przenoszony repliki lub zamykania.</span><span class="sxs-lookup"><span data-stu-id="7de31-228">The collections return Exceptions based on the timing and whether the replica is being moved or shut down.</span></span> <span data-ttu-id="7de31-229">Te wyjątki powinny być traktowane jako poprawnie.</span><span class="sxs-lookup"><span data-stu-id="7de31-229">These exceptions should be handled correctly.</span></span> <span data-ttu-id="7de31-230">Wyjątki generowane przez sieć szkieletowa usług można podzielić na stałe [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) i przejściowych [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) kategorii.</span><span class="sxs-lookup"><span data-stu-id="7de31-230">Exceptions thrown by Service Fabric fall into permanent [(`FabricException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabricexception?view=azure-dotnet) and transient [(`FabricTransientException`)](https://docs.microsoft.com/en-us/dotnet/api/system.fabric.fabrictransientexception?view=azure-dotnet) categories.</span></span> <span data-ttu-id="7de31-231">Stałe wyjątki powinny być rejestrowane i zgłoszony, gdy przejściowej wyjątki mogą ponowione opartych na logice niektórych ponów próbę.</span><span class="sxs-lookup"><span data-stu-id="7de31-231">Permanent exceptions should be logged and thrown, while the transient exceptions may be retried based on some retry logic.</span></span>

<span data-ttu-id="7de31-232">Obsługa wyjątków, które pochodzą od stosowania `ReliableCollections` w połączeniu z zdarzenia cyklu życia usługi jest ważnym elementem przetestowaniu i zweryfikowaniu niezawodnej usługi.</span><span class="sxs-lookup"><span data-stu-id="7de31-232">Handling the exceptions that come from use of the `ReliableCollections` in conjunction with service lifecycle events is an important part of testing and validating a Reliable Service.</span></span> <span data-ttu-id="7de31-233">Zalecane jest zawsze przy uruchamianiu usługi Obciążenie podczas wykonywania uaktualnienia i [testowania chaos](service-fabric-controlled-chaos.md) przed wdrożeniem kiedykolwiek do środowiska produkcyjnego.</span><span class="sxs-lookup"><span data-stu-id="7de31-233">The recommendation is always to run your service under load while performing upgrades and [chaos testing](service-fabric-controlled-chaos.md) before ever deploying to production.</span></span> <span data-ttu-id="7de31-234">Te podstawowe kroki pomoc, sprawdź, czy usługa jest poprawnie zaimplementowana i poprawnie obsługuje zdarzenia cyklu życia.</span><span class="sxs-lookup"><span data-stu-id="7de31-234">These basic steps help ensure that your service is correctly implemented and handles lifecycle events correctly.</span></span>


## <a name="notes-on-service-lifecycle"></a><span data-ttu-id="7de31-235">Uwagi dotyczące cyklu życia usług</span><span class="sxs-lookup"><span data-stu-id="7de31-235">Notes on service lifecycle</span></span>
  - <span data-ttu-id="7de31-236">Zarówno `RunAsync()` — metoda i `CreateServiceReplicaListeners/CreateServiceInstanceListeners` wywołania są opcjonalne.</span><span class="sxs-lookup"><span data-stu-id="7de31-236">Both the `RunAsync()` method and the `CreateServiceReplicaListeners/CreateServiceInstanceListeners` calls are optional.</span></span> <span data-ttu-id="7de31-237">Usługa może mieć ich, zarówno lub nie.</span><span class="sxs-lookup"><span data-stu-id="7de31-237">A service may have one of them, both, or neither.</span></span> <span data-ttu-id="7de31-238">Na przykład, jeśli usługa jest jego pracy w odpowiedź na wywołania użytkownika, jest niepotrzebna go do zaimplementowania `RunAsync()`.</span><span class="sxs-lookup"><span data-stu-id="7de31-238">For example, if the service does all its work in response to user calls, there is no need for it to implement `RunAsync()`.</span></span> <span data-ttu-id="7de31-239">Wymagane są tylko odbiorników komunikacji i ich skojarzonego kodu.</span><span class="sxs-lookup"><span data-stu-id="7de31-239">Only the communication listeners and their associated code are necessary.</span></span> <span data-ttu-id="7de31-240">Podobnie tworzenie i zwracanie odbiorników komunikacji jest opcjonalne, ponieważ usługa może mieć tylko pracy tła i dlatego tylko musi implementować`RunAsync()`</span><span class="sxs-lookup"><span data-stu-id="7de31-240">Similarly, creating and returning communication listeners is optional, as the service may have only background work to do, and so only needs to implement `RunAsync()`</span></span>
  - <span data-ttu-id="7de31-241">Jest on prawidłowy dla usługi, aby ukończyć `RunAsync()` pomyślnie i z powrotem od niego.</span><span class="sxs-lookup"><span data-stu-id="7de31-241">It is valid for a service to complete `RunAsync()` successfully and return from it.</span></span> <span data-ttu-id="7de31-242">Kończenie pracy nie jest warunek błędu.</span><span class="sxs-lookup"><span data-stu-id="7de31-242">Completing is not a failure condition.</span></span> <span data-ttu-id="7de31-243">Kończenie pracy `RunAsync()` wskazuje, czy praca w tle usługi zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="7de31-243">Completing `RunAsync()` indicates that the background work of the service has completed.</span></span> <span data-ttu-id="7de31-244">Dla stanowych usług niezawodne `RunAsync()` zostanie ponownie wywołany, jeśli obniżenie poziomu z podstawowego na pomocniczym i następnie podwyższony do podstawowej repliki.</span><span class="sxs-lookup"><span data-stu-id="7de31-244">For stateful reliable services, `RunAsync()` is called again if the replica were demoted from Primary to Secondary and then promoted back to Primary.</span></span>
  - <span data-ttu-id="7de31-245">Jeśli zamknie usługę `RunAsync()` przez zgłaszanie nieoczekiwany wyjątek, powoduje błąd.</span><span class="sxs-lookup"><span data-stu-id="7de31-245">If a service exits from `RunAsync()` by throwing some unexpected exception, this constitutes a failure.</span></span> <span data-ttu-id="7de31-246">Obiekt usługi jest zamknięta i zgłoszony błąd kondycji.</span><span class="sxs-lookup"><span data-stu-id="7de31-246">The service object is shut down and a health error reported.</span></span>
  - <span data-ttu-id="7de31-247">Gdy nie ma żadnego limitu czasu na zwracanie z tych metod, natychmiast spowoduje utratę możliwości zapisu do kolekcji niezawodnych i z tego powodu nie można ukończyć rzeczywistą pracę.</span><span class="sxs-lookup"><span data-stu-id="7de31-247">While there is no time limit on returning from these methods, you immediately lose the ability to write to Reliable Collections and therefore cannot complete any real work.</span></span> <span data-ttu-id="7de31-248">Zaleca się, czy zwracać możliwie jak najszybciej po otrzymaniu żądania anulowania.</span><span class="sxs-lookup"><span data-stu-id="7de31-248">It is recommended that you return as quickly as possible upon receiving the cancellation request.</span></span> <span data-ttu-id="7de31-249">Jeśli usługa nie odpowiada na te wywołania interfejsu API w rozsądnym czasie sieci szkieletowej usług wymuszanie może zakończyć korzystanie z usługi.</span><span class="sxs-lookup"><span data-stu-id="7de31-249">If your service does not respond to these API calls in a reasonable amount of time Service Fabric may forcibly terminate your service.</span></span> <span data-ttu-id="7de31-250">Zwykle to tylko odbywa się podczas uaktualniania aplikacji lub gdy usługa jest usuwana.</span><span class="sxs-lookup"><span data-stu-id="7de31-250">Usually this only happens during application upgrades or when a service is being deleted.</span></span> <span data-ttu-id="7de31-251">Tego limitu czasu wynosi 15 minut domyślnie.</span><span class="sxs-lookup"><span data-stu-id="7de31-251">This timeout is 15 minutes by default.</span></span>
  - <span data-ttu-id="7de31-252">Błędy w `OnCloseAsync()` doprowadzi do ścieżki `OnAbort()` wywoływana, która jest możliwość optymalnych ostatniej szansy, usługi wyczyścić Konfigurowanie i wszystkie zasoby, które zostały przejęte ich wydania.</span><span class="sxs-lookup"><span data-stu-id="7de31-252">Failures in the `OnCloseAsync()` path result in `OnAbort()` being called which is a last-chance best-effort opportunity for the service to clean up and release any resources that they have claimed.</span></span>

## <a name="next-steps"></a><span data-ttu-id="7de31-253">Następne kroki</span><span class="sxs-lookup"><span data-stu-id="7de31-253">Next steps</span></span>
- [<span data-ttu-id="7de31-254">Wprowadzenie do niezawodne usługi</span><span class="sxs-lookup"><span data-stu-id="7de31-254">Introduction to Reliable Services</span></span>](service-fabric-reliable-services-introduction.md)
- [<span data-ttu-id="7de31-255">Niezawodne usługi szybki start</span><span class="sxs-lookup"><span data-stu-id="7de31-255">Reliable Services quick start</span></span>](service-fabric-reliable-services-quick-start.md)
- [<span data-ttu-id="7de31-256">Niezawodne usługi advanced użycia</span><span class="sxs-lookup"><span data-stu-id="7de31-256">Reliable Services advanced usage</span></span>](service-fabric-reliable-services-advanced-usage.md)
