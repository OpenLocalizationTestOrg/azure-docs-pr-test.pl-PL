---
title: Korzystanie z biblioteki klienta elastycznej bazy danych z programu Entity Framework | Dokumentacja firmy Microsoft
description: "Użyj kodowania bazy danych biblioteki klienta elastycznej bazy danych i strukturą Entity Framework"
services: sql-database
documentationcenter: 
manager: jhubbard
author: torsteng
editor: 
ms.assetid: b9c3065b-cb92-41be-aa7f-deba23e7e159
ms.service: sql-database
ms.custom: scale out apps
ms.workload: sql-database
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 03/06/2017
ms.author: torsteng
ms.openlocfilehash: 2f0bff394c1e11a270cb324be5a1a45e9e531d7f
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/11/2017
---
# <a name="elastic-database-client-library-with-entity-framework"></a><span data-ttu-id="704d9-103">Biblioteka klienta usługi elastycznej bazy danych z programu Entity Framework</span><span class="sxs-lookup"><span data-stu-id="704d9-103">Elastic Database client library with Entity Framework</span></span>
<span data-ttu-id="704d9-104">Ten dokument przedstawia zmiany w aplikacji programu Entity Framework, które są potrzebne do integracji z [narzędzi elastycznej bazy danych](sql-database-elastic-scale-introduction.md).</span><span class="sxs-lookup"><span data-stu-id="704d9-104">This document shows the changes in an Entity Framework application that are needed to integrate with the [Elastic Database tools](sql-database-elastic-scale-introduction.md).</span></span> <span data-ttu-id="704d9-105">Koncentruje się na tworzenie [zarządzania mapy niezależnego fragmentu](sql-database-elastic-scale-shard-map-management.md) i [routingu zależne od danych](sql-database-elastic-scale-data-dependent-routing.md) z programu Entity Framework **Code First** podejście.</span><span class="sxs-lookup"><span data-stu-id="704d9-105">The focus is on composing [shard map management](sql-database-elastic-scale-shard-map-management.md) and [data-dependent routing](sql-database-elastic-scale-data-dependent-routing.md) with the Entity Framework **Code First** approach.</span></span> <span data-ttu-id="704d9-106">[Najpierw - Code nową bazę danych](http://msdn.microsoft.com/data/jj193542.aspx) samouczek dotyczący EF służy jako naszym przykładzie uruchomionych w tym dokumencie.</span><span class="sxs-lookup"><span data-stu-id="704d9-106">The [Code First - New Database](http://msdn.microsoft.com/data/jj193542.aspx) tutorial for EF serves as our running example throughout this document.</span></span> <span data-ttu-id="704d9-107">Przykładowy kod towarzyszące ten dokument jest częścią narzędzi elastycznej bazy danych, ustaw próbek w przykładach kodu programu Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="704d9-107">The sample code accompanying this document is part of elastic database tools' set of samples in the Visual Studio Code Samples.</span></span>

## <a name="downloading-and-running-the-sample-code"></a><span data-ttu-id="704d9-108">Pobieranie i uruchamianie przykładowy kod</span><span class="sxs-lookup"><span data-stu-id="704d9-108">Downloading and Running the Sample Code</span></span>
<span data-ttu-id="704d9-109">Aby pobrać kod w tym artykule:</span><span class="sxs-lookup"><span data-stu-id="704d9-109">To download the code for this article:</span></span>

* <span data-ttu-id="704d9-110">Visual Studio 2012 lub nowszy jest wymagany.</span><span class="sxs-lookup"><span data-stu-id="704d9-110">Visual Studio 2012 or later is required.</span></span> 
* <span data-ttu-id="704d9-111">Pobierz [elastyczne narzędzia bazy danych dla bazy danych SQL Azure — przykładowy Entity Framework integracji](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) w witrynie MSDN.</span><span class="sxs-lookup"><span data-stu-id="704d9-111">Download the [Elastic DB Tools for Azure SQL - Entity Framework Integration sample](https://code.msdn.microsoft.com/windowsapps/Elastic-Scale-with-Azure-bae904ba) from MSDN.</span></span> <span data-ttu-id="704d9-112">Rozpakuj próbki lokalizacji wybrane.</span><span class="sxs-lookup"><span data-stu-id="704d9-112">Unzip the sample to a location of your choosing.</span></span>
* <span data-ttu-id="704d9-113">Uruchom program Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="704d9-113">Start Visual Studio.</span></span> 
* <span data-ttu-id="704d9-114">W programie Visual Studio wybierz Plik -> Otwórz projekt/rozwiązanie.</span><span class="sxs-lookup"><span data-stu-id="704d9-114">In Visual Studio, select File -> Open Project/Solution.</span></span> 
* <span data-ttu-id="704d9-115">W **Otwórz projekt** okno dialogowe, przejdź do przykładowej został pobrany i wybierz **EntityFrameworkCodeFirst.sln** otworzyć próbki.</span><span class="sxs-lookup"><span data-stu-id="704d9-115">In the **Open Project** dialog, navigate to the sample you downloaded and select **EntityFrameworkCodeFirst.sln** to open the sample.</span></span> 

<span data-ttu-id="704d9-116">Aby uruchomić próbki, należy utworzyć trzy pusty bazy danych w bazie danych SQL Azure:</span><span class="sxs-lookup"><span data-stu-id="704d9-116">To run the sample, you need to create three empty databases in Azure SQL Database:</span></span>

* <span data-ttu-id="704d9-117">Bazy danych Menedżera Map niezależnego fragmentu</span><span class="sxs-lookup"><span data-stu-id="704d9-117">Shard Map Manager database</span></span>
* <span data-ttu-id="704d9-118">1 niezależnego fragmentu bazy danych</span><span class="sxs-lookup"><span data-stu-id="704d9-118">Shard 1 database</span></span>
* <span data-ttu-id="704d9-119">2 niezależnego fragmentu bazy danych</span><span class="sxs-lookup"><span data-stu-id="704d9-119">Shard 2 database</span></span>

<span data-ttu-id="704d9-120">Po utworzeniu tych baz danych, wypełnij posiadaczy miejsce w **Program.cs** o nazwę serwera bazy danych SQL Azure, nazwy bazy danych i poświadczeń do nawiązania połączenia bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-120">Once you have created these databases, fill in the place holders in **Program.cs** with your Azure SQL DB server name, the database names and your credentials to connect to the databases.</span></span> <span data-ttu-id="704d9-121">Skompiluj rozwiązanie w programie Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="704d9-121">Build the solution in Visual Studio.</span></span> <span data-ttu-id="704d9-122">Program Visual Studio pobierze wymagane pakiety NuGet biblioteki klienta elastycznej bazy danych, Entity Framework i wystąpienia błędu przejściowego obsługi jako część procesu kompilacji.</span><span class="sxs-lookup"><span data-stu-id="704d9-122">Visual Studio will download the required NuGet packages for the elastic database client library, Entity Framework, and Transient Fault handling as part of the build process.</span></span> <span data-ttu-id="704d9-123">Upewnij się, że trwa przywracanie pakietów NuGet jest włączona dla rozwiązania.</span><span class="sxs-lookup"><span data-stu-id="704d9-123">Make sure that restoring NuGet packages is enabled for your solution.</span></span> <span data-ttu-id="704d9-124">To ustawienie zostanie włączone, klikając prawym przyciskiem myszy plik rozwiązania w Eksploratorze rozwiązań programu Visual Studio.</span><span class="sxs-lookup"><span data-stu-id="704d9-124">You can enable this setting by right-clicking on the solution file in the Visual Studio Solution Explorer.</span></span> 

## <a name="entity-framework-workflows"></a><span data-ttu-id="704d9-125">Przepływy pracy programu Entity Framework</span><span class="sxs-lookup"><span data-stu-id="704d9-125">Entity Framework workflows</span></span>
<span data-ttu-id="704d9-126">Entity Framework deweloperzy polegać na jednym z następujących czterech przepływy pracy do tworzenia aplikacji i zapewnienia trwałości dla obiektów aplikacji:</span><span class="sxs-lookup"><span data-stu-id="704d9-126">Entity Framework developers rely on one of the following four workflows to build applications and to ensure persistence for application objects:</span></span> 

* <span data-ttu-id="704d9-127">**Code First (Nowa baza danych)**: developer EF tworzy model w kodzie aplikacji, a następnie EF generuje bazy danych z niego.</span><span class="sxs-lookup"><span data-stu-id="704d9-127">**Code First (New Database)**: The EF developer creates the model in the application code and then EF generates the database from it.</span></span> 
* <span data-ttu-id="704d9-128">**Code First (istniejącej bazy danych)**: dewelopera umożliwia EF generowanie kodu aplikacji dla modelu na podstawie istniejącej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-128">**Code First (Existing Database)**: The developer lets EF generate the application code for the model from an existing database.</span></span>
* <span data-ttu-id="704d9-129">**Model pierwszy**: dewelopera tworzy model w programie EF designer, a następnie EF utworzy bazę danych z modelu.</span><span class="sxs-lookup"><span data-stu-id="704d9-129">**Model First**: The developer creates the model in the EF designer and then EF creates the database from the model.</span></span>
* <span data-ttu-id="704d9-130">**Baza danych pierwszej**: projektanta używa EF narzędzi w celu uwzględnienia modelu z istniejącej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-130">**Database First**: The developer uses EF tooling to infer the model from an existing database.</span></span> 

<span data-ttu-id="704d9-131">Tych sposobów zależne od klasy DbContext niewidocznie Zarządzanie połączenia bazy danych i schemat bazy danych dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="704d9-131">All these approaches rely on the DbContext class to transparently manage database connections and database schema for an application.</span></span> <span data-ttu-id="704d9-132">Jak będzie omówiono bardziej szczegółowo w dalszej części dokumentu, różnych konstruktorów w klasie podstawowej DbContext pozwolić na różne poziomy kontroli nad utworzenia połączenia bazy danych tworzenia uruchamianie i schematu.</span><span class="sxs-lookup"><span data-stu-id="704d9-132">As we will discuss in more detail later in the document, different constructors on the DbContext base class allow for different levels of control over connection creation, database bootstrapping and schema creation.</span></span> <span data-ttu-id="704d9-133">Wyzwania wynikają głównie z faktu, że zarządzanie połączenia bazy danych, które są zapewniane przez EF przecina z funkcjami zarządzania połączenia danych zależnych routingu interfejsy dostępne przez biblioteki klienta elastycznej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-133">Challenges arise primarily from the fact that the database connection management provided by EF intersects with the connection management capabilities of the data dependent routing interfaces provided by the elastic database client library.</span></span> 

## <a name="elastic-database-tools-assumptions"></a><span data-ttu-id="704d9-134">Założenia narzędzi elastycznej bazy danych</span><span class="sxs-lookup"><span data-stu-id="704d9-134">Elastic database tools assumptions</span></span>
<span data-ttu-id="704d9-135">Aby uzyskać definicje terminów, zobacz [słownik narzędzi elastycznej bazy danych](sql-database-elastic-scale-glossary.md).</span><span class="sxs-lookup"><span data-stu-id="704d9-135">For term definitions, see [Elastic Database tools glossary](sql-database-elastic-scale-glossary.md).</span></span>

<span data-ttu-id="704d9-136">Z biblioteki klienta elastycznej bazy danych należy zdefiniować partycji o nazwie shardlets danych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="704d9-136">With elastic database client library, you define partitions of your application data called shardlets.</span></span> <span data-ttu-id="704d9-137">Shardlets są identyfikowane za pomocą klucza dzielenia na fragmenty i są mapowane na konkretnych baz danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-137">Shardlets are identified by a sharding key and are mapped to specific databases.</span></span> <span data-ttu-id="704d9-138">Aplikacja może mieć dowolną liczbę baz danych, zgodnie z potrzebami i dystrybuować shardlets jest zapewnienie wystarczającej ilości pojemności lub wydajności danego bieżące wymagania biznesowe.</span><span class="sxs-lookup"><span data-stu-id="704d9-138">An application may have as many databases as needed and distribute the shardlets to provide enough capacity or performance given current business requirements.</span></span> <span data-ttu-id="704d9-139">Mapowanie dzielenia na fragmenty wartości klucza do bazy danych jest przechowywany przez mapy niezależnego fragmentu pochodzącymi z interfejsów API klienta elastycznej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-139">The mapping of sharding key values to the databases is stored by a shard map provided by the elastic database client APIs.</span></span> <span data-ttu-id="704d9-140">Nazywamy tej możliwości **zarządzania mapy niezależnego fragmentu**, lub SMM skrócie.</span><span class="sxs-lookup"><span data-stu-id="704d9-140">We call this capability **Shard Map Management**, or SMM for short.</span></span> <span data-ttu-id="704d9-141">Mapa niezależnego fragmentu służy również jako broker połączeń z bazą danych dla żądań zawierających klucz dzielenia na fragmenty.</span><span class="sxs-lookup"><span data-stu-id="704d9-141">The shard map also serves as the broker of database connections for requests that carry a sharding key.</span></span> <span data-ttu-id="704d9-142">Firma Microsoft odwoływać się do tej funkcji jako **routingu zależne od danych**.</span><span class="sxs-lookup"><span data-stu-id="704d9-142">We refer to this capability as **data-dependent routing**.</span></span> 

<span data-ttu-id="704d9-143">Menedżer mapy niezależnego fragmentu chroni użytkowników z widoków niespójne w shardlet dane, które mogą wystąpić, gdy są wykonywane operacje zarządzania równoczesnych shardlet (np. przenoszenie danych z jednego niezależnego fragmentu do innego).</span><span class="sxs-lookup"><span data-stu-id="704d9-143">The shard map manager protects users from inconsistent views into shardlet data that can occur when concurrent shardlet management operations (such as relocating data from one shard to another) are happening.</span></span> <span data-ttu-id="704d9-144">Aby to zrobić, mapy niezależnego fragmentu zarządzane przez brokera biblioteki klienta połączenia bazy danych dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="704d9-144">To do so, the shard maps managed by the client library broker the database connections for an application.</span></span> <span data-ttu-id="704d9-145">Dzięki temu funkcja mapy niezależnego fragmentu automatycznie kill połączenia z bazą danych podczas operacji zarządzania niezależnego fragmentu może mieć wpływ na shardlet, który został utworzony dla połączenia.</span><span class="sxs-lookup"><span data-stu-id="704d9-145">This allows the shard map functionality to automatically kill a database connection when shard management operations could impact the shardlet that the connection has been created for.</span></span> <span data-ttu-id="704d9-146">Tej metody należy zintegrować z niektórych funkcji EF firmy, takich jak tworzenie nowych połączeń z jednego z istniejących, aby sprawdzić, czy baza danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-146">This approach needs to integrate with some of EF’s functionality, such as creating new connections from an existing one to check for database existence.</span></span> <span data-ttu-id="704d9-147">Ogólnie rzecz biorąc naszych obserwacji została działanie standardowe tylko pracy niezawodnie dla połączenia zamkniętego bazy danych, które można bezpiecznie sklonować dla EF konstruktorów typu DbContext.</span><span class="sxs-lookup"><span data-stu-id="704d9-147">In general, our observation has been that the standard DbContext constructors only work reliably for closed database connections that can safely be cloned for EF work.</span></span> <span data-ttu-id="704d9-148">Zamiast tego projektu zasady elastycznej bazy danych jest tylko broker otwarte połączenia.</span><span class="sxs-lookup"><span data-stu-id="704d9-148">The design principle of elastic database instead is to only broker opened connections.</span></span> <span data-ttu-id="704d9-149">Jeden wydaje się, że zamknięcie połączenia obsługiwane przez brokera w bibliotece klienta przed przekazaniem ich do EF DbContext może rozwiązać ten problem.</span><span class="sxs-lookup"><span data-stu-id="704d9-149">One might think that closing a connection brokered by the client library before handing it over to the EF DbContext may solve this issue.</span></span> <span data-ttu-id="704d9-150">Jednak połączenie jest zamykane i zależne EF otworzyć go ponownie, co foregoes sprawdzania poprawności i sprawdzanie spójności wykonywana przez bibliotekę.</span><span class="sxs-lookup"><span data-stu-id="704d9-150">However, by closing the connection and relying on EF to re-open it, one foregoes the validation and consistency checks performed by the library.</span></span> <span data-ttu-id="704d9-151">Funkcje migracji w EF, jednak używa tych połączeń do zarządzania podstawowy schemat bazy danych w sposób niewidoczny dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="704d9-151">The migrations functionality in EF, however, uses these connections to manage the underlying database schema in a way that is transparent to the application.</span></span> <span data-ttu-id="704d9-152">Najlepiej, jeśli chcemy zachować i łączenie wszystkie te funkcje z biblioteki klienta elastycznej bazy danych i EF w tej samej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="704d9-152">Ideally, we would like to retain and combine all these capabilities from both the elastic database client library and EF in the same application.</span></span> <span data-ttu-id="704d9-153">W poniższej sekcji omówiono te właściwości i wymagania bardziej szczegółowo.</span><span class="sxs-lookup"><span data-stu-id="704d9-153">The following section discusses these properties and requirements in more detail.</span></span> 

## <a name="requirements"></a><span data-ttu-id="704d9-154">Wymagania</span><span class="sxs-lookup"><span data-stu-id="704d9-154">Requirements</span></span>
<span data-ttu-id="704d9-155">Podczas pracy z biblioteki klienta elastycznej bazy danych i interfejsów API programu Entity Framework, chcemy zachować następujące właściwości:</span><span class="sxs-lookup"><span data-stu-id="704d9-155">When working with both the elastic database client library and Entity Framework APIs, we want to retain the following properties:</span></span> 

* <span data-ttu-id="704d9-156">**Skalowalny w poziomie**: Aby dodać lub usunąć baz danych z aplikacji podzielonej odpowiednio do potrzeb pojemność aplikacji warstwy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-156">**Scale-out**: To add or remove databases from the data tier of the sharded application as necessary for the capacity demands of the application.</span></span> <span data-ttu-id="704d9-157">Oznacza to kontroli nad tworzenie i usuwanie baz danych i przy użyciu elastycznej bazy danych Identyfikator niezależnego fragmentu interfejsów API manager do zarządzania bazami danych i mapowania shardlets mapy.</span><span class="sxs-lookup"><span data-stu-id="704d9-157">This means control over the the creation and deletion of databases and using the elastic database shard map manager APIs to manage databases, and mappings of shardlets.</span></span> 
* <span data-ttu-id="704d9-158">**Spójność**: aplikacja wykorzystuje dzielenia na fragmenty i korzysta z danych zależnych routingu funkcji biblioteki klienta.</span><span class="sxs-lookup"><span data-stu-id="704d9-158">**Consistency**: The application employs sharding, and uses the data dependent routing capabilities of the client library.</span></span> <span data-ttu-id="704d9-159">Aby uniknąć uszkodzenia lub wyników zapytania niewłaściwy, połączeń są przeprowadzana za pośrednictwem Menedżera map niezależnego fragmentu.</span><span class="sxs-lookup"><span data-stu-id="704d9-159">To avoid corruption or wrong query results, connections are brokered through the shard map manager.</span></span> <span data-ttu-id="704d9-160">Zachowuje również sprawdzania poprawności i spójność.</span><span class="sxs-lookup"><span data-stu-id="704d9-160">This also retains validation and consistency.</span></span>
* <span data-ttu-id="704d9-161">**"Code First"**: zachowania wygodę EF przez kod pierwszego modelu.</span><span class="sxs-lookup"><span data-stu-id="704d9-161">**Code First**: To retain the convenience of EF’s code first paradigm.</span></span> <span data-ttu-id="704d9-162">W pierwszym kod klasy w aplikacji są mapowane niewidocznie podstawowej struktury bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-162">In Code First, classes in the application are mapped transparently to the underlying database structures.</span></span> <span data-ttu-id="704d9-163">Kod aplikacji współdziała z DbSets, który zamaskować większością aspektów przetwarzania podstawowej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-163">The application code interacts with DbSets that mask most aspects involved in the underlying database processing.</span></span>
* <span data-ttu-id="704d9-164">**Schemat**: Entity Framework obsługuje tworzenie schematu bazy danych początkowej i kolejnych schematu zmiany za pomocą migracji.</span><span class="sxs-lookup"><span data-stu-id="704d9-164">**Schema**: Entity Framework handles initial database schema creation and subsequent schema evolution through migrations.</span></span> <span data-ttu-id="704d9-165">Zachowując te możliwości dostosowywania aplikacji jest łatwe w miarę rozwoju środowisko danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-165">By retaining these capabilities, adapting your app is easy as the data evolves.</span></span> 

<span data-ttu-id="704d9-166">Poniższe wskazówki nakazuje jak spełnia wymagania Code First aplikacji za pomocą narzędzi elastycznej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-166">The following guidance instructs how to satisfy these requirements for Code First applications using elastic database tools.</span></span> 

## <a name="data-dependent-routing-using-ef-dbcontext"></a><span data-ttu-id="704d9-167">Dane zależne routingu przy użyciu EF DbContext</span><span class="sxs-lookup"><span data-stu-id="704d9-167">Data dependent routing using EF DbContext</span></span>
<span data-ttu-id="704d9-168">Połączenia bazy danych z programu Entity Framework zwykle są zarządzane przez podklasy **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="704d9-168">Database connections with Entity Framework are typically managed through subclasses of **DbContext**.</span></span> <span data-ttu-id="704d9-169">Utworzyć te podklasy pochodny **DbContext**.</span><span class="sxs-lookup"><span data-stu-id="704d9-169">Create these subclasses by deriving from **DbContext**.</span></span> <span data-ttu-id="704d9-170">Jest to, gdzie został zdefiniowany z **DbSets** implementują kolekcje kopii bazy danych obiektu CLR dla aplikacji.</span><span class="sxs-lookup"><span data-stu-id="704d9-170">This is where you define your **DbSets** that implement the database-backed collections of CLR objects for your application.</span></span> <span data-ttu-id="704d9-171">W kontekście danych zależnych routingu umożliwi nam poznanie kilka właściwości pomocne, które nie posiadają niekoniecznie dla innych pierwszy scenariuszy aplikacji EF kodu:</span><span class="sxs-lookup"><span data-stu-id="704d9-171">In the context of data dependent routing, we can identify several helpful properties that do not necessarily hold for other EF code first application scenarios:</span></span> 

* <span data-ttu-id="704d9-172">Baza danych już istnieje i został zarejestrowany w mapie niezależnego fragmentu elastycznej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-172">The database already exists and has been registered in the elastic database shard map.</span></span> 
* <span data-ttu-id="704d9-173">Schemat aplikacji zostało już wdrożone w bazie danych (co omówiono poniżej).</span><span class="sxs-lookup"><span data-stu-id="704d9-173">The schema of the application has already been deployed to the database (explained below).</span></span> 
* <span data-ttu-id="704d9-174">Zależne od danych routingu połączeń z bazą danych jest przeprowadzana przez niezależnego fragmentu mapy.</span><span class="sxs-lookup"><span data-stu-id="704d9-174">Data-dependent routing connections to the database are brokered by the shard map.</span></span> 

<span data-ttu-id="704d9-175">Aby zintegrować **DbContexts** zależne od danych routingu dla skalowalnego w poziomie:</span><span class="sxs-lookup"><span data-stu-id="704d9-175">To integrate **DbContexts** with data-dependent routing for scale-out:</span></span>

1. <span data-ttu-id="704d9-176">Utwórz połączenia fizycznej bazy danych za pośrednictwem interfejsów klienta elastycznej bazy danych Menedżera mapy niezależnego fragmentu,</span><span class="sxs-lookup"><span data-stu-id="704d9-176">Create physical database connections through the elastic database client interfaces of the shard map manager,</span></span> 
2. <span data-ttu-id="704d9-177">Zawijaj połączenie z **DbContext** podklasy</span><span class="sxs-lookup"><span data-stu-id="704d9-177">Wrap the connection with the **DbContext** subclass</span></span>
3. <span data-ttu-id="704d9-178">Przekaż połączenie w dół do **DbContext** podstawowa klasy, aby upewnić się, wszystkie przetwarzania po stronie EF się stanie, a także.</span><span class="sxs-lookup"><span data-stu-id="704d9-178">Pass the connection down into the **DbContext** base classes to ensure all the processing on the EF side happens as well.</span></span> 

<span data-ttu-id="704d9-179">Poniższy przykład kodu pokazuje tej metody.</span><span class="sxs-lookup"><span data-stu-id="704d9-179">The following code example illustrates this approach.</span></span> <span data-ttu-id="704d9-180">(Ten kod jest również towarzyszący projektu programu Visual Studio)</span><span class="sxs-lookup"><span data-stu-id="704d9-180">(This code is also in the accompanying Visual Studio project)</span></span>

    public class ElasticScaleContext<T> : DbContext
    {
    public DbSet<Blog> Blogs { get; set; }
    …

        // C'tor for data dependent routing. This call will open a validated connection 
        // routed to the proper shard by the shard map manager. 
        // Note that the base class c'tor call will fail for an open connection
        // if migrations need to be done and SQL credentials are used. This is the reason for the 
        // separation of c'tors into the data-dependent routing case (this c'tor) and the internal c'tor for new shards.
        public ElasticScaleContext(ShardMap shardMap, T shardingKey, string connectionStr)
            : base(CreateDDRConnection(shardMap, shardingKey, connectionStr), 
            true /* contextOwnsConnection */)
        {
        }

        // Only static methods are allowed in calls into base class c'tors.
        private static DbConnection CreateDDRConnection(
        ShardMap shardMap, 
        T shardingKey, 
        string connectionStr)
        {
            // No initialization
            Database.SetInitializer<ElasticScaleContext<T>>(null);

            // Ask shard map to broker a validated connection for the given key
            SqlConnection conn = shardMap.OpenConnectionForKey<T>
                                (shardingKey, connectionStr, ConnectionOptions.Validate);
            return conn;
        }    

## <a name="main-points"></a><span data-ttu-id="704d9-181">Główne punkty</span><span class="sxs-lookup"><span data-stu-id="704d9-181">Main points</span></span>
* <span data-ttu-id="704d9-182">Nowy Konstruktor zastępuje konstruktora domyślnego w podklasy DbContext</span><span class="sxs-lookup"><span data-stu-id="704d9-182">A new constructor replaces the default constructor in the DbContext subclass</span></span> 
* <span data-ttu-id="704d9-183">Nowy Konstruktor przyjmuje argumenty, które są wymagane dla danych zależnych routingu za pomocą biblioteki klienta elastycznej bazy danych:</span><span class="sxs-lookup"><span data-stu-id="704d9-183">The new constructor takes the arguments that are required for data dependent routing through elastic database client library:</span></span>
  
  * <span data-ttu-id="704d9-184">Mapa niezależnych można uzyskać dostępu do interfejsów routingu zależne od danych</span><span class="sxs-lookup"><span data-stu-id="704d9-184">the shard map to access the data-dependent routing interfaces,</span></span>
  * <span data-ttu-id="704d9-185">klucz dzielenia na fragmenty, aby zidentyfikować shardlet,</span><span class="sxs-lookup"><span data-stu-id="704d9-185">the sharding key to identify the shardlet,</span></span>
  * <span data-ttu-id="704d9-186">Parametry połączenia przy użyciu poświadczeń dla połączenia routingu zależne od danych niezależnego fragmentu.</span><span class="sxs-lookup"><span data-stu-id="704d9-186">a connection string with the credentials for the data-dependent routing connection to the shard.</span></span> 
* <span data-ttu-id="704d9-187">Wywołanie konstruktora klasy podstawowej uwzględnia przekierowania statyczną metodę, która wykonuje wszystkie kroki niezbędne do routingu zależne od danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-187">The call to the base class constructor takes a detour into a static method that performs all the steps necessary for data-dependent routing.</span></span> 
  
  * <span data-ttu-id="704d9-188">Używa wywołania OpenConnectionForKey interfejsów klienta elastycznej bazy danych na mapie niezależnego fragmentu ustanowienie otwartego połączenia.</span><span class="sxs-lookup"><span data-stu-id="704d9-188">It uses the OpenConnectionForKey call of the elastic database client interfaces on the shard map to establish an open connection.</span></span>
  * <span data-ttu-id="704d9-189">Mapa niezależnego fragmentu tworzy Otwieranie połączenia z niezależnego fragmentu, przechowujący shardlet klucza danego dzielenia na fragmenty.</span><span class="sxs-lookup"><span data-stu-id="704d9-189">The shard map creates the open connection to the shard that holds the shardlet for the given sharding key.</span></span>
  * <span data-ttu-id="704d9-190">To połączenie otwarte jest przekazywane z powrotem do konstruktora klasy podstawowej typu DbContext, aby wskazać, czy to połączenie jest używane przez EF zamiast czekać na EF automatycznie Utwórz nowe połączenie.</span><span class="sxs-lookup"><span data-stu-id="704d9-190">This open connection is passed back to the base class constructor of DbContext to indicate that this connection is to be used by EF instead of letting EF create a new connection automatically.</span></span> <span data-ttu-id="704d9-191">W ten sposób połączenia zostały oznakowane przez interfejs API klienta elastycznej bazy danych, dzięki czemu może zagwarantować spójności w operacjach zarządzania mapy niezależnego fragmentu.</span><span class="sxs-lookup"><span data-stu-id="704d9-191">This way the connection has been tagged by the elastic database client API so that it can guarantee consistency under shard map management operations.</span></span>

<span data-ttu-id="704d9-192">Użyj nowego konstruktora dla Twojego podklasy DbContext zamiast domyślnego konstruktora w kodzie.</span><span class="sxs-lookup"><span data-stu-id="704d9-192">Use the new constructor for your DbContext subclass instead of the default constructor in your code.</span></span> <span data-ttu-id="704d9-193">Oto przykład:</span><span class="sxs-lookup"><span data-stu-id="704d9-193">Here is an example:</span></span> 

    // Create and save a new blog.

    Console.Write("Enter a name for a new blog: "); 
    var name = Console.ReadLine(); 

    using (var db = new ElasticScaleContext<int>( 
                            sharding.ShardMap,  
                            tenantId1,  
                            connStrBldr.ConnectionString)) 
    { 
        var blog = new Blog { Name = name }; 
        db.Blogs.Add(blog); 
        db.SaveChanges(); 

        // Display all Blogs for tenant 1 
        var query = from b in db.Blogs 
                    orderby b.Name 
                    select b; 
     … 
    }

<span data-ttu-id="704d9-194">Nowy Konstruktor otwiera połączenie niezależnego fragmentu, przechowujący dane dla shardlet zidentyfikowane przez wartość **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="704d9-194">The new constructor opens the connection to the shard that holds the data for the shardlet identified by the value of **tenantid1**.</span></span> <span data-ttu-id="704d9-195">Kod w **przy użyciu** bloku pozostanie bez zmian, aby uzyskać dostęp do **DbSet** dla blogów za pomocą EF na niezależnych dla **tenantid1**.</span><span class="sxs-lookup"><span data-stu-id="704d9-195">The code in the **using** block stays unchanged to access the **DbSet** for blogs using EF on the shard for **tenantid1**.</span></span> <span data-ttu-id="704d9-196">Spowoduje to zmianę semantyki dla kodu za pomocą zablokować taki, że wszystkie operacje bazy danych obecnie ograniczone do jednego niezależnego fragmentu gdzie **tenantid1** jest przechowywany.</span><span class="sxs-lookup"><span data-stu-id="704d9-196">This changes semantics for the code in the using block such that all database operations are now scoped to the one shard where **tenantid1** is kept.</span></span> <span data-ttu-id="704d9-197">Na przykład zapytania LINQ za pośrednictwem blogów **DbSet** zwróci tylko blogi przechowywane na bieżący identyfikator niezależnego fragmentu, ale nie te przechowywane na inne niezależne.</span><span class="sxs-lookup"><span data-stu-id="704d9-197">For instance, a LINQ query over the blogs **DbSet** would only return blogs stored on the current shard, but not the ones stored on other shards.</span></span>  

#### <a name="transient-faults-handling"></a><span data-ttu-id="704d9-198">Obsługa błędów przejściowych</span><span class="sxs-lookup"><span data-stu-id="704d9-198">Transient faults handling</span></span>
<span data-ttu-id="704d9-199">Zespół Microsoft Patterns & wskazówki opublikowane [przejściowy błąd obsługi aplikacji bloku](https://msdn.microsoft.com/library/dn440719.aspx).</span><span class="sxs-lookup"><span data-stu-id="704d9-199">The Microsoft Patterns & Practices team published the [The Transient Fault Handling Application Block](https://msdn.microsoft.com/library/dn440719.aspx).</span></span> <span data-ttu-id="704d9-200">Biblioteka jest używany z biblioteki klienta elastycznej skali w połączeniu z EF.</span><span class="sxs-lookup"><span data-stu-id="704d9-200">The library is used with elastic scale client library in combination with EF.</span></span> <span data-ttu-id="704d9-201">Jednak zapewnić zwracanych do miejsca, w którym możemy zagwarantować, że nowy konstruktor jest używany po błędu przejściowego tak, aby wszystkie nowe połączenia podejmowana jest używanie konstruktorów, które firma Microsoft ma tweaked przejściowej wyjątku.</span><span class="sxs-lookup"><span data-stu-id="704d9-201">However, ensure that any transient exception returns to a place where we can ensure that the new constructor is being used after a transient fault so that any new connection attempt is made using the constructors we have tweaked.</span></span> <span data-ttu-id="704d9-202">W przeciwnym razie połączenie z poprawną niezależnego fragmentu nie jest gwarantowana i nie ma żadnych gwarancji, połączenie jest obsługiwane w chwili wystąpienia zmian do mapy niezależnego fragmentu.</span><span class="sxs-lookup"><span data-stu-id="704d9-202">Otherwise, a connection to the correct shard is not guaranteed, and there are no assurances the connection is maintained as changes to the shard map occur.</span></span> 

<span data-ttu-id="704d9-203">Poniższy przykładowy kod przedstawia sposób używania zasady ponawiania SQL wokół nowe **DbContext** podklas:</span><span class="sxs-lookup"><span data-stu-id="704d9-203">The following code sample illustrates how a SQL retry policy can be used around the new **DbContext** subclass constructors:</span></span> 

    SqlDatabaseUtils.SqlRetryPolicy.ExecuteAction(() => 
    { 
        using (var db = new ElasticScaleContext<int>( 
                                sharding.ShardMap,  
                                tenantId1,  
                                connStrBldr.ConnectionString)) 
            { 
                    var blog = new Blog { Name = name }; 
                    db.Blogs.Add(blog); 
                    db.SaveChanges(); 
            … 
            } 
        }); 

<span data-ttu-id="704d9-204">**SqlDatabaseUtils.SqlRetryPolicy** w powyższym kodzie jest zdefiniowany jako **SqlDatabaseTransientErrorDetectionStrategy** z liczbą ponowień równą 10 i 5 sekund oczekiwania czasu między kolejnymi próbami.</span><span class="sxs-lookup"><span data-stu-id="704d9-204">**SqlDatabaseUtils.SqlRetryPolicy** in the code above is defined as a **SqlDatabaseTransientErrorDetectionStrategy** with a retry count of 10, and 5 seconds wait time between retries.</span></span> <span data-ttu-id="704d9-205">Ta metoda jest podobna do wskazówek dotyczących EF i transakcji inicjowanych przez użytkownika (zobacz [ograniczenia strategiami ponowną próbą wykonania (EF6 i jego nowszych wersjach)](http://msdn.microsoft.com/data/dn307226).</span><span class="sxs-lookup"><span data-stu-id="704d9-205">This approach is similar to the guidance for EF and user-initiated transactions (see [Limitations with Retrying Execution Strategies (EF6 onwards)](http://msdn.microsoft.com/data/dn307226).</span></span> <span data-ttu-id="704d9-206">Obu sytuacjach wymagają, że program aplikacji steruje zakresu, do którego zwraca wyjątek przejściowej: Aby ponownie otworzyć transakcji albo (jak pokazano) odtworzyć kontekstu z prawidłowego konstruktora, który używa biblioteki klienta elastycznej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-206">Both situations require that the application program controls the scope to which the transient exception returns: to either reopen the transaction, or (as shown) recreate the context from the proper constructor that uses the elastic database client library.</span></span>

<span data-ttu-id="704d9-207">Potrzeba kontroli w przypadku gdy wyjątki przejściowej podjąć nam w zakresie także wyklucza stosowanie wbudowanych **klasy SqlAzureExecutionStrategy** dołączony EF.</span><span class="sxs-lookup"><span data-stu-id="704d9-207">The need to control where transient exceptions take us back in scope also precludes the use of the built-in **SqlAzureExecutionStrategy** that comes with EF.</span></span> <span data-ttu-id="704d9-208">**Klasy SqlAzureExecutionStrategy** będzie ponownie otworzyć połączenie, ale nie używać **OpenConnectionForKey** ominięcie walidacji utworzonej w ramach **OpenConnectionForKey**wywołania.</span><span class="sxs-lookup"><span data-stu-id="704d9-208">**SqlAzureExecutionStrategy** would reopen a connection but not use **OpenConnectionForKey** and therefore bypass all the validation that is performed as part of the **OpenConnectionForKey** call.</span></span> <span data-ttu-id="704d9-209">Zamiast tego przykładowy kod używa wbudowanej **DefaultExecutionStrategy** również dołączony EF.</span><span class="sxs-lookup"><span data-stu-id="704d9-209">Instead, the code sample uses the built-in **DefaultExecutionStrategy** that also comes with EF.</span></span> <span data-ttu-id="704d9-210">W przeciwieństwie do **klasy SqlAzureExecutionStrategy**, działa on prawidłowo w połączeniu z zasady ponawiania z obsługi błędów przejściowych.</span><span class="sxs-lookup"><span data-stu-id="704d9-210">As opposed to **SqlAzureExecutionStrategy**, it works correctly in combination with the retry policy from Transient Fault Handling.</span></span> <span data-ttu-id="704d9-211">Zasady wykonywania jest ustawiony **ElasticScaleDbConfiguration** klasy.</span><span class="sxs-lookup"><span data-stu-id="704d9-211">The execution policy is set in the **ElasticScaleDbConfiguration** class.</span></span> <span data-ttu-id="704d9-212">Należy pamiętać, że zdecydowaliśmy nie należy używać **DefaultSqlExecutionStrategy** ponieważ sugeruje, aby użyć **klasy SqlAzureExecutionStrategy** Jeśli wystąpią wyjątki przejściowy — która może spowodować nieprawidłowe zachowanie zgodnie z opisem.</span><span class="sxs-lookup"><span data-stu-id="704d9-212">Note that we decided not to use **DefaultSqlExecutionStrategy** since it suggests to use **SqlAzureExecutionStrategy** if transient exceptions occur - which would lead to wrong behavior as discussed.</span></span> <span data-ttu-id="704d9-213">Aby uzyskać więcej informacji na zasady ponawiania różnych i EF, zobacz [połączenia odporność EF](http://msdn.microsoft.com/data/dn456835.aspx).</span><span class="sxs-lookup"><span data-stu-id="704d9-213">For more information on the different retry policies and EF, see [Connection Resiliency in EF](http://msdn.microsoft.com/data/dn456835.aspx).</span></span>     

#### <a name="constructor-rewrites"></a><span data-ttu-id="704d9-214">Konstruktor modyfikacji oprogramowania</span><span class="sxs-lookup"><span data-stu-id="704d9-214">Constructor rewrites</span></span>
<span data-ttu-id="704d9-215">Powyższe przykłady kodu przedstawiono domyślny konstruktor ponownie zapisuje wymagane dla aplikacji, aby można było używać danych zależnych routingu z programu Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="704d9-215">The code examples above illustrate the default constructor re-writes required for your application in order to use  data dependent routing with the Entity Framework.</span></span> <span data-ttu-id="704d9-216">Poniższa tabela stanowi uogólnienie takie podejście do innych konstruktorów.</span><span class="sxs-lookup"><span data-stu-id="704d9-216">The following table generalizes this approach to other constructors.</span></span> 

| <span data-ttu-id="704d9-217">Bieżący Konstruktor</span><span class="sxs-lookup"><span data-stu-id="704d9-217">Current Constructor</span></span> | <span data-ttu-id="704d9-218">Konstruktor nowych danych</span><span class="sxs-lookup"><span data-stu-id="704d9-218">Rewritten Constructor for data</span></span> | <span data-ttu-id="704d9-219">Konstruktora podstawowego</span><span class="sxs-lookup"><span data-stu-id="704d9-219">Base Constructor</span></span> | <span data-ttu-id="704d9-220">Uwagi</span><span class="sxs-lookup"><span data-stu-id="704d9-220">Notes</span></span> |
| --- | --- | --- | --- |
| <span data-ttu-id="704d9-221">MyContext()</span><span class="sxs-lookup"><span data-stu-id="704d9-221">MyContext()</span></span> |<span data-ttu-id="704d9-222">ElasticScaleContext (ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="704d9-222">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="704d9-223">DbContext (DbConnection, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-223">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="704d9-224">Połączenie musi być funkcją mapy niezależnego fragmentu i klucza routingu zależne od danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-224">The connection needs to be a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="704d9-225">Trzeba obejścia połączenia automatycznego tworzenia przez EF i zamiast tego użyć mapy niezależnego fragmentu do broker połączenia.</span><span class="sxs-lookup"><span data-stu-id="704d9-225">You need to by-pass automatic connection creation by EF and instead use the shard map to broker the connection.</span></span> |
| <span data-ttu-id="704d9-226">MyContext(string)</span><span class="sxs-lookup"><span data-stu-id="704d9-226">MyContext(string)</span></span> |<span data-ttu-id="704d9-227">ElasticScaleContext (ShardMap, TKey)</span><span class="sxs-lookup"><span data-stu-id="704d9-227">ElasticScaleContext(ShardMap, TKey)</span></span> |<span data-ttu-id="704d9-228">DbContext (DbConnection, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-228">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="704d9-229">Połączenie jest funkcją mapy niezależnego fragmentu i klucz routingu zależne od danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-229">The connection is a function of the shard map and the data-dependent routing key.</span></span> <span data-ttu-id="704d9-230">Stałej bazy danych nazwa lub parametry połączenia nie będą działać jako ich obejścia weryfikacji przez niezależnego fragmentu mapy.</span><span class="sxs-lookup"><span data-stu-id="704d9-230">A fixed database name or connection string will not work as they by-pass validation by the shard map.</span></span> |
| <span data-ttu-id="704d9-231">MyContext(DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="704d9-231">MyContext(DbCompiledModel)</span></span> |<span data-ttu-id="704d9-232">ElasticScaleContext (ShardMap, TKey, model DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="704d9-232">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="704d9-233">DbContext (DbConnection, model DbCompiledModel, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-233">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="704d9-234">Połączenia zostaną utworzone dla danego niezależnych klucza mapy i dzielenia na fragmenty z modelem podane.</span><span class="sxs-lookup"><span data-stu-id="704d9-234">The connection will get created for the given shard map and sharding key with the model provided.</span></span> <span data-ttu-id="704d9-235">Skompilowany modelu zostaną przekazane do podstawowej c'tor.</span><span class="sxs-lookup"><span data-stu-id="704d9-235">The compiled model will be passed on to the base c’tor.</span></span> |
| <span data-ttu-id="704d9-236">MyContext (DbConnection, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-236">MyContext(DbConnection, bool)</span></span> |<span data-ttu-id="704d9-237">ElasticScaleContext (ShardMap, TKey, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-237">ElasticScaleContext(ShardMap, TKey, bool)</span></span> |<span data-ttu-id="704d9-238">DbContext (DbConnection, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-238">DbContext(DbConnection, bool)</span></span> |<span data-ttu-id="704d9-239">Połączenie musi można wywnioskować na podstawie mapowania niezależnego fragmentu i klucz.</span><span class="sxs-lookup"><span data-stu-id="704d9-239">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="704d9-240">Nie można podać jako dane wejściowe, (chyba że te dane wejściowe korzystał już z mapy niezależnych oraz klucz).</span><span class="sxs-lookup"><span data-stu-id="704d9-240">It cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="704d9-241">Wartość logiczna zostaną przekazane.</span><span class="sxs-lookup"><span data-stu-id="704d9-241">The Boolean will be passed on.</span></span> |
| <span data-ttu-id="704d9-242">MyContext (ciąg, model DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="704d9-242">MyContext(string, DbCompiledModel)</span></span> |<span data-ttu-id="704d9-243">ElasticScaleContext (ShardMap, TKey, model DbCompiledModel)</span><span class="sxs-lookup"><span data-stu-id="704d9-243">ElasticScaleContext(ShardMap, TKey, DbCompiledModel)</span></span> |<span data-ttu-id="704d9-244">DbContext (DbConnection, model DbCompiledModel, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-244">DbContext(DbConnection, DbCompiledModel, bool)</span></span> |<span data-ttu-id="704d9-245">Połączenie musi można wywnioskować na podstawie mapowania niezależnego fragmentu i klucz.</span><span class="sxs-lookup"><span data-stu-id="704d9-245">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="704d9-246">Nie można podać jako dane wejściowe, (chyba że te dane wejściowe używał mapy niezależnych oraz klucz).</span><span class="sxs-lookup"><span data-stu-id="704d9-246">It cannot be provided as an input (unless that input was using the shard map and the key).</span></span> <span data-ttu-id="704d9-247">Skompilowany modelu zostaną przekazane.</span><span class="sxs-lookup"><span data-stu-id="704d9-247">The compiled model will be passed on.</span></span> |
| <span data-ttu-id="704d9-248">MyContext (ObjectContext, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-248">MyContext(ObjectContext, bool)</span></span> |<span data-ttu-id="704d9-249">ElasticScaleContext (ShardMap TKey, ObjectContext, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-249">ElasticScaleContext(ShardMap, TKey, ObjectContext, bool)</span></span> |<span data-ttu-id="704d9-250">DbContext (ObjectContext, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-250">DbContext(ObjectContext, bool)</span></span> |<span data-ttu-id="704d9-251">Nowy Konstruktor musi upewnić, że wszystkie połączenia w obiekcie ObjectContext przekazany jako dane wejściowe jest przekierowane do połączenia zarządza elastycznego skalowania.</span><span class="sxs-lookup"><span data-stu-id="704d9-251">The new constructor needs to ensure that any connection in the ObjectContext passed as an input is re-routed to a connection managed by Elastic Scale.</span></span> <span data-ttu-id="704d9-252">Szczegółowe omówienie ObjectContexts wykracza poza zakres tego dokumentu.</span><span class="sxs-lookup"><span data-stu-id="704d9-252">A detailed discussion of ObjectContexts is beyond the scope of this document.</span></span> |
| <span data-ttu-id="704d9-253">MyContext (DbConnection, model DbCompiledModel, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-253">MyContext(DbConnection, DbCompiledModel,bool)</span></span> |<span data-ttu-id="704d9-254">ElasticScaleContext (ShardMap TKey, model DbCompiledModel, wartość logiczna)</span><span class="sxs-lookup"><span data-stu-id="704d9-254">ElasticScaleContext(ShardMap, TKey, DbCompiledModel, bool)</span></span> |<span data-ttu-id="704d9-255">DbContext (DbConnection, model DbCompiledModel, wartość logiczna);</span><span class="sxs-lookup"><span data-stu-id="704d9-255">DbContext(DbConnection, DbCompiledModel, bool);</span></span> |<span data-ttu-id="704d9-256">Połączenie musi można wywnioskować na podstawie mapowania niezależnego fragmentu i klucz.</span><span class="sxs-lookup"><span data-stu-id="704d9-256">The connection needs to be inferred from the shard map and the key.</span></span> <span data-ttu-id="704d9-257">Połączenie nie można podać jako danych wejściowych (chyba że te dane wejściowe korzystał już z mapy niezależnych oraz klucz).</span><span class="sxs-lookup"><span data-stu-id="704d9-257">The connection cannot be provided as an input (unless that input was already using the shard map and the key).</span></span> <span data-ttu-id="704d9-258">Model i wartość logiczną są przekazywane do konstruktora klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="704d9-258">Model and Boolean are passed on to the base class constructor.</span></span> |

## <a name="shard-schema-deployment-through-ef-migrations"></a><span data-ttu-id="704d9-259">Identyfikator niezależnego fragmentu wdrożenia schematu za pomocą migracji EF</span><span class="sxs-lookup"><span data-stu-id="704d9-259">Shard schema deployment through EF migrations</span></span>
<span data-ttu-id="704d9-260">Zarządzanie automatyczne schematu jest udogodnienie pochodzącymi z programu Entity Framework.</span><span class="sxs-lookup"><span data-stu-id="704d9-260">Automatic schema management is a convenience provided by the Entity Framework.</span></span> <span data-ttu-id="704d9-261">W kontekście aplikacji przy użyciu narzędzi elastycznej bazy danych chcemy się zachować tej możliwości, aby automatycznie udostępniać schemat odłamków nowo utworzone po dodaniu bazy danych podzielonej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="704d9-261">In the context of applications using elastic database tools, we want to retain this capability to automatically provision the schema to newly created shards when databases are added to the sharded application.</span></span> <span data-ttu-id="704d9-262">Pierwotnym zastosowaniem jest zwiększenie pojemności w warstwie danych podzielonej aplikacji za pomocą EF.</span><span class="sxs-lookup"><span data-stu-id="704d9-262">The primary use case is to increase capacity at the data tier for sharded applications using EF.</span></span> <span data-ttu-id="704d9-263">Zależne EF jego możliwości zarządzania schematu zmniejsza nakład pracy administracyjnej bazy danych z aplikacją podzielonej oparty na EF.</span><span class="sxs-lookup"><span data-stu-id="704d9-263">Relying on EF’s capabilities for schema management reduces the database administration effort with a sharded application built on EF.</span></span> 

<span data-ttu-id="704d9-264">Wdrożenia schematu za pomocą migracji EF najlepiej **bez otwierania połączenia**.</span><span class="sxs-lookup"><span data-stu-id="704d9-264">Schema deployment through EF migrations works best on **unopened connections**.</span></span> <span data-ttu-id="704d9-265">To jest w przeciwieństwie do scenariusza dla zależne od danych routingu korzystający otwarte połączenie udostępniane przez interfejs API klienta elastycznej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-265">This is in contrast to the scenario for data dependent routing that relies on the opened connection provided by the elastic database client API.</span></span> <span data-ttu-id="704d9-266">Inna różnica polega na wymaganie spójności: podczas pożądane w celu zapewnienia spójności dla wszystkich połączeń routingu zależne od danych do ochrony przed manipulowania mapy równoczesnych niezależnego fragmentu nie jest problemem za pomocą początkowego wdrożenia schemat na nowe bazy danych ma jeszcze nie został zarejestrowany w mapie niezależnego fragmentu i jeszcze nie została przydzielona do przechowywania shardlets.</span><span class="sxs-lookup"><span data-stu-id="704d9-266">Another difference is the consistency requirement: While desirable to ensure consistency for all data-dependent routing connections to protect against concurrent shard map manipulation, it is not a concern with initial schema deployment to a new database that has not yet been registered in the shard map, and not yet been allocated to hold shardlets.</span></span> <span data-ttu-id="704d9-267">Firma Microsoft w związku z tym zależne połączeń zwykłej bazy danych dla tego scenariuszy, zamiast routingu zależne od danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-267">We can therefore rely on regular database connections for this scenarios, as opposed to data-dependent routing.</span></span>  

<span data-ttu-id="704d9-268">Prowadzi to do podejście gdzie wdrożenia schematu za pomocą migracji EF jest ściśle powiązane z rejestracją nową bazę danych jako niezależnego fragmentu w mapie niezależnych aplikacji.</span><span class="sxs-lookup"><span data-stu-id="704d9-268">This leads to an approach where schema deployment through EF migrations is tightly coupled with the registration of the new database as a shard in the application’s shard map.</span></span> <span data-ttu-id="704d9-269">To opiera się na następujące wymagania wstępne:</span><span class="sxs-lookup"><span data-stu-id="704d9-269">This relies on the following prerequisites:</span></span> 

* <span data-ttu-id="704d9-270">Bazy danych już istnieje.</span><span class="sxs-lookup"><span data-stu-id="704d9-270">The database has already been created.</span></span> 
* <span data-ttu-id="704d9-271">Baza danych jest pusta — posiada nie użytkowników schematu i danych użytkownika.</span><span class="sxs-lookup"><span data-stu-id="704d9-271">The database is empty - it holds no user schema and no user data.</span></span>
* <span data-ttu-id="704d9-272">Bazy danych nie są jeszcze dostępne za pośrednictwem interfejsów API klienta elastycznej bazy danych dla routingu zależne od danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-272">The database cannot yet be accessed through the elastic database client APIs for data-dependent routing.</span></span> 

<span data-ttu-id="704d9-273">Z tych wymagań wstępnych w miejscu, możemy utworzyć zwykły bez otwartego **SqlConnection** można rozpocząć poza EF migracji wdrożenia schematu.</span><span class="sxs-lookup"><span data-stu-id="704d9-273">With these prerequisites in place, we can create a regular un-opened **SqlConnection** to kick off EF migrations for schema deployment.</span></span> <span data-ttu-id="704d9-274">Poniższy przykładowy kod przedstawia tej metody.</span><span class="sxs-lookup"><span data-stu-id="704d9-274">The following code sample illustrates this approach.</span></span> 

        // Enter a new shard - i.e. an empty database - to the shard map, allocate a first tenant to it  
        // and kick off EF intialization of the database to deploy schema 

        public void RegisterNewShard(string server, string database, string connStr, int key) 
        { 

            Shard shard = this.ShardMap.CreateShard(new ShardLocation(server, database)); 

            SqlConnectionStringBuilder connStrBldr = new SqlConnectionStringBuilder(connStr); 
            connStrBldr.DataSource = server; 
            connStrBldr.InitialCatalog = database; 

            // Go into a DbContext to trigger migrations and schema deployment for the new shard. 
            // This requires an un-opened connection. 
            using (var db = new ElasticScaleContext<int>(connStrBldr.ConnectionString)) 
            { 
                // Run a query to engage EF migrations 
                (from b in db.Blogs 
                    select b).Count(); 
            } 

            // Register the mapping of the tenant to the shard in the shard map. 
            // After this step, data-dependent routing on the shard map can be used 

            this.ShardMap.CreatePointMapping(key, shard); 
        } 


<span data-ttu-id="704d9-275">W tym przykładzie pokazano metodę **RegisterNewShard** który rejestruje niezależnego fragmentu w mapie niezależnego fragmentu, wdraża schematu za pomocą migracji EF i przechowuje mapowanie klucz dzielenia na fragmenty, aby niezależnego fragmentu.</span><span class="sxs-lookup"><span data-stu-id="704d9-275">This sample shows the method **RegisterNewShard** that registers the shard in the shard map, deploys the schema through EF migrations, and stores a mapping of a sharding key to the shard.</span></span> <span data-ttu-id="704d9-276">Zależy od konstruktora **DbContext** podklasy (**ElasticScaleContext** w próbce) pobierającej parametrów połączenia SQL jako dane wejściowe.</span><span class="sxs-lookup"><span data-stu-id="704d9-276">It relies on a constructor of the **DbContext** subclass (**ElasticScaleContext** in the sample) that takes a SQL connection string as input.</span></span> <span data-ttu-id="704d9-277">Kod tego konstruktora jest proste, jak przedstawiono na poniższym przykładzie:</span><span class="sxs-lookup"><span data-stu-id="704d9-277">The code of this constructor is straight-forward, as the following example shows:</span></span> 

        // C'tor to deploy schema and migrations to a new shard 
        protected internal ElasticScaleContext(string connectionString) 
            : base(SetInitializerForConnection(connectionString)) 
        { 
        } 

        // Only static methods are allowed in calls into base class c'tors 
        private static string SetInitializerForConnection(string connnectionString) 
        { 
            // We want existence checks so that the schema can get deployed 
            Database.SetInitializer<ElasticScaleContext<T>>( 
        new CreateDatabaseIfNotExists<ElasticScaleContext<T>>()); 

            return connnectionString; 
        } 

<span data-ttu-id="704d9-278">Co najmniej jedna może być używana wersja konstruktora dziedziczona z klasy podstawowej.</span><span class="sxs-lookup"><span data-stu-id="704d9-278">One might have used the version of the constructor inherited from the base class.</span></span> <span data-ttu-id="704d9-279">Jednak kod musi zapewnić, że inicjator domyślne EF jest używana podczas łączenia.</span><span class="sxs-lookup"><span data-stu-id="704d9-279">But the code needs to ensure that the default initializer for EF is used when connecting.</span></span> <span data-ttu-id="704d9-280">Dlatego krótkim przekierować do metody statycznej przed wywołaniem do konstruktora klasy podstawowej z parametrami połączenia.</span><span class="sxs-lookup"><span data-stu-id="704d9-280">Hence the short detour into the static method before calling into the base class constructor with the connection string.</span></span> <span data-ttu-id="704d9-281">Należy pamiętać, że rejestracja odłamków powinno być ono uruchomione w innej domeny aplikacji lub proces, aby upewnić się, czy ustawienia inicjatora EF nie są w konflikcie.</span><span class="sxs-lookup"><span data-stu-id="704d9-281">Note that the registration of shards should run in a different app domain or process to ensure that the initializer settings for EF do not conflict.</span></span> 

## <a name="limitations"></a><span data-ttu-id="704d9-282">Ograniczenia</span><span class="sxs-lookup"><span data-stu-id="704d9-282">Limitations</span></span>
<span data-ttu-id="704d9-283">Metod opisanych w tym dokumencie pociąga za sobą kilka ograniczeń:</span><span class="sxs-lookup"><span data-stu-id="704d9-283">The approaches outlined in this document entail a couple of limitations:</span></span> 

* <span data-ttu-id="704d9-284">EF aplikacji, które używają **LocalDb** najpierw należy przeprowadzić migrację do zwykłej bazy danych programu SQL Server przed rozpoczęciem korzystania z biblioteki klienta elastycznej bazy danych.</span><span class="sxs-lookup"><span data-stu-id="704d9-284">EF applications that use **LocalDb** first need to migrate to a regular SQL Server database before using elastic database client library.</span></span> <span data-ttu-id="704d9-285">Skalowania aplikacji za pośrednictwem dzielenia na fragmenty o elastycznego skalowania nie jest możliwe za pomocą **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="704d9-285">Scaling out an application through sharding with Elastic Scale is not possible with **LocalDb**.</span></span> <span data-ttu-id="704d9-286">Należy pamiętać, że programowanie można nadal używać **LocalDb**.</span><span class="sxs-lookup"><span data-stu-id="704d9-286">Note that development can still use **LocalDb**.</span></span> 
* <span data-ttu-id="704d9-287">Wszelkie zmiany do aplikacji, które oznacza zmiany schematu bazy danych muszą przejść przez migracje EF na wszystkich fragmentów.</span><span class="sxs-lookup"><span data-stu-id="704d9-287">Any changes to the application that imply database schema changes need to go through EF migrations on all shards.</span></span> <span data-ttu-id="704d9-288">Przykładowy kod dla tego dokumentu nie pokazują, jak to zrobić.</span><span class="sxs-lookup"><span data-stu-id="704d9-288">The sample code for this document does not demonstrate how to do this.</span></span> <span data-ttu-id="704d9-289">Przy użyciu polecenia Update-Database z parametrem ConnectionString iteracja wszystkich odłamków; lub Wyodrębnij skryptu T-SQL oczekujące migracji, za pomocą Update-Database skrypt opcji i dotyczą skryptu T-SQL z fragmentów.</span><span class="sxs-lookup"><span data-stu-id="704d9-289">Consider using Update-Database with a ConnectionString parameter to iterate over all shards; or extract the T-SQL script for the pending migration using Update-Database with the -Script option and apply the T-SQL script to your shards.</span></span>  
* <span data-ttu-id="704d9-290">Biorąc pod uwagę na żądanie, zakłada się, że wszystkie jego przetwarzanie bazy danych znajduje się w obrębie jednego niezależnego fragmentu określonej za pomocą klucza dzielenia na fragmenty udostępnionego przez żądanie.</span><span class="sxs-lookup"><span data-stu-id="704d9-290">Given a request, it is assumed that all of its database processing is contained within a single shard as identified by the sharding key provided by the request.</span></span> <span data-ttu-id="704d9-291">Jednak to założenie nie zawsze ma wartość true.</span><span class="sxs-lookup"><span data-stu-id="704d9-291">However, this assumption does not always hold true.</span></span> <span data-ttu-id="704d9-292">Na przykład, gdy go nie jest możliwe do udostępnienia klucza dzielenia na fragmenty.</span><span class="sxs-lookup"><span data-stu-id="704d9-292">For example, when it is not possible to make a sharding key available.</span></span> <span data-ttu-id="704d9-293">Aby rozwiązać ten problem, udostępnia biblioteki klienckiej **MultiShardQuery** klasa implementująca abstrakcji połączenia, na potrzeby zapytań przez kilka fragmentów.</span><span class="sxs-lookup"><span data-stu-id="704d9-293">To address this, the client library provides the **MultiShardQuery** class that implements a connection abstraction for querying over several shards.</span></span> <span data-ttu-id="704d9-294">Nauka korzystania **MultiShardQuery** w połączeniu z EF wykracza poza zakres tego dokumentu</span><span class="sxs-lookup"><span data-stu-id="704d9-294">Learning to use the **MultiShardQuery** in combination with EF is beyond the scope of this document</span></span>

## <a name="conclusion"></a><span data-ttu-id="704d9-295">Podsumowanie</span><span class="sxs-lookup"><span data-stu-id="704d9-295">Conclusion</span></span>
<span data-ttu-id="704d9-296">Kroki opisane w niniejszym dokumencie EF aplikacje mogą używać możliwości biblioteki klienta elastycznej bazy danych dla danych zależnych routingu w ramach refaktoryzacji elementu konstruktorów **DbContext** używane w aplikacji EF podklasy.</span><span class="sxs-lookup"><span data-stu-id="704d9-296">Through the steps outlined in this document, EF applications can use the elastic database client library's capability for data dependent routing by refactoring constructors of the **DbContext** subclasses used in the EF application.</span></span> <span data-ttu-id="704d9-297">To ogranicza zmiany wymagane do tych miejscach gdzie **DbContext** klasy już istnieje.</span><span class="sxs-lookup"><span data-stu-id="704d9-297">This limits the  changes required to those places where **DbContext** classes already exist.</span></span> <span data-ttu-id="704d9-298">Ponadto aplikacje EF można nadal korzystać z wdrażania automatycznego schematu łącząc kroki, które wywołują migracji konieczne EF z rejestracją nowych fragmentów i mapowania na mapie niezależnego fragmentu.</span><span class="sxs-lookup"><span data-stu-id="704d9-298">In addition, EF applications can continue to benefit from automatic schema deployment by combining the steps that invoke the necessary EF migrations with the registration of new shards and mappings in the shard map.</span></span> 

[!INCLUDE [elastic-scale-include](../../includes/elastic-scale-include.md)]

<!--Image references-->
[1]: ./media/sql-database-elastic-scale-use-entity-framework-applications-visual-studio/sample.png
