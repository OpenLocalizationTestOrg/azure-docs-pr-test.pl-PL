---
title: "Azure kontrolną wydajności i skalowalności magazynu | Dokumentacja firmy Microsoft"
description: "Lista kontrolna sprawdzonych rozwiązań do użycia z usługą Azure Storage w tworzeniu wydajność aplikacji."
services: storage
documentationcenter: 
author: robinsh
manager: timlt
editor: tysonn
ms.assetid: 959d831b-a4fd-4634-a646-0d2c0c462ef8
ms.service: storage
ms.workload: storage
ms.tgt_pltfrm: na
ms.devlang: na
ms.topic: article
ms.date: 12/08/2016
ms.author: robinsh
ms.openlocfilehash: c12f98b069689e335d308d8f8edba2dece21d806
ms.sourcegitcommit: f537befafb079256fba0529ee554c034d73f36b0
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 07/11/2017
---
# <a name="microsoft-azure-storage-performance-and-scalability-checklist"></a><span data-ttu-id="87de6-103">Lista kontrolna dotycząca wydajności i skalowalności usługi Microsoft Azure Storage</span><span class="sxs-lookup"><span data-stu-id="87de6-103">Microsoft Azure Storage Performance and Scalability Checklist</span></span>
## <a name="overview"></a><span data-ttu-id="87de6-104">Omówienie</span><span class="sxs-lookup"><span data-stu-id="87de6-104">Overview</span></span>
<span data-ttu-id="87de6-105">Po wydaniu usługi Microsoft Azure Storage firma Microsoft opracowała liczba sprawdzonych wskazówki dotyczące korzystania z tych usług w sposób wydajności, a w tym artykule służy do konsolidowania najważniejszych je na listę kontrolną stylu.</span><span class="sxs-lookup"><span data-stu-id="87de6-105">Since the release of the Microsoft Azure Storage services, Microsoft has developed a number of proven practices for using these services in a performant manner, and this article serves to consolidate the most important of them into a checklist-style list.</span></span> <span data-ttu-id="87de6-106">Części tego artykułu jest ułatwia deweloperom aplikacji, sprawdź, czy używasz sprawdzonych rozwiązań z usługą Azure Storage oraz pomoc w identyfikacji innych sprawdzonych rozwiązań, należy rozważyć stosowanie.</span><span class="sxs-lookup"><span data-stu-id="87de6-106">The intention of this article is to help application developers verify they are using proven practices with Azure Storage and to help them identify other proven practices they should consider adopting.</span></span> <span data-ttu-id="87de6-107">W tym artykule nie jest podejmowana próba obejmuje co możliwe optymalizacji wydajności i skalowalności —, ale nie uwzględnia te, które są niewielkie ich wpływ lub nie ogólnie dotyczy.</span><span class="sxs-lookup"><span data-stu-id="87de6-107">This article does not attempt to cover every possible performance and scalability optimization — it excludes those that are small in their impact or not broadly applicable.</span></span> <span data-ttu-id="87de6-108">W takim zakresie, w jakim można przewidzieć zachowania aplikacji podczas projektowania, warto zachować te pamiętać na wczesnym etapie, aby uniknąć projektów, które będą uruchamiane na problemy z wydajnością.</span><span class="sxs-lookup"><span data-stu-id="87de6-108">To the extent that the application's behavior can be predicted during design, it's useful to keep these in mind early on to avoid designs that will run into performance problems.</span></span>  

<span data-ttu-id="87de6-109">Każdy deweloper aplikacji przy użyciu usługi Azure Storage powinien trwać przeczytaj ten artykuł, i sprawdź, czy aplikacji lub jej zgodny z każdego sprawdzonych rozwiązań wymienionych poniżej.</span><span class="sxs-lookup"><span data-stu-id="87de6-109">Every application developer using Azure Storage should take the time to read this article, and check that his or her application follows each of the proven practices listed below.</span></span>  

## <a name="checklist"></a><span data-ttu-id="87de6-110">Lista kontrolna</span><span class="sxs-lookup"><span data-stu-id="87de6-110">Checklist</span></span>
<span data-ttu-id="87de6-111">W tym artykule organizuje sprawdzonych rozwiązań w następujących grup.</span><span class="sxs-lookup"><span data-stu-id="87de6-111">This article organizes the proven practices into the following groups.</span></span> <span data-ttu-id="87de6-112">Sprawdzonych rozwiązań mające zastosowanie do:</span><span class="sxs-lookup"><span data-stu-id="87de6-112">Proven practices applicable to:</span></span>  

* <span data-ttu-id="87de6-113">Wszystkie usługi Azure Storage (obiekty BLOB, tabel, kolejek i plików)</span><span class="sxs-lookup"><span data-stu-id="87de6-113">All Azure Storage services (blobs, tables, queues, and files)</span></span>
* <span data-ttu-id="87de6-114">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-114">Blobs</span></span>
* <span data-ttu-id="87de6-115">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-115">Tables</span></span>
* <span data-ttu-id="87de6-116">Kolejki</span><span class="sxs-lookup"><span data-stu-id="87de6-116">Queues</span></span>  

| <span data-ttu-id="87de6-117">Gotowe</span><span class="sxs-lookup"><span data-stu-id="87de6-117">Done</span></span> | <span data-ttu-id="87de6-118">Obszar</span><span class="sxs-lookup"><span data-stu-id="87de6-118">Area</span></span> | <span data-ttu-id="87de6-119">Kategoria</span><span class="sxs-lookup"><span data-stu-id="87de6-119">Category</span></span> | <span data-ttu-id="87de6-120">Zapytania</span><span class="sxs-lookup"><span data-stu-id="87de6-120">Question</span></span> |
| --- | --- | --- | --- |
| &nbsp; | <span data-ttu-id="87de6-121">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-121">All Services</span></span> |<span data-ttu-id="87de6-122">Wartości docelowe skalowalności</span><span class="sxs-lookup"><span data-stu-id="87de6-122">Scalability Targets</span></span> |[<span data-ttu-id="87de6-123">Aplikacja zaprojektowano w celu uniknięcia zbliża się wartości docelowe skalowalności?</span><span class="sxs-lookup"><span data-stu-id="87de6-123">Is your application designed to avoid approaching the scalability targets?</span></span>](#subheading1) |
| &nbsp; | <span data-ttu-id="87de6-124">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-124">All Services</span></span> |<span data-ttu-id="87de6-125">Wartości docelowe skalowalności</span><span class="sxs-lookup"><span data-stu-id="87de6-125">Scalability Targets</span></span> |[<span data-ttu-id="87de6-126">Konwencja nazewnictwa zaprojektowana w celu umożliwienia lepszego równoważenia obciążenia?</span><span class="sxs-lookup"><span data-stu-id="87de6-126">Is your naming convention designed to enable better load-balancing?</span></span>](#subheading47) |
| &nbsp; | <span data-ttu-id="87de6-127">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-127">All Services</span></span> |<span data-ttu-id="87de6-128">Sieć</span><span class="sxs-lookup"><span data-stu-id="87de6-128">Networking</span></span> |[<span data-ttu-id="87de6-129">Czy urządzenia po stronie klienta mają wystarczająco dużej przepustowości i małe opóźnienia do osiągnięcia wydajności potrzebne?</span><span class="sxs-lookup"><span data-stu-id="87de6-129">Do client side devices have sufficiently high bandwidth and low latency to achieve the performance needed?</span></span>](#subheading2) |
| &nbsp; | <span data-ttu-id="87de6-130">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-130">All Services</span></span> |<span data-ttu-id="87de6-131">Sieć</span><span class="sxs-lookup"><span data-stu-id="87de6-131">Networking</span></span> |[<span data-ttu-id="87de6-132">Czy urządzenia po stronie klienta mają łącze wystarczająco wysokiej jakości?</span><span class="sxs-lookup"><span data-stu-id="87de6-132">Do client side devices have a high enough quality link?</span></span>](#subheading3) |
| &nbsp; | <span data-ttu-id="87de6-133">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-133">All Services</span></span> |<span data-ttu-id="87de6-134">Sieć</span><span class="sxs-lookup"><span data-stu-id="87de6-134">Networking</span></span> |[<span data-ttu-id="87de6-135">Aplikacja kliencka znajduje się "na koncie magazynu u"?</span><span class="sxs-lookup"><span data-stu-id="87de6-135">Is the client application located "near" the storage account?</span></span>](#subheading4) |
| &nbsp; | <span data-ttu-id="87de6-136">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-136">All Services</span></span> |<span data-ttu-id="87de6-137">Dystrybucja zawartości</span><span class="sxs-lookup"><span data-stu-id="87de6-137">Content Distribution</span></span> |[<span data-ttu-id="87de6-138">Używasz CDN do dystrybucji zawartości?</span><span class="sxs-lookup"><span data-stu-id="87de6-138">Are you using a CDN for content distribution?</span></span>](#subheading5) |
| &nbsp; | <span data-ttu-id="87de6-139">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-139">All Services</span></span> |<span data-ttu-id="87de6-140">Bezpośredni dostęp klienta</span><span class="sxs-lookup"><span data-stu-id="87de6-140">Direct Client Access</span></span> |[<span data-ttu-id="87de6-141">Używasz SAS i mechanizmu CORS umożliwia bezpośredni dostęp do magazynu, zamiast serwera proxy?</span><span class="sxs-lookup"><span data-stu-id="87de6-141">Are you using SAS and CORS to allow direct access to storage instead of proxy?</span></span>](#subheading6) |
| &nbsp; | <span data-ttu-id="87de6-142">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-142">All Services</span></span> |<span data-ttu-id="87de6-143">Buforowanie</span><span class="sxs-lookup"><span data-stu-id="87de6-143">Caching</span></span> |[<span data-ttu-id="87de6-144">Jest rzadko buforowania danych aplikacji, często używany i zmiany?</span><span class="sxs-lookup"><span data-stu-id="87de6-144">Is your application caching data that is repeatedly used and changes rarely?</span></span>](#subheading7) |
| &nbsp; | <span data-ttu-id="87de6-145">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-145">All Services</span></span> |<span data-ttu-id="87de6-146">Buforowanie</span><span class="sxs-lookup"><span data-stu-id="87de6-146">Caching</span></span> |[<span data-ttu-id="87de6-147">Aplikacja jest przetwarzanie wsadowe aktualizacji (buforowanie je po stronie klienta, a następnie przekazywania w większych zestawów)?</span><span class="sxs-lookup"><span data-stu-id="87de6-147">Is your application batching updates (caching them client side and then uploading in larger sets)?</span></span>](#subheading8) |
| &nbsp; | <span data-ttu-id="87de6-148">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-148">All Services</span></span> |<span data-ttu-id="87de6-149">Konfiguracja .NET</span><span class="sxs-lookup"><span data-stu-id="87de6-149">.NET Configuration</span></span> |[<span data-ttu-id="87de6-150">Czy skonfigurowano z klienta do używania wystarczającą liczbę równoczesnych połączeń?</span><span class="sxs-lookup"><span data-stu-id="87de6-150">Have you configured your client to use a sufficient number of concurrent connections?</span></span>](#subheading9) |
| &nbsp; | <span data-ttu-id="87de6-151">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-151">All Services</span></span> |<span data-ttu-id="87de6-152">Konfiguracja .NET</span><span class="sxs-lookup"><span data-stu-id="87de6-152">.NET Configuration</span></span> |[<span data-ttu-id="87de6-153">Czy skonfigurowano platformy .NET, użyj wystarczającą liczbę wątków?</span><span class="sxs-lookup"><span data-stu-id="87de6-153">Have you configured .NET to use a sufficient number of threads?</span></span>](#subheading10) |
| &nbsp; | <span data-ttu-id="87de6-154">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-154">All Services</span></span> |<span data-ttu-id="87de6-155">Konfiguracja .NET</span><span class="sxs-lookup"><span data-stu-id="87de6-155">.NET Configuration</span></span> |[<span data-ttu-id="87de6-156">Używasz .NET 4.5 lub nowszy, która została ulepszona wyrzucanie elementów bezużytecznych?</span><span class="sxs-lookup"><span data-stu-id="87de6-156">Are you using .NET 4.5 or later, which has improved garbage collection?</span></span>](#subheading11) |
| &nbsp; | <span data-ttu-id="87de6-157">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-157">All Services</span></span> |<span data-ttu-id="87de6-158">Równoległość</span><span class="sxs-lookup"><span data-stu-id="87de6-158">Parallelism</span></span> |[<span data-ttu-id="87de6-159">Ma zapewnić że równoległości jest ograniczone odpowiednio tak, aby nie przeciążać możliwości klienta lub wartości docelowe skalowalności?</span><span class="sxs-lookup"><span data-stu-id="87de6-159">Have you ensured that parallelism is bounded appropriately so that you don't overload either your client capabilities or the scalability targets?</span></span>](#subheading12) |
| &nbsp; | <span data-ttu-id="87de6-160">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-160">All Services</span></span> |<span data-ttu-id="87de6-161">Narzędzia</span><span class="sxs-lookup"><span data-stu-id="87de6-161">Tools</span></span> |[<span data-ttu-id="87de6-162">Za pomocą najnowszej wersji programu Microsoft znajdują się narzędzia i bibliotek klienta?</span><span class="sxs-lookup"><span data-stu-id="87de6-162">Are you using the latest version of Microsoft provided client libraries and tools?</span></span>](#subheading13) |
| &nbsp; | <span data-ttu-id="87de6-163">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-163">All Services</span></span> |<span data-ttu-id="87de6-164">Ponowne próby</span><span class="sxs-lookup"><span data-stu-id="87de6-164">Retries</span></span> |[<span data-ttu-id="87de6-165">Czy na pewno przy użyciu wykładniczego wycofywania ponawiania zasady ograniczania błędów i limity czasu?</span><span class="sxs-lookup"><span data-stu-id="87de6-165">Are you using an exponential backoff retry policy for throttling errors and timeouts?</span></span>](#subheading14) |
| &nbsp; | <span data-ttu-id="87de6-166">Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-166">All Services</span></span> |<span data-ttu-id="87de6-167">Ponowne próby</span><span class="sxs-lookup"><span data-stu-id="87de6-167">Retries</span></span> |[<span data-ttu-id="87de6-168">Jest unikanie ponownych prób Twojej aplikacji niepowtarzającego błędów?</span><span class="sxs-lookup"><span data-stu-id="87de6-168">Is your application avoiding retries for non-retryable errors?</span></span>](#subheading15) |
| &nbsp; | <span data-ttu-id="87de6-169">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-169">Blobs</span></span> |<span data-ttu-id="87de6-170">Wartości docelowe skalowalności</span><span class="sxs-lookup"><span data-stu-id="87de6-170">Scalability Targets</span></span> |[<span data-ttu-id="87de6-171">Masz dużą liczbę klientów uzyskujących dostęp do pojedynczego obiektu równocześnie?</span><span class="sxs-lookup"><span data-stu-id="87de6-171">Do you have a large number of clients accessing a single object concurrently?</span></span>](#subheading46) |
| &nbsp; | <span data-ttu-id="87de6-172">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-172">Blobs</span></span> |<span data-ttu-id="87de6-173">Wartości docelowe skalowalności</span><span class="sxs-lookup"><span data-stu-id="87de6-173">Scalability Targets</span></span> |[<span data-ttu-id="87de6-174">Aplikacja przebywa w celu skalowalność przepustowości lub operacji dla pojedynczego obiektu blob?</span><span class="sxs-lookup"><span data-stu-id="87de6-174">Is your application staying within the bandwidth or operations scalability target for a single blob?</span></span>](#subheading16) |
| &nbsp; | <span data-ttu-id="87de6-175">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-175">Blobs</span></span> |<span data-ttu-id="87de6-176">Kopiowanie obiektów blob</span><span class="sxs-lookup"><span data-stu-id="87de6-176">Copying Blobs</span></span> |[<span data-ttu-id="87de6-177">Czy kopiowanie blob wydajne?</span><span class="sxs-lookup"><span data-stu-id="87de6-177">Are you copying blobs in an efficient manner?</span></span>](#subheading17) |
| &nbsp; | <span data-ttu-id="87de6-178">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-178">Blobs</span></span> |<span data-ttu-id="87de6-179">Kopiowanie obiektów blob</span><span class="sxs-lookup"><span data-stu-id="87de6-179">Copying Blobs</span></span> |[<span data-ttu-id="87de6-180">Używasz narzędzia AzCopy do kopiowania zbiorczego obiektów blob?</span><span class="sxs-lookup"><span data-stu-id="87de6-180">Are you using AzCopy for bulk copies of blobs?</span></span>](#subheading18) |
| &nbsp; | <span data-ttu-id="87de6-181">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-181">Blobs</span></span> |<span data-ttu-id="87de6-182">Kopiowanie obiektów blob</span><span class="sxs-lookup"><span data-stu-id="87de6-182">Copying Blobs</span></span> |[<span data-ttu-id="87de6-183">Import/Eksport Azure jest używany do transferowania dużych woluminów danych?</span><span class="sxs-lookup"><span data-stu-id="87de6-183">Are you using Azure Import/Export to transfer very large volumes of data?</span></span>](#subheading19) |
| &nbsp; | <span data-ttu-id="87de6-184">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-184">Blobs</span></span> |<span data-ttu-id="87de6-185">Używanie metadanych</span><span class="sxs-lookup"><span data-stu-id="87de6-185">Use Metadata</span></span> |[<span data-ttu-id="87de6-186">Są przechowywania często używanych metadane dotyczące obiektów blob w ich metadanych?</span><span class="sxs-lookup"><span data-stu-id="87de6-186">Are you storing frequently used metadata about blobs in their metadata?</span></span>](#subheading20) |
| &nbsp; | <span data-ttu-id="87de6-187">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-187">Blobs</span></span> |<span data-ttu-id="87de6-188">Przekazywanie Fast</span><span class="sxs-lookup"><span data-stu-id="87de6-188">Uploading Fast</span></span> |[<span data-ttu-id="87de6-189">Podczas próby przekazania szybko jednego obiektu blob, przekazujesz bloki równocześnie?</span><span class="sxs-lookup"><span data-stu-id="87de6-189">When trying to upload one blob quickly, are you uploading blocks in parallel?</span></span>](#subheading21) |
| &nbsp; | <span data-ttu-id="87de6-190">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-190">Blobs</span></span> |<span data-ttu-id="87de6-191">Przekazywanie Fast</span><span class="sxs-lookup"><span data-stu-id="87de6-191">Uploading Fast</span></span> |[<span data-ttu-id="87de6-192">Podczas próby szybko przekazać wiele obiektów blob, przekazujesz obiekty BLOB równocześnie?</span><span class="sxs-lookup"><span data-stu-id="87de6-192">When trying to upload many blobs quickly, are you uploading blobs in parallel?</span></span>](#subheading22) |
| &nbsp; | <span data-ttu-id="87de6-193">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-193">Blobs</span></span> |<span data-ttu-id="87de6-194">Popraw typu obiektu Blob</span><span class="sxs-lookup"><span data-stu-id="87de6-194">Correct Blob Type</span></span> |[<span data-ttu-id="87de6-195">Używasz stronicowych obiektów blob lub blokowych obiektów blob, gdy jest to potrzebne?</span><span class="sxs-lookup"><span data-stu-id="87de6-195">Are you using page blobs or block blobs when appropriate?</span></span>](#subheading23) |
| &nbsp; | <span data-ttu-id="87de6-196">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-196">Tables</span></span> |<span data-ttu-id="87de6-197">Wartości docelowe skalowalności</span><span class="sxs-lookup"><span data-stu-id="87de6-197">Scalability Targets</span></span> |[<span data-ttu-id="87de6-198">Są zbliża się wartości docelowe skalowalności dla jednostek na sekundę?</span><span class="sxs-lookup"><span data-stu-id="87de6-198">Are you approaching the scalability targets for entities per second?</span></span>](#subheading24) |
| &nbsp; | <span data-ttu-id="87de6-199">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-199">Tables</span></span> |<span data-ttu-id="87de6-200">Konfiguracja</span><span class="sxs-lookup"><span data-stu-id="87de6-200">Configuration</span></span> |[<span data-ttu-id="87de6-201">Używasz JSON dla żądań tabeli?</span><span class="sxs-lookup"><span data-stu-id="87de6-201">Are you using JSON for your table requests?</span></span>](#subheading25) |
| &nbsp; | <span data-ttu-id="87de6-202">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-202">Tables</span></span> |<span data-ttu-id="87de6-203">Konfiguracja</span><span class="sxs-lookup"><span data-stu-id="87de6-203">Configuration</span></span> |[<span data-ttu-id="87de6-204">Możesz wyłączyć Nagle'a poprawić wydajność żądań małych?</span><span class="sxs-lookup"><span data-stu-id="87de6-204">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading26) |
| &nbsp; | <span data-ttu-id="87de6-205">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-205">Tables</span></span> |<span data-ttu-id="87de6-206">Tabele i partycji</span><span class="sxs-lookup"><span data-stu-id="87de6-206">Tables and Partitions</span></span> |[<span data-ttu-id="87de6-207">Ma należy prawidłowo podzielona na partycje danych?</span><span class="sxs-lookup"><span data-stu-id="87de6-207">Have you properly partitioned your data?</span></span>](#subheading27) |
| &nbsp; | <span data-ttu-id="87de6-208">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-208">Tables</span></span> |<span data-ttu-id="87de6-209">Partycje dynamicznej</span><span class="sxs-lookup"><span data-stu-id="87de6-209">Hot Partitions</span></span> |[<span data-ttu-id="87de6-210">Są jest unikanie tylko Dołącz i tylko dołączy wzorców?</span><span class="sxs-lookup"><span data-stu-id="87de6-210">Are you avoiding append-only and prepend-only patterns?</span></span>](#subheading28) |
| &nbsp; | <span data-ttu-id="87de6-211">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-211">Tables</span></span> |<span data-ttu-id="87de6-212">Partycje dynamicznej</span><span class="sxs-lookup"><span data-stu-id="87de6-212">Hot Partitions</span></span> |[<span data-ttu-id="87de6-213">Operacji wstawiania/aktualizacji są rozkładane między wiele partycji?</span><span class="sxs-lookup"><span data-stu-id="87de6-213">Are your inserts/updates spread across many partitions?</span></span>](#subheading29) |
| &nbsp; | <span data-ttu-id="87de6-214">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-214">Tables</span></span> |<span data-ttu-id="87de6-215">Zakres kwerendy</span><span class="sxs-lookup"><span data-stu-id="87de6-215">Query Scope</span></span> |[<span data-ttu-id="87de6-216">Możesz zaprojektowany schemat punktu zapytania do użycia w większości przypadków i zapytania tabeli, aby być używane rzadko?</span><span class="sxs-lookup"><span data-stu-id="87de6-216">Have you designed your schema to allow for point queries to be used in most cases, and table queries to be used sparingly?</span></span>](#subheading30) |
| &nbsp; | <span data-ttu-id="87de6-217">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-217">Tables</span></span> |<span data-ttu-id="87de6-218">Gęstość zapytania</span><span class="sxs-lookup"><span data-stu-id="87de6-218">Query Density</span></span> |[<span data-ttu-id="87de6-219">Czy skanowania zazwyczaj tylko zapytania i zwracanie wszystkich wierszy, które będą korzystać z aplikacji?</span><span class="sxs-lookup"><span data-stu-id="87de6-219">Do your queries typically only scan and return rows that your application will use?</span></span>](#subheading31) |
| &nbsp; | <span data-ttu-id="87de6-220">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-220">Tables</span></span> |<span data-ttu-id="87de6-221">Ograniczenie zwrócone dane</span><span class="sxs-lookup"><span data-stu-id="87de6-221">Limiting Returned Data</span></span> |[<span data-ttu-id="87de6-222">Używasz filtrowanie w celu uniknięcia zwracających jednostki, które nie są potrzebne?</span><span class="sxs-lookup"><span data-stu-id="87de6-222">Are you using filtering to avoid returning entities that are not needed?</span></span>](#subheading32) |
| &nbsp; | <span data-ttu-id="87de6-223">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-223">Tables</span></span> |<span data-ttu-id="87de6-224">Ograniczenie zwrócone dane</span><span class="sxs-lookup"><span data-stu-id="87de6-224">Limiting Returned Data</span></span> |[<span data-ttu-id="87de6-225">Aby uniknąć zwracanie właściwości, które nie są wymagane jest używany projekcji?</span><span class="sxs-lookup"><span data-stu-id="87de6-225">Are you using projection to avoid returning properties that are not needed?</span></span>](#subheading33) |
| &nbsp; | <span data-ttu-id="87de6-226">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-226">Tables</span></span> |<span data-ttu-id="87de6-227">Denormalization</span><span class="sxs-lookup"><span data-stu-id="87de6-227">Denormalization</span></span> |[<span data-ttu-id="87de6-228">Dane mają nieznormalizowane tak, aby uniknąć nieefektywne zapytania lub wiele żądań odczytu podczas próby pobrania danych?</span><span class="sxs-lookup"><span data-stu-id="87de6-228">Have you denormalized your data such that you avoid inefficient queries or multiple read requests when trying to get data?</span></span>](#subheading34) |
| &nbsp; | <span data-ttu-id="87de6-229">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-229">Tables</span></span> |<span data-ttu-id="87de6-230">Wstawiania/aktualizowania/usuwania</span><span class="sxs-lookup"><span data-stu-id="87de6-230">Insert/Update/Delete</span></span> |[<span data-ttu-id="87de6-231">Czy można przetwarzanie wsadowe żądań wymagających transakcyjnej lub może odbywać się w tym samym czasie, aby zmniejszyć przechodzenia?</span><span class="sxs-lookup"><span data-stu-id="87de6-231">Are you batching requests that need to be transactional or can be done at the same time to reduce round-trips?</span></span>](#subheading35) |
| &nbsp; | <span data-ttu-id="87de6-232">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-232">Tables</span></span> |<span data-ttu-id="87de6-233">Wstawiania/aktualizowania/usuwania</span><span class="sxs-lookup"><span data-stu-id="87de6-233">Insert/Update/Delete</span></span> |[<span data-ttu-id="87de6-234">Jest unikanie pobierania jednostki tylko w celu określenia, czy do wywołania, insert lub update?</span><span class="sxs-lookup"><span data-stu-id="87de6-234">Are you avoiding retrieving an entity just to determine whether to call insert or update?</span></span>](#subheading36) |
| &nbsp; | <span data-ttu-id="87de6-235">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-235">Tables</span></span> |<span data-ttu-id="87de6-236">Wstawiania/aktualizowania/usuwania</span><span class="sxs-lookup"><span data-stu-id="87de6-236">Insert/Update/Delete</span></span> |[<span data-ttu-id="87de6-237">Bierzesz pod uwagę przechowywanie serii danych, które często mają zostać pobrane ze sobą w pojedynczej jednostki jako właściwości zamiast wiele jednostek?</span><span class="sxs-lookup"><span data-stu-id="87de6-237">Have you considered storing series of data that will frequently be retrieved together in a single entity as properties instead of multiple entities?</span></span>](#subheading37) |
| &nbsp; | <span data-ttu-id="87de6-238">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-238">Tables</span></span> |<span data-ttu-id="87de6-239">Wstawiania/aktualizowania/usuwania</span><span class="sxs-lookup"><span data-stu-id="87de6-239">Insert/Update/Delete</span></span> |[<span data-ttu-id="87de6-240">Dla jednostek, które będą zawsze pobierane ze sobą i mogą być zapisywane w partiach (np. czasu serii danych) bierzesz pod uwagę zamiast tabel za pomocą obiektów blob?</span><span class="sxs-lookup"><span data-stu-id="87de6-240">For entities that will always be retrieved together and can be written in batches (e.g. time series data), have you considered using blobs instead of tables?</span></span>](#subheading38) |
| &nbsp; | <span data-ttu-id="87de6-241">Kolejki</span><span class="sxs-lookup"><span data-stu-id="87de6-241">Queues</span></span> |<span data-ttu-id="87de6-242">Wartości docelowe skalowalności</span><span class="sxs-lookup"><span data-stu-id="87de6-242">Scalability Targets</span></span> |[<span data-ttu-id="87de6-243">Są zbliża się wartości docelowe skalowalności komunikatów na sekundę?</span><span class="sxs-lookup"><span data-stu-id="87de6-243">Are you approaching the scalability targets for messages per second?</span></span>](#subheading39) |
| &nbsp; | <span data-ttu-id="87de6-244">Kolejki</span><span class="sxs-lookup"><span data-stu-id="87de6-244">Queues</span></span> |<span data-ttu-id="87de6-245">Konfiguracja</span><span class="sxs-lookup"><span data-stu-id="87de6-245">Configuration</span></span> |[<span data-ttu-id="87de6-246">Możesz wyłączyć Nagle'a poprawić wydajność żądań małych?</span><span class="sxs-lookup"><span data-stu-id="87de6-246">Have you turned Nagle off to improve the performance of small requests?</span></span>](#subheading40) |
| &nbsp; | <span data-ttu-id="87de6-247">Kolejki</span><span class="sxs-lookup"><span data-stu-id="87de6-247">Queues</span></span> |<span data-ttu-id="87de6-248">Rozmiar komunikatu</span><span class="sxs-lookup"><span data-stu-id="87de6-248">Message Size</span></span> |[<span data-ttu-id="87de6-249">Czy Twoje compact wiadomości do zwiększenia wydajności kolejki?</span><span class="sxs-lookup"><span data-stu-id="87de6-249">Are your messages compact to improve the performance of the queue?</span></span>](#subheading41) |
| &nbsp; | <span data-ttu-id="87de6-250">Kolejki</span><span class="sxs-lookup"><span data-stu-id="87de6-250">Queues</span></span> |<span data-ttu-id="87de6-251">Zbiorcze pobieranie</span><span class="sxs-lookup"><span data-stu-id="87de6-251">Bulk Retrieve</span></span> |[<span data-ttu-id="87de6-252">Czy pobieranych wiele komunikatów w ramach jednej operacji "Get"?</span><span class="sxs-lookup"><span data-stu-id="87de6-252">Are you retrieving multiple messages in a single "Get" operation?</span></span>](#subheading42) |
| &nbsp; | <span data-ttu-id="87de6-253">Kolejki</span><span class="sxs-lookup"><span data-stu-id="87de6-253">Queues</span></span> |<span data-ttu-id="87de6-254">Częstotliwość sondowania</span><span class="sxs-lookup"><span data-stu-id="87de6-254">Polling Frequency</span></span> |[<span data-ttu-id="87de6-255">Są możesz sondowania wystarczająco często, aby zmniejszyć opóźnienia postrzegana aplikacji?</span><span class="sxs-lookup"><span data-stu-id="87de6-255">Are you polling frequently enough to reduce the perceived latency of your application?</span></span>](#subheading43) |
| &nbsp; | <span data-ttu-id="87de6-256">Kolejki</span><span class="sxs-lookup"><span data-stu-id="87de6-256">Queues</span></span> |<span data-ttu-id="87de6-257">Komunikat dotyczący aktualizacji</span><span class="sxs-lookup"><span data-stu-id="87de6-257">Update Message</span></span> |[<span data-ttu-id="87de6-258">UpdateMessage jest używany do przechowywania postęp w przetwarzanie komunikatów, co pozwala uniknąć konieczności ponownie przetworzyć cały komunikat, jeśli wystąpi błąd?</span><span class="sxs-lookup"><span data-stu-id="87de6-258">Are you using UpdateMessage to store progress in processing messages, avoiding having to reprocess the entire message if an error occurs?</span></span>](#subheading44) |
| &nbsp; | <span data-ttu-id="87de6-259">Kolejki</span><span class="sxs-lookup"><span data-stu-id="87de6-259">Queues</span></span> |<span data-ttu-id="87de6-260">Architektura</span><span class="sxs-lookup"><span data-stu-id="87de6-260">Architecture</span></span> |[<span data-ttu-id="87de6-261">Kolejki jest używany do całej aplikacji skalowalność za utrzymywanie obciążeń długotrwałe poza ścieżkę krytyczną i następnie skalować niezależnie?</span><span class="sxs-lookup"><span data-stu-id="87de6-261">Are you using queues to make your entire application more scalable by keeping long-running workloads out of the critical path and scale then independently?</span></span>](#subheading45) |

## <span data-ttu-id="87de6-262"><a name="allservices"></a>Wszystkie usługi</span><span class="sxs-lookup"><span data-stu-id="87de6-262"><a name="allservices"></a>All Services</span></span>
<span data-ttu-id="87de6-263">Ta sekcja zawiera sprawdzonych rozwiązań, które mają zastosowanie do użycia usług Azure Storage (obiekty BLOB, tabel, kolejek lub plików).</span><span class="sxs-lookup"><span data-stu-id="87de6-263">This section lists proven practices that are applicable to the use of any of the Azure Storage services (blobs, tables, queues, or files).</span></span>  

### <span data-ttu-id="87de6-264"><a name="subheading1"></a>Wartości docelowe skalowalności</span><span class="sxs-lookup"><span data-stu-id="87de6-264"><a name="subheading1"></a>Scalability Targets</span></span>
<span data-ttu-id="87de6-265">Każda z usług magazynu Azure ma wartości docelowe skalowalności pojemność (GB), szybkości transakcji i przepustowości.</span><span class="sxs-lookup"><span data-stu-id="87de6-265">Each of the Azure Storage services has scalability targets for capacity (GB), transaction rate, and bandwidth.</span></span> <span data-ttu-id="87de6-266">Jeśli aplikacja zbliża się lub przekroczy wartości docelowe skalowalności, napotkać opóźnienia zwiększona transakcji lub ograniczenia przepustowości.</span><span class="sxs-lookup"><span data-stu-id="87de6-266">If your application approaches or exceeds any of the scalability targets, it may encounter increased transaction latencies or throttling.</span></span> <span data-ttu-id="87de6-267">Gdy usługa Magazyn ogranicza aplikacji, usługi rozpoczyna się do zwrócenia "503 Serwer jest zajęty" lub "500 limit czasu operacji" kody błędów dla niektórych transakcji magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-267">When a Storage service throttles your application, the service begins to return "503 Server busy" or "500 Operation timeout" error codes for some storage transactions.</span></span> <span data-ttu-id="87de6-268">W tej sekcji omówiono zarówno ogólne podejście do pracy nad cele dotyczące skalowalności przepustowości i wartości docelowe skalowalności w szczególności.</span><span class="sxs-lookup"><span data-stu-id="87de6-268">This section discusses both the general approach to dealing with scalability targets and bandwidth scalability targets in particular.</span></span> <span data-ttu-id="87de6-269">Kolejnych sekcjach, które zajmują się usługi magazynu omówiono w nim wartości docelowe skalowalności w kontekście tej określonej usługi:</span><span class="sxs-lookup"><span data-stu-id="87de6-269">Later sections that deal with individual storage services discuss scalability targets in the context of that specific service:</span></span>  

* [<span data-ttu-id="87de6-270">Obiekt blob przepustowość i żądań na sekundę</span><span class="sxs-lookup"><span data-stu-id="87de6-270">Blob bandwidth and requests per second</span></span>](#subheading16)
* [<span data-ttu-id="87de6-271">Tabela jednostek na sekundę</span><span class="sxs-lookup"><span data-stu-id="87de6-271">Table entities per second</span></span>](#subheading24)
* [<span data-ttu-id="87de6-272">Wiadomości w kolejce na sekundę</span><span class="sxs-lookup"><span data-stu-id="87de6-272">Queue messages per second</span></span>](#subheading39)  

#### <span data-ttu-id="87de6-273"><a name="sub1bandwidth"></a>Cel skalowalność przepustowości dla wszystkich usług</span><span class="sxs-lookup"><span data-stu-id="87de6-273"><a name="sub1bandwidth"></a>Bandwidth Scalability Target for All Services</span></span>
<span data-ttu-id="87de6-274">Zapisywanie obiektów docelowych przepustowości w Stanach Zjednoczonych dla konta magazynu geograficznie nadmiarowego (GRS) są 10 GB/s na sekundę (GB/s) transfer danych przychodzących (dane wysyłane do konta magazynu) i 20 GB/s dla transfer danych wychodzących (dane przesyłane z konta magazynu).</span><span class="sxs-lookup"><span data-stu-id="87de6-274">At the time of writing, the bandwidth targets in the US for a geo-redundant storage (GRS) account are 10 gigabits per second (Gbps) for ingress (data sent to the storage account) and 20 Gbps for egress (data sent from the storage account).</span></span> <span data-ttu-id="87de6-275">Konto magazyn lokalnie nadmiarowy (LRS), limity są wyższe — 20 GB/s dla przychodzące i 30 GB/s za wyjście.</span><span class="sxs-lookup"><span data-stu-id="87de6-275">For a locally redundant storage (LRS) account, the limits are higher – 20 Gbps for ingress and 30 Gbps for egress.</span></span>  <span data-ttu-id="87de6-276">Limity przepustowości międzynarodowych może być niższa i można znaleźć w naszych [strony elementy docelowe skalowalności](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span><span class="sxs-lookup"><span data-stu-id="87de6-276">International bandwidth limits may be lower and can be found on our [scalability targets page](http://msdn.microsoft.com/library/azure/dn249410.aspx).</span></span>  <span data-ttu-id="87de6-277">Aby uzyskać więcej informacji na temat opcji nadmiarowość magazynu, zobacz linki w [przydatne zasoby](#sub1useful) poniżej.</span><span class="sxs-lookup"><span data-stu-id="87de6-277">For more information on the storage redundancy options, see the links in [Useful Resources](#sub1useful) below.</span></span>  

#### <a name="what-to-do-when-approaching-a-scalability-target"></a><span data-ttu-id="87de6-278">Co zrobić, gdy zbliża się docelowy skalowalności</span><span class="sxs-lookup"><span data-stu-id="87de6-278">What to do when approaching a scalability target</span></span>
<span data-ttu-id="87de6-279">Jeśli aplikacja zbliża się do wartości docelowe skalowalności konta pojedynczy magazyn, należy wziąć pod uwagę przyjmowanie jedną z następujących metod:</span><span class="sxs-lookup"><span data-stu-id="87de6-279">If your application is approaching the scalability targets for a single storage account, consider adopting one of the following approaches:</span></span>  

* <span data-ttu-id="87de6-280">Rozważenia obciążeniem, które powoduje, że aplikacja podejścia lub przekraczają docelowy skalowalności.</span><span class="sxs-lookup"><span data-stu-id="87de6-280">Reconsider the workload that causes your application to approach or exceed the scalability target.</span></span> <span data-ttu-id="87de6-281">Można projektować, jest inaczej użycie mniejszej przepustowości lub pojemności lub mniejszą liczbą transakcji?</span><span class="sxs-lookup"><span data-stu-id="87de6-281">Can you design it differently to use less bandwidth or capacity, or fewer transactions?</span></span>
* <span data-ttu-id="87de6-282">Jeśli aplikacja może przekraczać jedną z wartości docelowe skalowalności, należy utworzyć wiele kont magazynu i partycji danych aplikacji w wielu kont magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-282">If an application must exceed one of the scalability targets, you should create multiple storage accounts and partition your application data across those multiple storage accounts.</span></span> <span data-ttu-id="87de6-283">Jeśli używasz tego wzorca, następnie należy koniecznie Utwórz projekt swojej aplikacji tak, aby dodać więcej kont magazynu w przyszłości do równoważenia obciążenia.</span><span class="sxs-lookup"><span data-stu-id="87de6-283">If you use this pattern, then be sure to design your application so that you can add more storage accounts in the future for load balancing.</span></span> <span data-ttu-id="87de6-284">W czasie zapisywania każdej subskrypcji platformy Azure może mieć maksymalnie 100 kont magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-284">At time of writing, each Azure subscription can have up to 100 storage accounts.</span></span>  <span data-ttu-id="87de6-285">Konta magazynu ma także żadnego kosztu innych niż użycie pod względem przechowywanych danych, transakcji wykonanych lub przesyłane dane.</span><span class="sxs-lookup"><span data-stu-id="87de6-285">Storage accounts also have no cost other than your usage in terms of data stored, transactions made, or data transferred.</span></span>
* <span data-ttu-id="87de6-286">Jeśli aplikacja trafienia cele przepustowości, należy wziąć pod uwagę kompresowania danych na komputerze klienckim, aby ograniczyć przepustowość wymagana do wysyłania danych do usługi magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-286">If your application hits the bandwidth targets, consider compressing data in the client to reduce the bandwidth required to send the data to the storage service.</span></span>  <span data-ttu-id="87de6-287">Należy pamiętać, że może to oszczędzić przepustowość i zwiększyć wydajność sieci, mogą mieć jednak również pewne negatywnego wpływu.</span><span class="sxs-lookup"><span data-stu-id="87de6-287">Note that while this may save bandwidth and improve network performance, it can also have some negative impacts.</span></span>  <span data-ttu-id="87de6-288">Należy ocenić wpływ na wydajność to ze względu na wymagania dodatkowego przetwarzania kompresji i dekompresji danych w kliencie.</span><span class="sxs-lookup"><span data-stu-id="87de6-288">You should evaluate the performance impact of this due to the additional processing requirements for compressing and decompressing data in the client.</span></span> <span data-ttu-id="87de6-289">Ponadto przechowywania skompresowanych danych może utrudnić więcej do rozwiązywania problemów, ponieważ może to być trudniejsze do wyświetlenia przechowywanych danych przy użyciu standardowych narzędzi.</span><span class="sxs-lookup"><span data-stu-id="87de6-289">In addition, storing compressed data can make it more difficult to troubleshoot issues since it could be more difficult to view stored data using standard tools.</span></span>
* <span data-ttu-id="87de6-290">Jeśli aplikacja trafienia wartości docelowe skalowalności, upewnij się, że używasz wykładniczego wycofywania ponownych prób (zobacz [ponownych prób](#subheading14)).</span><span class="sxs-lookup"><span data-stu-id="87de6-290">If your application hits the scalability targets, then ensure that you are using an exponential backoff for retries (see [Retries](#subheading14)).</span></span>  <span data-ttu-id="87de6-291">Warto upewnij się, że nigdy nie próbują wartości docelowe skalowalności (przy użyciu jednej z metod powyżej), ale to zagwarantować, że aplikacja nie tylko ponawiać szybko, co gorsza ograniczenie.</span><span class="sxs-lookup"><span data-stu-id="87de6-291">It's better to make sure you never approach the scalability targets (by using one of the above methods), but this will ensure your application won't just keep retrying rapidly, making the throttling worse.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="87de6-292">Przydatne zasoby</span><span class="sxs-lookup"><span data-stu-id="87de6-292">Useful Resources</span></span>
<span data-ttu-id="87de6-293">Poniższe linki udostępniają dodatkowe szczegóły na wartości docelowe skalowalności:</span><span class="sxs-lookup"><span data-stu-id="87de6-293">The following links provide additional detail on scalability targets:</span></span>

* <span data-ttu-id="87de6-294">Zobacz [cele dotyczące wydajności i skalowalności magazynu Azure](storage-scalability-targets.md) informacji o wartości docelowe skalowalności.</span><span class="sxs-lookup"><span data-stu-id="87de6-294">See [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md) for information about scalability targets.</span></span>
* <span data-ttu-id="87de6-295">Zobacz [replikacja usługi Azure Storage](storage-redundancy.md) i wpis w blogu [opcje nadmiarowość magazynu Azure i dostęp do odczytu z magazynu geograficznie nadmiarowego magazynu](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) informacji o opcjach nadmiarowość magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-295">See [Azure Storage replication](storage-redundancy.md) and the blog post [Azure Storage Redundancy Options and Read Access Geo Redundant Storage](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/11/introducing-read-access-geo-replicated-storage-ra-grs-for-windows-azure-storage.aspx) for information about storage redundancy options.</span></span>
* <span data-ttu-id="87de6-296">Aby uzyskać aktualne informacje o cenach dla usług Azure, zobacz [cennik platformy Azure](https://azure.microsoft.com/pricing/overview/).</span><span class="sxs-lookup"><span data-stu-id="87de6-296">For current information about pricing for Azure services, see [Azure pricing](https://azure.microsoft.com/pricing/overview/).</span></span>  

### <span data-ttu-id="87de6-297"><a name="subheading47"></a>Konwencja nazewnictwa partycji</span><span class="sxs-lookup"><span data-stu-id="87de6-297"><a name="subheading47"></a>Partition Naming Convention</span></span>
<span data-ttu-id="87de6-298">Usługa Azure Storage wykorzystuje schemat partycjonowania opartej na zakresie równowagi skala i wielkość obciążenia systemu.</span><span class="sxs-lookup"><span data-stu-id="87de6-298">Azure Storage uses a range-based partitioning scheme to scale and load balance the system.</span></span> <span data-ttu-id="87de6-299">Klucz partycji służy do partycji, które dane do zakresów i tych zakresów są równoważeniem obciążenia w systemie.</span><span class="sxs-lookup"><span data-stu-id="87de6-299">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="87de6-300">Oznacza to, że konwencji nazewnictwa, takich jak leksykalne porządkowanie (np. msftpayroll, msftperformance, msftemployees itp.) lub przy użyciu sygnatury czasowe (log20160101, log20160102, log20160102 itp.) będą spowodować w przyszłości zmianę partycji umieszczone potencjalnie znajdujących się na tym samym Serwer partycji, dopóki operacja z równoważeniem obciążenia dzieli je na mniejsze zakresów.</span><span class="sxs-lookup"><span data-stu-id="87de6-300">This means naming conventions such as lexical ordering (e.g. msftpayroll, msftperformance, msftemployees, etc) or using time-stamps (log20160101, log20160102, log20160102, etc) will lend itself to the partitions being potentially co-located on the same partition server, until a load balancing operation splits them out into smaller ranges.</span></span> <span data-ttu-id="87de6-301">Na przykład wszystkie obiekty BLOB w kontenerze, mogą być udostępniane przez jeden serwer, dopóki obciążenia na te obiekty BLOB wymaga dalszych ponowne równoważenie zakresów partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-301">For example, all blobs within a container can be served by a single server until the load on these blobs requires further rebalancing of the partition ranges.</span></span> <span data-ttu-id="87de6-302">Podobnie grupa kont lekkim załadowany z ich nazw, w kolejności leksykalne może być obsługiwana przez pojedynczego serwera do obciążenia na jednym lub wymagają wszystkie te konta można podzielić na wielu serwerach partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-302">Similarly, a group of lightly loaded accounts with their names arranged in lexical order may be served by a single server until the load on one or all of these accounts require them to be split across multiple partitions servers.</span></span> <span data-ttu-id="87de6-303">Każdej operacji równoważenia obciążenia może mieć wpływ na opóźnienie magazynu wywołań podczas operacji.</span><span class="sxs-lookup"><span data-stu-id="87de6-303">Each load balancing operation may impact the latency of storage calls during the operation.</span></span> <span data-ttu-id="87de6-304">Możliwość systemu obsługi nagłym serii ruchu do partycji jest ograniczona skalowalność serwera jednej partycji do momentu operacji funkcji równoważenia obciążenia w kopnięć i rebalances zakresem kluczy partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-304">The system's ability to handle a sudden burst of traffic to a partition is limited by the scalability of a single partition server until the load balancing operation kicks-in and rebalances the partition key range.</span></span>  

<span data-ttu-id="87de6-305">Możesz wykonać najważniejsze wskazówki, aby zmniejszyć częstotliwość takich operacji.</span><span class="sxs-lookup"><span data-stu-id="87de6-305">You can follow some best practices to reduce the frequency of such operations.</span></span>  

* <span data-ttu-id="87de6-306">Sprawdź, czy używane w przypadku kont, kontenerów, obiektów blob, tabel i kolejek, ściśle konwencji nazewnictwa.</span><span class="sxs-lookup"><span data-stu-id="87de6-306">Examine the naming convention you use for accounts, containers, blobs, tables and queues, closely.</span></span> <span data-ttu-id="87de6-307">Należy rozważyć prefiksu nazwy kont z 3-cyfrowy skrót przy użyciu funkcji skrótu, który najlepiej odpowiada Twoim potrzebom.</span><span class="sxs-lookup"><span data-stu-id="87de6-307">Consider prefixing account names with a 3-digit hash using a hashing function that best suits your needs.</span></span>  
* <span data-ttu-id="87de6-308">Organizowanie danych za pomocą znacznika czasu lub identyfikatory numeryczne, masz upewnij się, że nie używasz wzorce ruchu tylko Dołącz (lub tylko dołączenie wartości).</span><span class="sxs-lookup"><span data-stu-id="87de6-308">If you organize your data using timestamps or numerical identifiers, you have to ensure you are not using an append-only (or prepend-only) traffic patterns.</span></span> <span data-ttu-id="87de6-309">Te wzorce nie są odpowiednie dla zakresu — na podstawie partycjonowania systemu i może prowadzić do całego ruchu, przechodząc do jednej partycji i efektywnie ograniczenie systemu z równoważenia obciążenia.</span><span class="sxs-lookup"><span data-stu-id="87de6-309">These patterns are not suitable for a range -based partitioning system, and could lead to all the traffic going to a single partition and limiting the system from effectively load balancing.</span></span> <span data-ttu-id="87de6-310">Na przykład jeśli masz codziennych operacji korzystających z obiektu blob z sygnaturą czasową takich jak RRRRMMDD cały ruch do tego codziennej pracy jest kierowany do jednego obiektu, który jest obsługiwany przez serwer z jedną partycją.</span><span class="sxs-lookup"><span data-stu-id="87de6-310">For instance, if you have daily operations that use a blob object with a timestamp such as yyyymmdd, then all the traffic for that daily operation is directed to a single object which is served by a single partition server.</span></span> <span data-ttu-id="87de6-311">Sprawdź czy dla obiekt blob limity dla każdej partycji limity potrzeb i Podziel tej operacji w wielu obiektów blob, jeśli to konieczne.</span><span class="sxs-lookup"><span data-stu-id="87de6-311">Look at whether the per blob limits and per partition limits meet your needs, and consider breaking this operation into multiple blobs if needed.</span></span> <span data-ttu-id="87de6-312">Podobnie jeśli czas serii danych są przechowywane w tabelach, wszystkie ruchu może być kierowany do ostatniego części klucza przestrzeni nazw.</span><span class="sxs-lookup"><span data-stu-id="87de6-312">Similarly, if you store time series data in your tables, all the traffic could be directed to the last part of the key namespace.</span></span> <span data-ttu-id="87de6-313">Jeśli musisz użyć sygnatury czasowe lub identyfikatory numeryczne, prefiks identyfikatora znakiem, 3-cyfrowy, lub w przypadku sygnatury czasowe prefiks część czasu, takich jak ssyyyymmdd sekund.</span><span class="sxs-lookup"><span data-stu-id="87de6-313">If you must use timestamps or numerical IDs, prefix the id with a 3-digit hash, or in the case of timestamps prefix the seconds part of the time such as ssyyyymmdd.</span></span> <span data-ttu-id="87de6-314">Jeśli wykonywane są regularnie wyświetlania i badania operacje, wybierz funkcję wyznaczania wartości skrótu, która powoduje ograniczenie liczby zapytań.</span><span class="sxs-lookup"><span data-stu-id="87de6-314">If listing and querying operations are routinely performed, choose a hashing function that will limit your number of queries.</span></span> <span data-ttu-id="87de6-315">W innych przypadkach może być wystarczający losowe prefiks.</span><span class="sxs-lookup"><span data-stu-id="87de6-315">In other cases, a random prefix may be sufficient.</span></span>  
* <span data-ttu-id="87de6-316">Dla dodatkowe informacje na temat schemat partycjonowania używane w magazynie Azure, przeczytaj dokument SOSP [tutaj](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span><span class="sxs-lookup"><span data-stu-id="87de6-316">For additional information on the partitioning scheme used in Azure Storage, read the SOSP paper [here](http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf).</span></span>

### <a name="networking"></a><span data-ttu-id="87de6-317">Sieć</span><span class="sxs-lookup"><span data-stu-id="87de6-317">Networking</span></span>
<span data-ttu-id="87de6-318">Gdy sprawy wywołania interfejsu API, często ograniczeń sieci fizycznej aplikacji mieć znaczący wpływ na wydajność.</span><span class="sxs-lookup"><span data-stu-id="87de6-318">While the API calls matter, often the physical network constraints of the application have a significant impact on performance.</span></span> <span data-ttu-id="87de6-319">Poniżej opisano niektóre ograniczenia, które użytkownicy mogą wystąpić.</span><span class="sxs-lookup"><span data-stu-id="87de6-319">The following describe some of limitations users may encounter.</span></span>  

#### <a name="client-network-capability"></a><span data-ttu-id="87de6-320">Możliwość sieci klienta</span><span class="sxs-lookup"><span data-stu-id="87de6-320">Client Network Capability</span></span>
##### <span data-ttu-id="87de6-321"><a name="subheading2"></a>Przepływność</span><span class="sxs-lookup"><span data-stu-id="87de6-321"><a name="subheading2"></a>Throughput</span></span>
<span data-ttu-id="87de6-322">Przepustowość problem jest często możliwości klienta.</span><span class="sxs-lookup"><span data-stu-id="87de6-322">For bandwidth, the problem is often the capabilities of the client.</span></span> <span data-ttu-id="87de6-323">Na przykład, gdy konto magazynu pojedynczego może obsłużyć 10 GB/s lub więcej transfer danych przychodzących (zobacz [wartości docelowe skalowalności przepustowości](#sub1bandwidth)), szybkość sieci w wystąpieniu roli procesu roboczego platformy Azure "Małe" obsługuje jedynie około 100 MB/s.</span><span class="sxs-lookup"><span data-stu-id="87de6-323">For example, while a single storage account can handle 10 Gbps or more of ingress (see [bandwidth scalability targets](#sub1bandwidth)), the network speed in a "Small" Azure Worker Role instance is only capable of approximately 100 Mbps.</span></span> <span data-ttu-id="87de6-324">Większy wystąpieniach platformy Azure ma kart sieciowych o większej pojemności, więc należy rozważyć użycie większych wystąpienia lub więcej maszyny Wirtualnej, jeśli potrzebujesz wyższe limity sieci z jednego komputera.</span><span class="sxs-lookup"><span data-stu-id="87de6-324">Larger Azure instances have NICs with greater capacity, so you should consider using a larger instance or more VM's if you need higher network limits from a single machine.</span></span> <span data-ttu-id="87de6-325">Jeśli uzyskujesz dostęp do usługi magazynu z aplikacji w lokalnym, a następnie ta zasada dotyczy: zrozumieć funkcje sieci urządzeń klienckich i łączność sieciową do lokalizacji magazynu Azure i albo poprawić je w razie potrzeby bądź projektowania programu Aplikacja do pracy w ich możliwości.</span><span class="sxs-lookup"><span data-stu-id="87de6-325">If you are accessing a Storage service from an on premises application, then the same rule applies: understand the network capabilities of the client device and the network connectivity to the Azure Storage location and either improve them as needed or design your application to work within their capabilities.</span></span>  

##### <span data-ttu-id="87de6-326"><a name="subheading3"></a>Jakość łącza</span><span class="sxs-lookup"><span data-stu-id="87de6-326"><a name="subheading3"></a>Link Quality</span></span>
<span data-ttu-id="87de6-327">Podobnie jak w przypadku bez użycia sieci należy pamiętać, że warunków sieciowych, co zapewnia błędów i utraty pakietów spowolni skuteczne przepływności.</span><span class="sxs-lookup"><span data-stu-id="87de6-327">As with any network usage, be aware that network conditions resulting in errors and packet loss will slow effective throughput.</span></span>  <span data-ttu-id="87de6-328">Za pomocą programu WireShark ani NetMon może pomóc w zdiagnozowaniu tego problemu.</span><span class="sxs-lookup"><span data-stu-id="87de6-328">Using WireShark or NetMon may help in diagnosing this issue.</span></span>  

##### <a name="useful-resources"></a><span data-ttu-id="87de6-329">Przydatne zasoby</span><span class="sxs-lookup"><span data-stu-id="87de6-329">Useful Resources</span></span>
<span data-ttu-id="87de6-330">Aby uzyskać więcej informacji na temat rozmiarów maszyn wirtualnych i przydzielonej przepustowości, zobacz [rozmiarów maszyn wirtualnych systemu Windows](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) lub [rozmiarów maszyn wirtualnych systemu Linux](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span><span class="sxs-lookup"><span data-stu-id="87de6-330">For more information about virtual machine sizes and allocated bandwidth, see [Windows VM sizes](../virtual-machines/windows/sizes.md?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) or [Linux VM sizes](../virtual-machines/linux/sizes.md?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).</span></span>  

#### <span data-ttu-id="87de6-331"><a name="subheading4"></a>Lokalizacja</span><span class="sxs-lookup"><span data-stu-id="87de6-331"><a name="subheading4"></a>Location</span></span>
<span data-ttu-id="87de6-332">W dowolnym środowisku rozproszonym umieszczenie klienta się w pobliżu serwer zapewnia najlepszą wydajność.</span><span class="sxs-lookup"><span data-stu-id="87de6-332">In any distributed environment, placing the client near to the server delivers in the best performance.</span></span> <span data-ttu-id="87de6-333">Do uzyskiwania dostępu do usługi Azure Storage o najniższym opóźnieniu, najlepiej lokalizacji klienta jest w tym samym regionie Azure.</span><span class="sxs-lookup"><span data-stu-id="87de6-333">For accessing Azure Storage with the lowest latency, the best location for your client is within the same Azure region.</span></span> <span data-ttu-id="87de6-334">Na przykład jeśli masz witryny sieci Web platformy Azure, która używa usługi Azure Storage, powinien oba te zlokalizować w pojedynczym regionie (na przykład nam zachodnie lub Azja południowo-wschodnia).</span><span class="sxs-lookup"><span data-stu-id="87de6-334">For example, if you have an Azure Web Site that uses Azure Storage, you should locate them both within a single region (for example, US West or Asia Southeast).</span></span> <span data-ttu-id="87de6-335">Zmniejsza to opóźnienie i koszt — w czasie zapisywania, jest wolne przepustowości w pojedynczym regionie.</span><span class="sxs-lookup"><span data-stu-id="87de6-335">This reduces the latency and the cost — at the time of writing, bandwidth usage within a single region is free.</span></span>  

<span data-ttu-id="87de6-336">Jeśli Twoje aplikacje nie znajdują się w obrębie platformy Azure (np. aplikacje urządzenia przenośnego lub lokalne usługi enterprise), następnie ponownie klienta umieszczenie konta magazynu w regionie się w pobliżu urządzenia, które będą miały dostęp, zazwyczaj zmniejsza opóźnienia.</span><span class="sxs-lookup"><span data-stu-id="87de6-336">If your client applications are not hosted within Azure (such as mobile device apps or on premises enterprise services), then again placing the storage account in a region near to the devices that will access it, will generally reduce latency.</span></span> <span data-ttu-id="87de6-337">Jeśli klienci szeroko są dystrybuowane (na przykład niektóre w Ameryce Północnej, a niektóre w Europie), a następnie należy rozważyć użycie wielu kont magazynu: jeden znajdujący się w Ameryce Północnej regionu i co Europejskich regionu.</span><span class="sxs-lookup"><span data-stu-id="87de6-337">If your clients are broadly distributed (for example, some in North America, and some in Europe), then you should consider using multiple storage accounts: one located in a North American region and one in a European region.</span></span> <span data-ttu-id="87de6-338">Dzięki temu można zmniejszyć opóźnienia dla użytkowników w obu regionach.</span><span class="sxs-lookup"><span data-stu-id="87de6-338">This will help to reduce latency for users in both regions.</span></span> <span data-ttu-id="87de6-339">Ta metoda jest zwykle łatwiej można wdrożenie, jeśli dane aplikacji są przechowywane są specyficzne dla poszczególnych użytkowników i nie wymaga replikowania danych między kontami magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-339">This approach is usually easier to implement if the data the application stores is specific to individual users, and does not require replicating data between storage accounts.</span></span>  <span data-ttu-id="87de6-340">Do szerokiej dystrybucji zawartości zaleca się CDN — zobacz następną sekcję, aby uzyskać więcej informacji.</span><span class="sxs-lookup"><span data-stu-id="87de6-340">For broad content distribution, a CDN is recommended – see the next section for more details.</span></span>  

### <span data-ttu-id="87de6-341"><a name="subheading5"></a>Dystrybucja zawartości</span><span class="sxs-lookup"><span data-stu-id="87de6-341"><a name="subheading5"></a>Content Distribution</span></span>
<span data-ttu-id="87de6-342">Czasami aplikacja musi obsługiwać tę samą zawartość do wielu użytkowników (np. produktu pokaz wideo użyty na stronie głównej witryny sieci Web), znajdujące się w tym samym lub wielu regionach.</span><span class="sxs-lookup"><span data-stu-id="87de6-342">Sometimes, an application needs to serve the same content to many users (e.g. a product demo video used in the home page of a website), located in either the same or multiple regions.</span></span> <span data-ttu-id="87de6-343">W tym scenariuszu należy użyć dostarczania sieci zawartości (CDN) takie jak usługi Azure CDN, a CDN użyje magazynu Azure jako źródła danych.</span><span class="sxs-lookup"><span data-stu-id="87de6-343">In this scenario, you should use a Content Delivery Network (CDN) such as Azure CDN, and the CDN would use Azure storage as the origin of the data.</span></span> <span data-ttu-id="87de6-344">W przeciwieństwie do konta usługi Azure Storage znajdujące się w pojedynczym regionie, który może dostarczyć zawartość z niskim opóźnieniem do innych regionów usługi Azure CDN używa serwerów w wielu centrach danych na całym świecie.</span><span class="sxs-lookup"><span data-stu-id="87de6-344">Unlike an Azure Storage account that exists in a single region and that cannot deliver content with low latency to other regions, Azure CDN uses servers in multiple data centers around the world.</span></span> <span data-ttu-id="87de6-345">Ponadto CDN zazwyczaj może obsługiwać znacznie wyższe limity wyjście niż konto jednego magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-345">Additionally, a CDN can typically support much higher egress limits than a single storage account.</span></span>  

<span data-ttu-id="87de6-346">Aby uzyskać więcej informacji na temat usługi Azure CDN, zobacz [Azure CDN](https://azure.microsoft.com/services/cdn/).</span><span class="sxs-lookup"><span data-stu-id="87de6-346">For more information about Azure CDN, see [Azure CDN](https://azure.microsoft.com/services/cdn/).</span></span>  

### <span data-ttu-id="87de6-347"><a name="subheading6"></a>Przy użyciu sygnatury dostępu Współdzielonego i mechanizmu CORS</span><span class="sxs-lookup"><span data-stu-id="87de6-347"><a name="subheading6"></a>Using SAS and CORS</span></span>
<span data-ttu-id="87de6-348">Gdy musisz autoryzować kodu, takich jak JavaScript w przeglądarce sieci web lub aplikacji telefonu komórkowego uzyskują dostęp do danych w usłudze Azure Storage, jednym z podejść jest użycie aplikacji w roli sieci web jako serwer proxy: urządzenie użytkownika jest uwierzytelniany w usłudze roli sieci web , który z kolei jest uwierzytelniany w usłudze usługi magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-348">When you need to authorize code such as JavaScript in a user's web browser or a mobile phone app to access data in Azure Storage, one approach is to use an application in web role as a proxy: the user's device authenticates with the web role, which in turn authenticates with the storage service.</span></span> <span data-ttu-id="87de6-349">W ten sposób można uniknąć, udostępnianie kluczy konta magazynu na urządzeniach niezabezpieczonych.</span><span class="sxs-lookup"><span data-stu-id="87de6-349">In this way, you can avoid exposing your storage account keys on insecure devices.</span></span> <span data-ttu-id="87de6-350">Jednak ten zostaje umieszczony duże obciążenie w roli sieci web ponieważ wszystkich danych przesyłanych między usług magazynu i urządzeń użytkownika musi przechodzić przez rolę sieci web.</span><span class="sxs-lookup"><span data-stu-id="87de6-350">However, this places a big overhead on the web role because all the data transferred between the user's device and the storage service must pass through the web role.</span></span> <span data-ttu-id="87de6-351">Możesz uniknąć używania roli sieci web jako serwer proxy usługi magazynu przy użyciu dostępu sygnatur dostępu Współdzielonego, czasami w połączeniu z nagłówkami współużytkowanie zasobów między źródłami (CORS).</span><span class="sxs-lookup"><span data-stu-id="87de6-351">You can avoid using a web role as a proxy for the storage service by using Shared Access Signatures (SAS), sometimes in conjunction with Cross-Origin Resource Sharing headers (CORS).</span></span> <span data-ttu-id="87de6-352">Przy użyciu sygnatury dostępu Współdzielonego, można zezwolić na urządzeniu użytkownika na wysyłanie żądań bezpośrednio do usługi magazynu za pomocą tokenu ograniczony dostęp.</span><span class="sxs-lookup"><span data-stu-id="87de6-352">Using SAS, you can allow your user's device to make requests directly to a storage service by means of a limited access token.</span></span> <span data-ttu-id="87de6-353">Na przykład jeśli użytkownik chce Przekaż zdjęcie do aplikacji, roli sieci web można wygenerować i wysłać do urządzenia użytkownika tokenu sygnatury dostępu Współdzielonego, który przyznaje uprawnienia do zapisu do konkretnego obiektu blob lub kontener dalej 30 minut (po którym token sygnatury dostępu Współdzielonego wygasa).</span><span class="sxs-lookup"><span data-stu-id="87de6-353">For example, if a user wants to upload a photo to your application, your web role can generate and send to the user's device a SAS token that grants permission to write to a specific blob or container for the next 30 minutes (after which the SAS token expires).</span></span>

<span data-ttu-id="87de6-354">Zwykle przeglądarce nie zezwala na JavaScript na stronie hostowanej przez witrynę sieci Web w jednej domenie wykonywanie określonych operacji, takich jak "PUT" do innej domeny.</span><span class="sxs-lookup"><span data-stu-id="87de6-354">Normally, a browser will not allow JavaScript in a page hosted by a website on one domain to perform specific operations such as a "PUT" to another domain.</span></span> <span data-ttu-id="87de6-355">Na przykład, jeśli host rolę sieci web w "contosomarketing.cloudapp.net" i chcesz użyć JavaScript po stronie klienta w celu przekazania obiektu blob na koncie magazynu na "contosoproducts.blob.core.windows.net," przeglądarki w "tego samego źródła policy" będzie zabraniać tej operacji.</span><span class="sxs-lookup"><span data-stu-id="87de6-355">For example, if you host a web role at "contosomarketing.cloudapp.net," and want to use client side JavaScript to upload a blob to your storage account at "contosoproducts.blob.core.windows.net," the browser's "same origin policy" will forbid this operation.</span></span> <span data-ttu-id="87de6-356">CORS jest funkcją przeglądarki, która pozwala domeny docelowej (w tym przypadku konta magazynu) na komunikowanie się w przeglądarce, że subskrypcja ufa żądań pochodzących z domeny źródłowej (w tym przypadku roli sieci web).</span><span class="sxs-lookup"><span data-stu-id="87de6-356">CORS is a browser feature that allows the target domain (in this case the storage account) to communicate to the browser that it trusts requests originating in the source domain (in this case the web role).</span></span>  

<span data-ttu-id="87de6-357">Oba te technologie mogą pomóc uniknąć niepotrzebnego obciążenia (i wąskich gardeł) w aplikacji sieci web.</span><span class="sxs-lookup"><span data-stu-id="87de6-357">Both of these technologies can help you avoid unnecessary load (and bottlenecks) on your web application.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="87de6-358">Przydatne zasoby</span><span class="sxs-lookup"><span data-stu-id="87de6-358">Useful Resources</span></span>
<span data-ttu-id="87de6-359">Aby uzyskać więcej informacji na temat sygnatury dostępu Współdzielonego, zobacz [sygnatury dostępu współdzielonego, część 1: opis modelu sygnatur dostępu Współdzielonego](storage-dotnet-shared-access-signature-part-1.md).</span><span class="sxs-lookup"><span data-stu-id="87de6-359">For more information about SAS, see [Shared Access Signatures, Part 1: Understanding the SAS Model](storage-dotnet-shared-access-signature-part-1.md).</span></span>  

<span data-ttu-id="87de6-360">Aby uzyskać więcej informacji na temat CORS, zobacz [udostępniania zasobów między źródłami (CORS) obsługę usług magazynu Azure](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span><span class="sxs-lookup"><span data-stu-id="87de6-360">For more information about CORS, see [Cross-Origin Resource Sharing (CORS) Support for the Azure Storage Services](http://msdn.microsoft.com/library/azure/dn535601.aspx).</span></span>  

### <a name="caching"></a><span data-ttu-id="87de6-361">Buforowanie</span><span class="sxs-lookup"><span data-stu-id="87de6-361">Caching</span></span>
#### <span data-ttu-id="87de6-362"><a name="subheading7"></a>Pobieranie danych</span><span class="sxs-lookup"><span data-stu-id="87de6-362"><a name="subheading7"></a>Getting Data</span></span>
<span data-ttu-id="87de6-363">Ogólnie rzecz biorąc pobieranie danych z usługą raz jest lepszym rozwiązaniem niż pobierania ich dwa razy.</span><span class="sxs-lookup"><span data-stu-id="87de6-363">In general, getting data from a service once is better than getting it twice.</span></span> <span data-ttu-id="87de6-364">Rozważmy przykładową aplikację sieci web MVC działającą w roli sieci web została już pobrana obiektu blob 50MB z usługi magazynowania jako zawartości dla użytkownika.</span><span class="sxs-lookup"><span data-stu-id="87de6-364">Consider the example of an MVC web application running in a web role that has already retrieved a 50MB blob from the storage service to serve as content to a user.</span></span> <span data-ttu-id="87de6-365">Aplikacja może następnie pobrać tego samego obiektu blob, za każdym razem, gdy użytkownik zażąda go lub go można buforować lokalnie na dysku i ponowne użycie pamięci podręcznej wersji kolejne żądania użytkowników.</span><span class="sxs-lookup"><span data-stu-id="87de6-365">The application could then retrieve that same blob every time a user requests it, or it could cache it locally to disk and reuse the cached version for subsequent user requests.</span></span> <span data-ttu-id="87de6-366">Ponadto gdy użytkownik zażąda danych aplikacji można problem UZYSKAĆ z nagłówkiem warunkowego czas modyfikacji, który będzie uniknąć pobierania całego obiektu blob, jeśli nie została zmodyfikowana.</span><span class="sxs-lookup"><span data-stu-id="87de6-366">Furthermore, whenever a user requests the data, the application could issue GET with a conditional header for modification time, which would avoid getting the entire blob if it hasn't been modified.</span></span> <span data-ttu-id="87de6-367">Można użyć tego samego wzorca do pracy z jednostek tabeli.</span><span class="sxs-lookup"><span data-stu-id="87de6-367">You can apply this same pattern to working with table entities.</span></span>  

<span data-ttu-id="87de6-368">W niektórych przypadkach może się okazać, że aplikacja może przyjmować obiektu blob pozostaje ważny przez krótki czas, po jej pobraniu i że w tym okresie aplikacji nie trzeba sprawdzić, czy został zmodyfikowany obiektu blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-368">In some cases, you may decide that your application can assume that the blob remains valid for a short period after retrieving it, and that during this period the application does not need to check if the blob was modified.</span></span>

<span data-ttu-id="87de6-369">Konfiguracja, wyszukiwania i inne dane, które są zawsze używane przez aplikację są obiekty doskonale nadające się do buforowania.</span><span class="sxs-lookup"><span data-stu-id="87de6-369">Configuration, lookup, and other data that are always used by the application are great candidates for caching.</span></span>  

<span data-ttu-id="87de6-370">Na przykład jak uzyskać właściwości obiektu blob, aby odnaleźć daty ostatniej modyfikacji, przy użyciu platformy .NET, zobacz [zestawu i pobrać właściwości i metadane](storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="87de6-370">For an example of how to get a blob's properties to discover the last modified date using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span> <span data-ttu-id="87de6-371">Aby uzyskać więcej informacji na temat warunkowego pliki do pobrania, zobacz [warunkowo Odśwież lokalną kopię obiektu Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span><span class="sxs-lookup"><span data-stu-id="87de6-371">For more information about conditional downloads, see [Conditionally Refresh a Local Copy of a Blob](http://msdn.microsoft.com/library/azure/dd179371.aspx).</span></span>  

#### <span data-ttu-id="87de6-372"><a name="subheading8"></a>Przekazywanie danych w partiach</span><span class="sxs-lookup"><span data-stu-id="87de6-372"><a name="subheading8"></a>Uploading Data in Batches</span></span>
<span data-ttu-id="87de6-373">W niektórych scenariuszach aplikacji agregowanie danych lokalnie i następnie okresowo przekaż go w partii, zamiast natychmiast przekazywania każdego elementu danych.</span><span class="sxs-lookup"><span data-stu-id="87de6-373">In some application scenarios, you can aggregate data locally, and then periodically upload it in a batch instead of uploading each piece of data immediately.</span></span> <span data-ttu-id="87de6-374">Na przykład aplikacja sieci web może przechowywać plik dziennika działań: aplikacji albo można przekazać szczegółowe informacje o każdym działaniu, ponieważ występuje jako element tabeli (co wymaga wielu operacji magazynu), lub można go zapisać szczegóły aktywności do lokalnego pliku dziennika, a następnie Okresowo należy przekazać wszystkie szczegóły aktywności jako rozdzielonym pliku do obiektu blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-374">For example, a web application might keep a log file of activities: the application could either upload details of every activity as it happens as a table entity (which requires many storage operations), or it could save activity details to a local log file, and then periodically upload all activity details as a delimited file to a blob.</span></span> <span data-ttu-id="87de6-375">W przypadku każdego wpisu dziennika o rozmiarze 1KB rozmiaru, możesz przekazać tysięcy w ramach jednej transakcji "Umieszczanie obiektu Blob" (możesz przekazać obiekt blob rozmiar w ramach pojedynczej transakcji do 64MB).</span><span class="sxs-lookup"><span data-stu-id="87de6-375">If each log entry is 1KB in size, you can upload thousands in a single "Put Blob" transaction (you can upload a blob of up to 64MB in size in a single transaction).</span></span> <span data-ttu-id="87de6-376">Oczywiście jeśli komputer lokalny ulegnie awarii przed przekazywania, potencjalnie utracisz niektóre dane dziennika: Deweloper aplikacji musi projektowania możliwości urządzeń klienckich lub przekazywanie błędów.</span><span class="sxs-lookup"><span data-stu-id="87de6-376">Of course, if the local machine crashes prior to the upload, you will potentially lose some log data: the application developer must design for the possibility of client device or upload failures.</span></span>  <span data-ttu-id="87de6-377">Jeśli dane działanie muszą zostać pobrane dla timespans (nie tylko pojedyncze działanie), obiekty BLOB są zalecane przez tabel.</span><span class="sxs-lookup"><span data-stu-id="87de6-377">If the activity data needs to be downloaded for timespans (not just single activity), then blobs are recommended over tables.</span></span>

### <a name="net-configuration"></a><span data-ttu-id="87de6-378">Konfiguracja .NET</span><span class="sxs-lookup"><span data-stu-id="87de6-378">.NET Configuration</span></span>
<span data-ttu-id="87de6-379">Jeśli przy użyciu programu .NET Framework, w tej sekcji przedstawiono kilka ustawień konfiguracyjnych szybki, których można dokonać znaczną poprawę wydajności.</span><span class="sxs-lookup"><span data-stu-id="87de6-379">If using the .NET Framework, this section lists several quick configuration settings that you can use to make significant performance improvements.</span></span>  <span data-ttu-id="87de6-380">Jeśli korzystanie z innych języków, sprawdź, czy podobne uniwersalne w wybranym języku.</span><span class="sxs-lookup"><span data-stu-id="87de6-380">If using other languages, check to see if similar concepts apply in your chosen language.</span></span>  

#### <span data-ttu-id="87de6-381"><a name="subheading9"></a>Zwiększenia domyślnego limitu połączenia</span><span class="sxs-lookup"><span data-stu-id="87de6-381"><a name="subheading9"></a>Increase default connection limit</span></span>
<span data-ttu-id="87de6-382">W środowisku .NET poniższy kod zwiększa domyślny limit połączeń (która jest zazwyczaj 2 w środowisku klienta lub 10 w środowisku serwera) do 100.</span><span class="sxs-lookup"><span data-stu-id="87de6-382">In .NET, the following code increases the default connection limit (which is usually 2 in a client environment or 10 in a server environment) to 100.</span></span> <span data-ttu-id="87de6-383">Zazwyczaj należy ustawić wartość do około liczbę wątków używanych przez aplikację.</span><span class="sxs-lookup"><span data-stu-id="87de6-383">Typically, you should set the value to approximately the number of threads used by your application.</span></span>  

```csharp
ServicePointManager.DefaultConnectionLimit = 100; //(Or More)  
```

<span data-ttu-id="87de6-384">Należy ustawić limit połączeń przed otwarciem wszystkie połączenia.</span><span class="sxs-lookup"><span data-stu-id="87de6-384">You must set the connection limit before opening any connections.</span></span>  

<span data-ttu-id="87de6-385">Dla innych języków programowania zobacz dokumentację tego języka Aby określić, jak ustawić limit połączeń.</span><span class="sxs-lookup"><span data-stu-id="87de6-385">For other programming languages, see that language's documentation to determine how to set the connection limit.</span></span>  

<span data-ttu-id="87de6-386">Aby uzyskać dodatkowe informacje, zobacz we wpisie blogu [usług sieci Web: równoczesnych połączeń](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span><span class="sxs-lookup"><span data-stu-id="87de6-386">For additional information, see the blog post [Web Services: Concurrent Connections](http://blogs.msdn.com/b/darrenj/archive/2005/03/07/386655.aspx).</span></span>  

#### <span data-ttu-id="87de6-387"><a name="subheading10"></a>Zwiększ wątków Min puli wątków, jeśli przy użyciu synchronicznej kodu z zadań asynchronicznych</span><span class="sxs-lookup"><span data-stu-id="87de6-387"><a name="subheading10"></a>Increase ThreadPool Min Threads if using synchronous code with Async Tasks</span></span>
<span data-ttu-id="87de6-388">Ten kod spowoduje zwiększenie wątków z puli wątków min:</span><span class="sxs-lookup"><span data-stu-id="87de6-388">This code will increase the thread pool min threads:</span></span>  

```csharp
ThreadPool.SetMinThreads(100,100); //(Determine the right number for your application)  
```

<span data-ttu-id="87de6-389">Aby uzyskać więcej informacji, zobacz [metody ThreadPool.SetMinThreads](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span><span class="sxs-lookup"><span data-stu-id="87de6-389">For more information, see [ThreadPool.SetMinThreads Method](http://msdn.microsoft.com/library/system.threading.threadpool.setminthreads%28v=vs.110%29.aspx).</span></span>  

#### <span data-ttu-id="87de6-390"><a name="subheading11"></a>Korzystać z platformy .NET 4.5 wyrzucanie elementów bezużytecznych</span><span class="sxs-lookup"><span data-stu-id="87de6-390"><a name="subheading11"></a>Take advantage of .NET 4.5 Garbage Collection</span></span>
<span data-ttu-id="87de6-391">Umożliwia .NET 4.5 lub nowszej do aplikacji klienckiej, korzystając z usprawnień wydajności w pamięci serwera.</span><span class="sxs-lookup"><span data-stu-id="87de6-391">Use .NET 4.5 or later for the client application to take advantage of performance improvements in server garbage collection.</span></span>

<span data-ttu-id="87de6-392">Aby uzyskać więcej informacji, zobacz artykuł [Omówienie programu poprawy wydajności w programie .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span><span class="sxs-lookup"><span data-stu-id="87de6-392">For more information, see the article [An Overview of Performance Improvements in .NET 4.5](http://msdn.microsoft.com/magazine/hh882452.aspx).</span></span>  

### <span data-ttu-id="87de6-393"><a name="subheading12"></a>Niepowiązane równoległości</span><span class="sxs-lookup"><span data-stu-id="87de6-393"><a name="subheading12"></a>Unbounded Parallelism</span></span>
<span data-ttu-id="87de6-394">Równoległość mogą być doskonałą wydajność, należy zachować ostrożność przekazywanie lub pobieranie danych przy użyciu wielu procesów roboczych na dostęp do wielu partycji przy użyciu niepowiązany równoległości (brak limitu liczby wątków i/lub równoległych żądań) (kontenerów, kolejki, lub Tabela partycji) w tym samym koncie magazynu lub dostępu do wielu elementów w tej samej partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-394">While parallelism can be great for performance, be careful about using unbounded parallelism (no limit on the number of threads and/or parallel requests) to upload or download data, using multiple workers to access multiple partitions (containers, queues, or table partitions) in the same storage account or to access multiple items in the same partition.</span></span> <span data-ttu-id="87de6-395">W przypadku niepowiązanego równoległości, aplikacja może przekroczyć możliwości urządzeń klienckich lub skalowalności konta magazynu elementów docelowych, co powoduje dłuższe czasy oczekiwania i ograniczania przepustowości.</span><span class="sxs-lookup"><span data-stu-id="87de6-395">If the parallelism is unbounded, your application can exceed the client device's capabilities or the storage account's scalability targets resulting in longer latencies and throttling.</span></span>  

### <span data-ttu-id="87de6-396"><a name="subheading13"></a>Narzędzia i biblioteki klienta magazynu</span><span class="sxs-lookup"><span data-stu-id="87de6-396"><a name="subheading13"></a>Storage Client Libraries and Tools</span></span>
<span data-ttu-id="87de6-397">Należy zawsze używać najnowszej bibliotek klienta i narzędzia firmy Microsoft.</span><span class="sxs-lookup"><span data-stu-id="87de6-397">Always use the latest Microsoft provided client libraries and tools.</span></span> <span data-ttu-id="87de6-398">W czasie zapisywania są dostępne dla platformy .NET, Windows Phone środowiska wykonawczego systemu Windows, Java i C++ bibliotek klienta, a także biblioteki podglądu dla innych języków.</span><span class="sxs-lookup"><span data-stu-id="87de6-398">At the time of writing, there are client libraries available for .NET, Windows Phone, Windows Runtime, Java, and C++, as well as preview libraries for other languages.</span></span> <span data-ttu-id="87de6-399">Ponadto firma Microsoft wydała poleceń cmdlet programu PowerShell i polecenia wiersza polecenia platformy Azure do pracy z usługą Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="87de6-399">In addition, Microsoft has released PowerShell cmdlets and Azure CLI commands for working with Azure Storage.</span></span> <span data-ttu-id="87de6-400">Microsoft aktywnie rozwija tych narzędzi z wydajnością na uwadze, jednocześnie dbając o ich na bieżąco z najnowszymi wersjami usługi i gwarantuje, że wiele praktyk sprawdzonych wydajności wewnętrznie obsługują.</span><span class="sxs-lookup"><span data-stu-id="87de6-400">Microsoft actively develops these tools with performance in mind, keeps them up to date with the latest service versions, and ensures they handle many of the proven performance practices internally.</span></span>  

### <a name="retries"></a><span data-ttu-id="87de6-401">Ponowne próby</span><span class="sxs-lookup"><span data-stu-id="87de6-401">Retries</span></span>
#### <span data-ttu-id="87de6-402"><a name="subheading14"></a>Ograniczanie ServerBusy</span><span class="sxs-lookup"><span data-stu-id="87de6-402"><a name="subheading14"></a>Throttling/ServerBusy</span></span>
<span data-ttu-id="87de6-403">W niektórych przypadkach usługa magazynu może ograniczyć aplikacji lub może się zdarzyć, nie można obsłużyć żądania ze względu na niektórych stan przejściowy i zwraca komunikat "503 Serwer jest zajęty" lub "500 Timeout".</span><span class="sxs-lookup"><span data-stu-id="87de6-403">In some cases, the storage service may throttle your application or may simply be unable to serve the request due to some transient condition and return a "503 Server busy" message or "500 Timeout".</span></span>  <span data-ttu-id="87de6-404">Może to nastąpić, jeśli aplikacja zbliża się do dowolnej wartości docelowe skalowalności lub jeśli system jest ponowne równoważenie dane podzielonym na partycje, aby umożliwić wyższej przepustowości.</span><span class="sxs-lookup"><span data-stu-id="87de6-404">This can happen if your application is approaching any of the scalability targets, or if the system is rebalancing your partitioned data to allow for higher throughput.</span></span>  <span data-ttu-id="87de6-405">Aplikacja kliencka zazwyczaj ponów operację, powodujący takie wystąpił błąd: próba jednym żądaniu później będzie możliwe.</span><span class="sxs-lookup"><span data-stu-id="87de6-405">The client application should typically retry the operation that causes such an error: attempting the same request later can succeed.</span></span> <span data-ttu-id="87de6-406">Jednak usługa magazynu jest ograniczanie aplikacji, ponieważ jest powyżej wartości docelowe skalowalności lub nawet wtedy, gdy usługa nie może obsłużyć żądania z innego powodu, agresywne ponownych prób zwykle należy co gorsza problem.</span><span class="sxs-lookup"><span data-stu-id="87de6-406">However, if the storage service is throttling your application because it is exceeding scalability targets, or even if the service was unable to serve the request for some other reason, aggressive retries usually make the problem worse.</span></span> <span data-ttu-id="87de6-407">Z tego powodu należy używać wykładniczej wycofania (klient biblioteki ustawienie domyślne to zachowanie).</span><span class="sxs-lookup"><span data-stu-id="87de6-407">For this reason, you should use an exponential back off (the client libraries default to this behavior).</span></span> <span data-ttu-id="87de6-408">Na przykład aplikacja może ponów próbę po 2 sekundy 4 sekundy, a następnie 10 sekund, a następnie 30 sekund, a następnie nadaj całkowicie.</span><span class="sxs-lookup"><span data-stu-id="87de6-408">For example, your application may retry after 2 seconds, then 4 seconds, then 10 seconds, then 30 seconds, and then give up completely.</span></span> <span data-ttu-id="87de6-409">Powoduje to zachowanie aplikacji znacznie zmniejszyć jego obciążenia w usłudze zamiast powiększając istniejące problemów.</span><span class="sxs-lookup"><span data-stu-id="87de6-409">This behavior results in your application significantly reducing its load on the service rather than exacerbating any problems.</span></span>  

<span data-ttu-id="87de6-410">Należy pamiętać, że błędy połączenia można ponowić natychmiast, ponieważ nie są wynikiem ograniczania przepustowości i powinny być przejściowy.</span><span class="sxs-lookup"><span data-stu-id="87de6-410">Note that connectivity errors can be retried immediately, because they are not the result of throttling and are expected to be transient.</span></span>  

#### <span data-ttu-id="87de6-411"><a name="subheading15"></a>Niepowtarzającego — błędy</span><span class="sxs-lookup"><span data-stu-id="87de6-411"><a name="subheading15"></a>Non-Retryable Errors</span></span>
<span data-ttu-id="87de6-412">Znane błędy, które mogą ponownych prób, a które nie są są bibliotek klienckich.</span><span class="sxs-lookup"><span data-stu-id="87de6-412">The client libraries are aware of which errors are retry-able and which are not.</span></span> <span data-ttu-id="87de6-413">Podczas pisania kodu przed interfejs API REST magazynu, pamiętaj, występują błędy, które nie powinny ponawiania: na przykład 400 (nieprawidłowe żądanie) odpowiedź wskazuje, czy aplikacja kliencka wysłane żądanie, które nie może być przetworzone, ponieważ nie było w formularzu oczekiwanego.</span><span class="sxs-lookup"><span data-stu-id="87de6-413">However, if you are writing your own code against the storage REST API, remember there are some errors that you should not retry: for example, a 400 (Bad Request) response indicates that the client application sent a request that could not be processed because it was not in an expected form.</span></span> <span data-ttu-id="87de6-414">Ponowne wysyłanie żądania spowoduje, że ta sama odpowiedź zawsze, więc nie ma żadnego punktu w ponawianie próby jego.</span><span class="sxs-lookup"><span data-stu-id="87de6-414">Resending this request will result the same response every time, so there is no point in retrying it.</span></span> <span data-ttu-id="87de6-415">Podczas pisania kodu przed interfejs API REST magazynu, należy pamiętać, co oznaczają kody błędów i odpowiednie sposób, aby ponowić próbę (lub nie) dla każdego z nich.</span><span class="sxs-lookup"><span data-stu-id="87de6-415">If you are writing your own code against the storage REST API, be aware of what the error codes mean and the proper way to retry (or not) for each of them.</span></span>  

#### <a name="useful-resources"></a><span data-ttu-id="87de6-416">Przydatne zasoby</span><span class="sxs-lookup"><span data-stu-id="87de6-416">Useful Resources</span></span>
<span data-ttu-id="87de6-417">Aby uzyskać więcej informacji o kodach błędów magazynu, zobacz [stanu i kodów błędów](http://msdn.microsoft.com/library/azure/dd179382.aspx) w witrynie sieci web Microsoft Azure.</span><span class="sxs-lookup"><span data-stu-id="87de6-417">For more information about storage error codes, see [Status and Error Codes](http://msdn.microsoft.com/library/azure/dd179382.aspx) on the Microsoft Azure web site.</span></span>  

## <a name="blobs"></a><span data-ttu-id="87de6-418">Obiekty blob</span><span class="sxs-lookup"><span data-stu-id="87de6-418">Blobs</span></span>
<span data-ttu-id="87de6-419">Oprócz sprawdzonych rozwiązań dla [wszystkie usługi](#allservices) opisanych powyżej, poniżej sprawdzonych rozwiązań dotyczą przede wszystkim usługi blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-419">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the blob service.</span></span>  

### <a name="blob-specific-scalability-targets"></a><span data-ttu-id="87de6-420">Wartości docelowe skalowalności specyficzne dla obiektów blob</span><span class="sxs-lookup"><span data-stu-id="87de6-420">Blob-Specific Scalability Targets</span></span>
#### <span data-ttu-id="87de6-421"><a name="subheading46"></a>Wielu klientów jednocześnie dostęp do pojedynczego obiektu</span><span class="sxs-lookup"><span data-stu-id="87de6-421"><a name="subheading46"></a>Multiple clients accessing a single object concurrently</span></span>
<span data-ttu-id="87de6-422">Jeśli masz dużą liczbę klientów uzyskujących dostęp do pojedynczego obiektu jednocześnie należy wziąć pod uwagę na wartości docelowe skalowalności konta obiekt i magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-422">If you have a large number of clients accessing a single object concurrently you will need to consider per object and storage account scalability targets.</span></span> <span data-ttu-id="87de6-423">Dokładna liczba klientów, którzy mogą uzyskiwać dostęp do pojedynczego obiektu będą się różnić w zależności od czynników, takich jak liczba klientów żądać obiektu jednocześnie, rozmiar obiektu, sieci warunki itp.</span><span class="sxs-lookup"><span data-stu-id="87de6-423">The exact number of clients that can access a single object will vary depending on factors such as the number of clients requesting the object simultaneously, the size of the object, network conditions etc.</span></span>

<span data-ttu-id="87de6-424">Jeśli obiekt może być dystrybuowane za pośrednictwem obsługiwanych CDN, taką jak obrazy lub filmy wideo z witryny internetowej, a następnie należy używać sieci CDN.</span><span class="sxs-lookup"><span data-stu-id="87de6-424">If the object can be distributed through a CDN such as images or videos served from a website then you should use a CDN.</span></span> <span data-ttu-id="87de6-425">Zobacz [tutaj](#subheading5).</span><span class="sxs-lookup"><span data-stu-id="87de6-425">See [here](#subheading5).</span></span>

<span data-ttu-id="87de6-426">W innych sytuacjach, takich jak symulacje naukowych, gdzie jest poufne dane dostępne są dwie opcje.</span><span class="sxs-lookup"><span data-stu-id="87de6-426">In other scenarios such as scientific simulations where the data is confidential you have two options.</span></span> <span data-ttu-id="87de6-427">Pierwsza to aby przesunąć dostępu właściwe dla obciążenia w taki sposób, że obiekt jest dostępny w danym okresie czasu vs uzyskiwany jednocześnie.</span><span class="sxs-lookup"><span data-stu-id="87de6-427">The first is to stagger your workload's access such that the object is accessed over a period of time vs being accessed simultaneously.</span></span> <span data-ttu-id="87de6-428">Alternatywnie możesz tymczasowo skopiować obiekt do wielu kont magazynu, co pozwala zwiększyć całkowitą liczbę IOPS dla każdego obiektu i wielu kont magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-428">Alternatively, you can temporarily copy the object to multiple storage accounts thus increasing the total IOPS per object and across storage accounts.</span></span> <span data-ttu-id="87de6-429">Podczas testowania ograniczone znaleziono, że około 25 maszyn wirtualnych jednocześnie można pobrać obiektu blob 100GB, równoległe (każda maszyna wirtualna została parallelizing pobierania za pomocą wątków 32).</span><span class="sxs-lookup"><span data-stu-id="87de6-429">In limited testing we found that around 25 VMs could simultaneously download a 100GB blob in parallel (each VM was parallelizing the download using 32 threads).</span></span> <span data-ttu-id="87de6-430">Jeśli użytkownik ma 100 klientów wymagające dostępu do obiektu, najpierw skopiować go do drugiego konta magazynu i mieć najpierw 50 maszyn wirtualnych dostęp pierwszy obiekt blob i drugi 50 dostęp maszyny wirtualne drugiej obiektów blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-430">If you had 100 clients needing to access the object, first copy it to a second storage account and then have the first 50 VMs access the first blob and the second 50 VMs access the second blob.</span></span> <span data-ttu-id="87de6-431">Wyniki różni się zależnie od Twoje zachowanie aplikacji, więc należy przetestować, to podczas projektowania.</span><span class="sxs-lookup"><span data-stu-id="87de6-431">Results will vary depending on your applications behavior so you should test this during design.</span></span> 

#### <span data-ttu-id="87de6-432"><a name="subheading16"></a>Przepustowości i operacji na obiektów Blob</span><span class="sxs-lookup"><span data-stu-id="87de6-432"><a name="subheading16"></a>Bandwidth and operations per Blob</span></span>
<span data-ttu-id="87de6-433">Można odczytać lub zapisać do pojedynczego obiektu blob na maksymalnie 60 MB na sekundę (jest to około 480 MB/s przekracza możliwości wiele sieci po stronie klienta (łącznie z fizycznej karty Sieciowej na urządzeniu klienckim).</span><span class="sxs-lookup"><span data-stu-id="87de6-433">You can read or write to a single blob at up to a maximum of 60 MB/second (this is approximately 480 Mbps which exceeds the capabilities of many client side networks (including the physical NIC on the client device).</span></span> <span data-ttu-id="87de6-434">Ponadto pojedynczego obiektu blob obsługuje maksymalnie 500 żądań na sekundę.</span><span class="sxs-lookup"><span data-stu-id="87de6-434">In addition, a single blob supports up to 500 requests per second.</span></span> <span data-ttu-id="87de6-435">Jeśli wielu klientów, którzy potrzebują do odczytu tego samego obiektu blob i może zostać przekroczona tych ograniczeń, należy rozważyć przy użyciu CDN dystrybucji obiektu blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-435">If you have multiple clients that need to read the same blob and you might exceed these limits, you should consider using a CDN for distributing the blob.</span></span>  

<span data-ttu-id="87de6-436">Aby uzyskać więcej informacji o przepływności docelowej dla obiektów blob, zobacz [cele dotyczące wydajności i skalowalności magazynu Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="87de6-436">For more information about target throughput for blobs, see [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <a name="copying-and-moving-blobs"></a><span data-ttu-id="87de6-437">Kopiowanie i przenoszenie obiektów blob</span><span class="sxs-lookup"><span data-stu-id="87de6-437">Copying and Moving Blobs</span></span>
#### <span data-ttu-id="87de6-438"><a name="subheading17"></a>Kopiowanie obiektu Blob</span><span class="sxs-lookup"><span data-stu-id="87de6-438"><a name="subheading17"></a>Copy Blob</span></span>
<span data-ttu-id="87de6-439">Przydatne możliwość kopiowania obiektów blob na kontach wprowadzone magazynu interfejsu API REST wersji 2012-02-12: aplikacja kliencka poinstruować usługę magazynu można skopiować obiektu blob z innego źródła (prawdopodobnie w innego konta magazynu), a następnie umożliwił wykonaj usługi Kopia asynchronicznie.</span><span class="sxs-lookup"><span data-stu-id="87de6-439">The storage REST API version 2012-02-12 introduced the useful ability to copy blobs across accounts: a client application can instruct the storage service to copy a blob from another source (possibly in a different storage account), and then let the service perform the copy asynchronously.</span></span> <span data-ttu-id="87de6-440">Może to znacznie zmniejszyć przepustowość potrzebne dla aplikacji, gdy są migrację danych z innych kont magazynu, ponieważ nie trzeba pobrać i przekazać dane.</span><span class="sxs-lookup"><span data-stu-id="87de6-440">This can significantly reduce the bandwidth needed for the application when you are migrating data from other storage accounts because you do not need to download and upload the data.</span></span>  

<span data-ttu-id="87de6-441">Pierwsza kwestia, jest jednak, że jeśli kopiowanie odbywa się między kontami magazynu, nie ma żadnej gwarancji czas na podczas kopiowania zostanie zakończony.</span><span class="sxs-lookup"><span data-stu-id="87de6-441">One consideration, however, is that, when copying between storage accounts, there is no time guarantee on when the copy will complete.</span></span> <span data-ttu-id="87de6-442">Jeśli aplikacja musi wykonać kopiowania obiektów blob, szybko pod kontrolą, lepszym rozwiązaniem byłoby można skopiować obiektu blob, pobierając go z maszyną wirtualną i przekazać go do lokalizacji docelowej.</span><span class="sxs-lookup"><span data-stu-id="87de6-442">If your application needs to complete a blob copy quickly under your control, it may be better to copy the blob by downloading it to a VM and then uploading it to the destination.</span></span>  <span data-ttu-id="87de6-443">W przypadku pełnego przewidywalności w takiej sytuacji upewnij się, że kopię jest wykonywane przez maszynę Wirtualną w tym samym regionie Azure, w przeciwnym razie warunków sieciowych może i prawdopodobnie zostaną mają wpływ na wydajność kopii.</span><span class="sxs-lookup"><span data-stu-id="87de6-443">For full predictability in that situation, ensure that the copy is performed by a VM running in the same Azure region, or else network conditions may (and probably will) affect your copy performance.</span></span>  <span data-ttu-id="87de6-444">Ponadto można monitorować postęp asynchroniczne kopiowania programowo.</span><span class="sxs-lookup"><span data-stu-id="87de6-444">In addition, you can monitor the progress of an asynchronous copy programmatically.</span></span>  

<span data-ttu-id="87de6-445">Należy pamiętać, kopie w ramach tego samego konta magazynu, sama są zazwyczaj zakończenie szybko.</span><span class="sxs-lookup"><span data-stu-id="87de6-445">Note that copies within the same storage account itself are generally completed quickly.</span></span>  

<span data-ttu-id="87de6-446">Aby uzyskać więcej informacji, zobacz [kopiowania obiektu Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span><span class="sxs-lookup"><span data-stu-id="87de6-446">For more information, see [Copy Blob](http://msdn.microsoft.com/library/azure/dd894037.aspx).</span></span>  

#### <span data-ttu-id="87de6-447"><a name="subheading18"></a>Przy użyciu programu AzCopy</span><span class="sxs-lookup"><span data-stu-id="87de6-447"><a name="subheading18"></a>Use AzCopy</span></span>
<span data-ttu-id="87de6-448">Zespół usługi Azure Storage wydała narzędzie wiersza polecenia "AzCopy" który mają na celu pomoc zbiorczego transferu wiele obiektów blob do z i wielu kont magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-448">The Azure Storage team has released a command-line tool "AzCopy" that is meant to help with bulk transferring many blobs to, from, and across storage accounts.</span></span>  <span data-ttu-id="87de6-449">To narzędzie jest zoptymalizowana w tym scenariuszu i można osiągnąć dużą szybkością.</span><span class="sxs-lookup"><span data-stu-id="87de6-449">This tool is optimized for this scenario, and can achieve high transfer rates.</span></span>  <span data-ttu-id="87de6-450">Zaleca się jego użycie zbiorczego przekazywanie, pobieranie i scenariuszy kopii.</span><span class="sxs-lookup"><span data-stu-id="87de6-450">Its use is encouraged for bulk upload, download, and copy scenarios.</span></span> <span data-ttu-id="87de6-451">Aby uzyskać więcej informacji i pobierz go, zobacz [Transfer danych za pomocą wiersza polecenia Azcopy](storage-use-azcopy.md).</span><span class="sxs-lookup"><span data-stu-id="87de6-451">To learn more about it and download it, see [Transfer data with the AzCopy Command-Line Utility](storage-use-azcopy.md).</span></span>  

#### <span data-ttu-id="87de6-452"><a name="subheading19"></a>Usługa Azure Import/Eksport</span><span class="sxs-lookup"><span data-stu-id="87de6-452"><a name="subheading19"></a>Azure Import/Export Service</span></span>
<span data-ttu-id="87de6-453">Bardzo duże woluminy danych (więcej niż 1TB) Magazyn Azure oferuje usługi Import/eksport, która umożliwia wysyłanie i pobieranie z magazynu obiektów blob wysyłanie dysków twardych.</span><span class="sxs-lookup"><span data-stu-id="87de6-453">For very large volumes of data (more than 1TB), the Azure Storage offers the Import/Export service, which allows for uploading and downloading from blob storage by shipping hard drives.</span></span>  <span data-ttu-id="87de6-454">Można dane są umieszczane na dysku twardym i wysyłać do firmy Microsoft, przekazywania lub wysyłać pusty dysk twardy do firmy Microsoft do pobierania danych.</span><span class="sxs-lookup"><span data-stu-id="87de6-454">You can put your data on a hard drive and send it to Microsoft for upload, or send a blank hard drive to Microsoft to download data.</span></span>  <span data-ttu-id="87de6-455">Aby uzyskać więcej informacji, zobacz [korzystanie z usługi Microsoft Azure importu/eksportu przesyłanie danych do magazynu obiektów Blob](storage-import-export-service.md).</span><span class="sxs-lookup"><span data-stu-id="87de6-455">For more information, see [Use the Microsoft Azure Import/Export Service to Transfer Data to Blob Storage](storage-import-export-service.md).</span></span>  <span data-ttu-id="87de6-456">Może to być znacznie skuteczniejsza niż przekazywanie/pobieranie ten wolumin danych za pośrednictwem sieci.</span><span class="sxs-lookup"><span data-stu-id="87de6-456">This can be much more efficient than uploading/downloading this volume of data over the network.</span></span>  

### <span data-ttu-id="87de6-457"><a name="subheading20"></a>Używanie metadanych</span><span class="sxs-lookup"><span data-stu-id="87de6-457"><a name="subheading20"></a>Use metadata</span></span>
<span data-ttu-id="87de6-458">Usługa blob obsługuje żądania head, które mogą zawierać metadane dotyczące obiektów blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-458">The blob service supports head requests, which can include metadata about the blob.</span></span> <span data-ttu-id="87de6-459">Na przykład w razie potrzeby danych EXIF poza zdjęcie aplikacji go można pobrać zdjęcia i wyodrębnij go.</span><span class="sxs-lookup"><span data-stu-id="87de6-459">For example, if your application needed the EXIF data out of a photo, it could retrieve the photo and extract it.</span></span> <span data-ttu-id="87de6-460">Aby oszczędzić przepustowość i zwiększyć wydajność, aplikacja może zapisać danych EXIF w metadane obiektu blob, gdy aplikacja przekazywane zdjęcie: można następnie pobrać danych EXIF w metadanych za pomocą tylko żądania HEAD, zapisywanie znaczących przepustowości i czas przetwarzania potrzebne, aby wyodrębnić dane EXIF zawsze obiektu blob jest do odczytu.</span><span class="sxs-lookup"><span data-stu-id="87de6-460">To save bandwidth and improve performance, your application could store the EXIF data in the blob's metadata when the application uploaded the photo: you can then retrieve the EXIF data in metadata using only a HEAD request, saving significant bandwidth and the processing time needed to extract the EXIF data each time the blob is read.</span></span> <span data-ttu-id="87de6-461">Powinien to być przydatne w scenariuszach, w których należy tylko metadane i nie pełnej zawartości obiektu blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-461">This would be useful in scenarios where you only need the metadata, and not the full content of a blob.</span></span>  <span data-ttu-id="87de6-462">Należy pamiętać, że tylko 8 KB metadanych mogą być przechowywane na obiekt blob (usługa nie akceptuje żądań do magazynu większą), więc jeśli dane nie mieści się w tym rozmiar, nie można używać tej metody.</span><span class="sxs-lookup"><span data-stu-id="87de6-462">Note that only 8 KB of metadata can be stored per blob (the service will not accept a request to store more than that), so if the data does not fit in that size, you may not be able to use this approach.</span></span>  

<span data-ttu-id="87de6-463">Na przykład sposobu uzyskania metadane obiektu blob przy użyciu platformy .NET, zobacz [zestawu i pobrać właściwości i metadane](storage-properties-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="87de6-463">For an example of how to get a blob's metadata using .NET, see [Set and Retrieve Properties and Metadata](storage-properties-metadata.md).</span></span>  

### <a name="uploading-fast"></a><span data-ttu-id="87de6-464">Przekazywanie Fast</span><span class="sxs-lookup"><span data-stu-id="87de6-464">Uploading Fast</span></span>
<span data-ttu-id="87de6-465">Szybko przekazać obiektów blob, odpowiedzi na pierwsze pytanie jest: czy przekazywanie obiektu blob jeden lub wiele?</span><span class="sxs-lookup"><span data-stu-id="87de6-465">To upload blobs fast, the first question to answer is: are you uploading one blob or many?</span></span>  <span data-ttu-id="87de6-466">Użyj poniższych wskazówek, aby określić poprawną metodę, w zależności od danego scenariusza.</span><span class="sxs-lookup"><span data-stu-id="87de6-466">Use the below guidance to determine the correct method to use depending on your scenario.</span></span>  

#### <span data-ttu-id="87de6-467"><a name="subheading21"></a>Szybkie przekazywanie jednego dużych obiektów blob</span><span class="sxs-lookup"><span data-stu-id="87de6-467"><a name="subheading21"></a>Uploading one large blob quickly</span></span>
<span data-ttu-id="87de6-468">Szybko przekazać jeden duży obiekt blob, aplikacja kliencka przekazać jego bloków lub stron równoległe (co w trosce o wartości docelowe skalowalności poszczególne obiekty BLOB i konto magazynu jako całość).</span><span class="sxs-lookup"><span data-stu-id="87de6-468">To upload a single large blob quickly, your client application should upload its blocks or pages in parallel (being mindful of the scalability targets for individual blobs and the storage account as a whole).</span></span>  <span data-ttu-id="87de6-469">Należy zauważyć, że oficjalnego bibliotek udostępnionych przez firmę Microsoft klienta RTM magazynu (.NET, Java) możliwość to zrobić.</span><span class="sxs-lookup"><span data-stu-id="87de6-469">Note that the official Microsoft-provided RTM Storage Client libraries (.NET, Java) have the ability to do this.</span></span>  <span data-ttu-id="87de6-470">Dla każdego z bibliotekami używać poniżej określonego obiektu/właściwości można ustawić poziomu współbieżności:</span><span class="sxs-lookup"><span data-stu-id="87de6-470">For each of the libraries, use the below specified object/property to set the level of concurrency:</span></span>  

* <span data-ttu-id="87de6-471">.NET: Zestaw ParallelOperationThreadCount w obiekcie BlobRequestOptions do użycia.</span><span class="sxs-lookup"><span data-stu-id="87de6-471">.NET: Set ParallelOperationThreadCount on a BlobRequestOptions object to be used.</span></span>
* <span data-ttu-id="87de6-472">Java/Android: Użyj BlobRequestOptions.setConcurrentRequestCount()</span><span class="sxs-lookup"><span data-stu-id="87de6-472">Java/Android: Use BlobRequestOptions.setConcurrentRequestCount()</span></span>
* <span data-ttu-id="87de6-473">Node.js: Użyj parallelOperationThreadCount opcji żądania lub usługi blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-473">Node.js: Use parallelOperationThreadCount on either the request options or on the blob service.</span></span>
* <span data-ttu-id="87de6-474">C++: Metoda blob_request_options::set_parallelism_factor.</span><span class="sxs-lookup"><span data-stu-id="87de6-474">C++: Use the blob_request_options::set_parallelism_factor method.</span></span>

#### <span data-ttu-id="87de6-475"><a name="subheading22"></a>Szybko przekazać wiele obiektów blob</span><span class="sxs-lookup"><span data-stu-id="87de6-475"><a name="subheading22"></a>Uploading many blobs quickly</span></span>
<span data-ttu-id="87de6-476">Aby szybko przekazać wiele obiektów blob, Przekaż obiekty BLOB równolegle.</span><span class="sxs-lookup"><span data-stu-id="87de6-476">To upload many blobs quickly, upload blobs in parallel.</span></span> <span data-ttu-id="87de6-477">Jest to szybsza niż przekazywanie jednego obiekty BLOB w czasie z bloku równoległego przekazywania ponieważ rozprzestrzenia się przekazywania między wieloma partycjami usługi magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-477">This is faster than uploading single blobs at a time with parallel block uploads because it spreads the upload across multiple partitions of the storage service.</span></span> <span data-ttu-id="87de6-478">Pojedynczego obiektu blob obsługuje tylko przepustowości 60 MB na sekundę (około 480 MB/s).</span><span class="sxs-lookup"><span data-stu-id="87de6-478">A single blob only supports a throughput of 60 MB/second (approximately 480 Mbps).</span></span> <span data-ttu-id="87de6-479">W czasie zapisywania konta amerykańskiej LRS obsługuje maksymalnie 20 wejściowych GB/s, czyli znacznie większe niż obsługiwana przez poszczególnych obiektów blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-479">At the time of writing, a US-based LRS account supports up to 20 Gbps ingress which is far more than the throughput supported by an individual blob.</span></span>  <span data-ttu-id="87de6-480">[Narzędzie AzCopy](#subheading18) wykonuje przekazywanie równoległe domyślnie i jest zalecany dla tego scenariusza.</span><span class="sxs-lookup"><span data-stu-id="87de6-480">[AzCopy](#subheading18) performs uploads in parallel by default, and is recommended for this scenario.</span></span>  

### <span data-ttu-id="87de6-481"><a name="subheading23"></a>Wybierając odpowiedni typ obiektów blob</span><span class="sxs-lookup"><span data-stu-id="87de6-481"><a name="subheading23"></a>Choosing the correct type of blob</span></span>
<span data-ttu-id="87de6-482">Usługa Azure Storage obsługuje dwa typy obiektów blob: *strony* obiekty BLOB i *bloku* obiektów blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-482">Azure Storage supports two types of blob: *page* blobs and *block* blobs.</span></span> <span data-ttu-id="87de6-483">Użycie danego scenariusza wybór typu obiektu blob wpłynie na wydajności i skalowalności rozwiązania.</span><span class="sxs-lookup"><span data-stu-id="87de6-483">For a given usage scenario, your choice of blob type will affect the performance and scalability of your solution.</span></span> <span data-ttu-id="87de6-484">Blokowe obiekty BLOB są odpowiednie, jeśli chcesz przekazać wydajnie dużych ilości danych: na przykład aplikacja kliencka może być konieczne do przekazania do magazynu obiektów blob zdjęć i wideo.</span><span class="sxs-lookup"><span data-stu-id="87de6-484">Block blobs are appropriate when you want to upload large amounts of data efficiently: for example, a client application may need to upload photos or video to blob storage.</span></span> <span data-ttu-id="87de6-485">Stronicowe obiekty BLOB są odpowiednie, jeśli aplikacja musi przeprowadzić losowe zapisy na danych: na przykład Azure wirtualne dyski twarde są przechowywane jako stronicowych obiektów blob.</span><span class="sxs-lookup"><span data-stu-id="87de6-485">Page blobs are appropriate if the application needs to perform random writes on the data: for example, Azure VHDs are stored as page blobs.</span></span>  

<span data-ttu-id="87de6-486">Aby uzyskać więcej informacji, zobacz [opis blokowych obiektów blob, Dołącz obiektów blob i stronicowe obiekty BLOB](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span><span class="sxs-lookup"><span data-stu-id="87de6-486">For more information, see [Understanding Block Blobs, Append Blobs, and Page Blobs](http://msdn.microsoft.com/library/azure/ee691964.aspx).</span></span>  

## <a name="tables"></a><span data-ttu-id="87de6-487">Tabele</span><span class="sxs-lookup"><span data-stu-id="87de6-487">Tables</span></span>
<span data-ttu-id="87de6-488">Oprócz sprawdzonych rozwiązań dla [wszystkie usługi](#allservices) opisanych powyżej, poniżej sprawdzonych rozwiązań dotyczą przede wszystkim usługi tabel.</span><span class="sxs-lookup"><span data-stu-id="87de6-488">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the table service.</span></span>  

### <span data-ttu-id="87de6-489"><a name="subheading24"></a>Wartości docelowe skalowalności specyficzna dla tabeli</span><span class="sxs-lookup"><span data-stu-id="87de6-489"><a name="subheading24"></a>Table-Specific Scalability Targets</span></span>
<span data-ttu-id="87de6-490">Oprócz ograniczenia przepustowości całe konto magazynu tabele mają następujące ograniczenia określonych skalowalności.</span><span class="sxs-lookup"><span data-stu-id="87de6-490">In addition to the bandwidth limitations of an entire storage account, tables have the following specific scalability limit.</span></span>  <span data-ttu-id="87de6-491">Należy pamiętać, system będzie równoważenia obciążenia jako Twoje wzrost ruchu, że jeśli seria nagłym ruchu, nie można natychmiast uzyskać ten wolumin przepływności.</span><span class="sxs-lookup"><span data-stu-id="87de6-491">Note that the system will load balance as your traffic increases, but if your traffic has sudden bursts, you may not be able to get this volume of throughput immediately.</span></span>  <span data-ttu-id="87de6-492">Jeśli deseń seria, należy się spodziewać ograniczania przepustowości i/lub przekroczenia limitu czasu podczas serii jako magazyn usługi automatycznie równoważy obciążenie limit tabeli.</span><span class="sxs-lookup"><span data-stu-id="87de6-492">If your pattern has bursts, you should expect to see throttling and/or timeouts during the burst as the storage service automatically load balances out your table.</span></span>  <span data-ttu-id="87de6-493">Rozwijanie powoli zwykle ma lepsze wyniki jako udostępnia czas systemowy na potrzeby równoważenia obciążenia odpowiednio.</span><span class="sxs-lookup"><span data-stu-id="87de6-493">Ramping up slowly generally has better results as it gives the system time to load balance appropriately.</span></span>  

#### <a name="entities-per-second-account"></a><span data-ttu-id="87de6-494">Jednostek na sekundę (konto)</span><span class="sxs-lookup"><span data-stu-id="87de6-494">Entities per Second (Account)</span></span>
<span data-ttu-id="87de6-495">Limit skalowalności do uzyskiwania dostępu do tabel jest maksymalnie 20 000 jednostek (o rozmiarze 1KB każdego) na drugi dla konta.</span><span class="sxs-lookup"><span data-stu-id="87de6-495">The scalability limit for accessing tables is up to 20,000 entities (1KB each) per second for an account.</span></span>  <span data-ttu-id="87de6-496">Ogólnie rzecz biorąc każdy obiekt, który dodaje się zaktualizowany, usunięty lub skanowania liczby kierunku ten element docelowy.</span><span class="sxs-lookup"><span data-stu-id="87de6-496">In general, each entity that is inserted, updated, deleted, or scanned counts toward this target.</span></span>  <span data-ttu-id="87de6-497">Dlatego Wstawianie wsadowe, która zawiera 100 jednostek jest traktowane jako 100 jednostek.</span><span class="sxs-lookup"><span data-stu-id="87de6-497">So a batch insert that contains 100 entities would count as 100 entities.</span></span>  <span data-ttu-id="87de6-498">Zapytanie, które skanuje 1000 jednostek i zwraca 5 jest traktowane jako 1000 jednostek.</span><span class="sxs-lookup"><span data-stu-id="87de6-498">A query that scans 1000 entities and returns 5 would count as 1000 entities.</span></span>  

#### <a name="entities-per-second-partition"></a><span data-ttu-id="87de6-499">Jednostek na sekundę (partycja)</span><span class="sxs-lookup"><span data-stu-id="87de6-499">Entities per Second (Partition)</span></span>
<span data-ttu-id="87de6-500">W ramach jednej partycji docelowej skalowalność do uzyskiwania dostępu do tabel jest 2000 jednostek (1KB) na sekundę, przy użyciu tego samego zliczanie zgodnie z opisem w poprzedniej sekcji.</span><span class="sxs-lookup"><span data-stu-id="87de6-500">Within a single partition, the scalability target for accessing tables is 2,000 entities (1KB each) per second, using the same counting as described in the previous section.</span></span>  

### <a name="configuration"></a><span data-ttu-id="87de6-501">Konfiguracja</span><span class="sxs-lookup"><span data-stu-id="87de6-501">Configuration</span></span>
<span data-ttu-id="87de6-502">W tej sekcji przedstawiono kilka ustawień konfiguracji szybki, które można udostępnić znaczną poprawę wydajności w usłudze tabel:</span><span class="sxs-lookup"><span data-stu-id="87de6-502">This section lists several quick configuration settings that you can use to make significant performance improvements in the table service:</span></span>  

#### <span data-ttu-id="87de6-503"><a name="subheading25"></a>Użyj formatu JSON</span><span class="sxs-lookup"><span data-stu-id="87de6-503"><a name="subheading25"></a>Use JSON</span></span>
<span data-ttu-id="87de6-504">Począwszy od wersji usług magazynu 2013-08-15, usługa tabel obsługuje za pomocą JSON zamiast formatu AtomPub opartych na języku XML do przenoszenia danych z tabeli.</span><span class="sxs-lookup"><span data-stu-id="87de6-504">Beginning with storage service version 2013-08-15, the table service supports using JSON instead of the XML-based AtomPub format for transferring table data.</span></span> <span data-ttu-id="87de6-505">Można zmniejszyć rozmiar ładunku jak 75% i może znacznie poprawić wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="87de6-505">This can reduce payload sizes by as much as 75% and can significantly improve the performance of your application.</span></span>

<span data-ttu-id="87de6-506">Aby uzyskać więcej informacji, zobacz wpis [Microsoft Azure tabel: wprowadzenie JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) i [Format ładunku dla operacji usługi tabeli](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span><span class="sxs-lookup"><span data-stu-id="87de6-506">For more information, see the post [Microsoft Azure Tables: Introducing JSON](http://blogs.msdn.com/b/windowsazurestorage/archive/2013/12/05/windows-azure-tables-introducing-json.aspx) and [Payload Format for Table Service Operations](http://msdn.microsoft.com/library/azure/dn535600.aspx).</span></span>

#### <span data-ttu-id="87de6-507"><a name="subheading26"></a>Nagle'a wyłączone</span><span class="sxs-lookup"><span data-stu-id="87de6-507"><a name="subheading26"></a>Nagle Off</span></span>
<span data-ttu-id="87de6-508">Algorytm Nagle'a firmy jest często stosowana w sieciach TCP/IP w celu zwiększenia wydajności sieci.</span><span class="sxs-lookup"><span data-stu-id="87de6-508">Nagle's algorithm is widely implemented across TCP/IP networks as a means to improve network performance.</span></span> <span data-ttu-id="87de6-509">Jednak nie jest optymalne we wszystkich okolicznościach (na przykład wysokiej interakcyjne środowiska).</span><span class="sxs-lookup"><span data-stu-id="87de6-509">However, it is not optimal in all circumstances (such as highly interactive environments).</span></span> <span data-ttu-id="87de6-510">Usługi Azure Storage algorytm Nagle'a firmy ma negatywny wpływ na wydajność żądań do tabeli i kolejki usług i należy go wyłączyć, jeśli to możliwe.</span><span class="sxs-lookup"><span data-stu-id="87de6-510">For Azure Storage, Nagle's algorithm has a negative impact on the performance of requests to the table and queue services, and you should disable it if possible.</span></span>  

<span data-ttu-id="87de6-511">Aby uzyskać więcej informacji, zobacz nasze blogu [nie przyjazną kierunku małych żądań jest algorytm Nagle'a w](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), co wyjaśnia, dlaczego algorytm Nagle'a w słabo współdziała z tabeli i kolejki żądań i pokazuje, jak ją wyłączyć na kliencie aplikacja.</span><span class="sxs-lookup"><span data-stu-id="87de6-511">For more information, see our blog post [Nagle's Algorithm is Not Friendly towards Small Requests](http://blogs.msdn.com/b/windowsazurestorage/archive/2010/06/25/nagle-s-algorithm-is-not-friendly-towards-small-requests.aspx), which explains why Nagle's algorithm interacts poorly with table and queue requests, and shows how to disable it in your client application.</span></span>  

### <a name="schema"></a><span data-ttu-id="87de6-512">Schemat</span><span class="sxs-lookup"><span data-stu-id="87de6-512">Schema</span></span>
<span data-ttu-id="87de6-513">Jak reprezentują i wyszukiwanie danych jest najważniejszych pojedynczego czynnik, który wpływa na wydajność usługi tabel.</span><span class="sxs-lookup"><span data-stu-id="87de6-513">How you represent and query your data is the biggest single factor that affects the performance of the table service.</span></span> <span data-ttu-id="87de6-514">Gdy każda aplikacja jest inny, w tej sekcji opisano niektóre ogólne wskazówki sprawdzonych, które odnoszą się do:</span><span class="sxs-lookup"><span data-stu-id="87de6-514">While every application is different, this section outlines some general proven practices that relate to:</span></span>  

* <span data-ttu-id="87de6-515">Projektowaniu tabel</span><span class="sxs-lookup"><span data-stu-id="87de6-515">Table design</span></span>
* <span data-ttu-id="87de6-516">Wydajność kwerendy</span><span class="sxs-lookup"><span data-stu-id="87de6-516">Efficient queries</span></span>
* <span data-ttu-id="87de6-517">Aktualizacje wydajne danych</span><span class="sxs-lookup"><span data-stu-id="87de6-517">Efficient data updates</span></span>  

#### <span data-ttu-id="87de6-518"><a name="subheading27"></a>Tabele i partycji</span><span class="sxs-lookup"><span data-stu-id="87de6-518"><a name="subheading27"></a>Tables and partitions</span></span>
<span data-ttu-id="87de6-519">Tabele są podzielone na partycje.</span><span class="sxs-lookup"><span data-stu-id="87de6-519">Tables are divided into partitions.</span></span> <span data-ttu-id="87de6-520">Każdy podmiot przechowywane w partycji współużytkują ten sam klucz partycji i ma klucz wiersza unikatowy, aby zidentyfikować go w ramach tej partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-520">Every entity stored in a partition shares the same partition key and has a unique row key to identify it within that partition.</span></span> <span data-ttu-id="87de6-521">Partycje zapewniają korzyści, ale również wprowadzić limity skalowalności.</span><span class="sxs-lookup"><span data-stu-id="87de6-521">Partitions provide benefits but also introduce scalability limits.</span></span>  

* <span data-ttu-id="87de6-522">Korzyści: Można aktualizować jednostek w tej samej partycji w jednym, atomic, partii transakcji, która zawiera maksymalnie 100 przechowywania operacji (limit to łączny rozmiar 4MB).</span><span class="sxs-lookup"><span data-stu-id="87de6-522">Benefits: You can update entities in the same partition in a single, atomic, batch transaction that contains up to 100 separate storage operations (limit of 4MB total size).</span></span> <span data-ttu-id="87de6-523">Zakładając, że taką samą liczbę jednostek, które mają zostać pobrane, możesz także zbadać danych w jednej partycji wydajniej danych obejmującej partycji (mimo że Dowiedz się więcej zaleceń dotyczących przeszukiwaniem danych w tabeli).</span><span class="sxs-lookup"><span data-stu-id="87de6-523">Assuming the same number of entities to be retrieved, you can also query data within a single partition more efficiently than data that spans partitions (though read on for further recommendations on querying table data).</span></span>
* <span data-ttu-id="87de6-524">Limit skalowalności: dostęp do jednostek przechowywanych w jednej partycji nie może być równoważeniem obciążenia ponieważ partycje obsługuje atomic partii transakcji.</span><span class="sxs-lookup"><span data-stu-id="87de6-524">Scalability limit: Access to entities stored in a single partition cannot be load-balanced because partitions support atomic batch transactions.</span></span> <span data-ttu-id="87de6-525">Z tego powodu cel skalowalność dla pojedynczej tabeli partycji jest niższa niż usługi tabeli jako całość.</span><span class="sxs-lookup"><span data-stu-id="87de6-525">For this reason, the scalability target for an individual table partition is lower than for the table service as a whole.</span></span>  

<span data-ttu-id="87de6-526">Ze względu na tę charakterystykę tabel i partycje powinna przyjąć następujące zasady projektowania:</span><span class="sxs-lookup"><span data-stu-id="87de6-526">Because of these characteristics of tables and partitions, you should adopt the following design principles:</span></span>  

* <span data-ttu-id="87de6-527">Dane aplikacji klienckiej często zaktualizowane lub wykonać zapytania w tej samej jednostki logicznej pracy powinien znajdować się w tej samej partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-527">Data that your client application frequently updated or queried in the same logical unit of work should be located in the same partition.</span></span>  <span data-ttu-id="87de6-528">Może to być, ponieważ aplikacja jest agregowanie zapisy lub chcesz korzystać z operacji wsadowych atomic.</span><span class="sxs-lookup"><span data-stu-id="87de6-528">This may be because your application is aggregating writes, or because you want to take advantage of atomic batch operations.</span></span>  <span data-ttu-id="87de6-529">Ponadto danych w jednej partycji mogą być bardziej wydajne wyszukiwane w pojedynczego zapytania niż dane na partycje.</span><span class="sxs-lookup"><span data-stu-id="87de6-529">Also, data in a single partition can be more efficiently queried in a single query than data across partitions.</span></span>
* <span data-ttu-id="87de6-530">Dane aplikacji klienckiej nie wstawiania/aktualizacji lub zapytania w tej samej jednostki logicznej pracy (pojedynczego zapytania lub aktualizację partii) powinien znajdować się w osobnych partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-530">Data that your client application does not insert/update or query in the same logical unit of work (single query or batch update) should be located in separate partitions.</span></span>  <span data-ttu-id="87de6-531">Jeden ważna uwaga jest, że nie ma żadnego limitu liczby kluczy partycji w jednej tabeli, więc o miliony kluczy partycji nie jest problem i nie ma wpływu na wydajność.</span><span class="sxs-lookup"><span data-stu-id="87de6-531">One important note is that there is no limit to the number of partition keys in a single table, so having millions of partition keys is not a problem and will not impact performance.</span></span>  <span data-ttu-id="87de6-532">Na przykład jeśli aplikacja jest popularnych witryny sieci Web z nazwą logowania użytkownika, za pomocą identyfikatora użytkownika jako klucza partycji może być dobrym rozwiązaniem.</span><span class="sxs-lookup"><span data-stu-id="87de6-532">For example, if your application is a popular website with user login, using the User Id as the partition key could be a good choice.</span></span>  

#### <a name="hot-partitions"></a><span data-ttu-id="87de6-533">Partycje dynamicznej</span><span class="sxs-lookup"><span data-stu-id="87de6-533">Hot Partitions</span></span>
<span data-ttu-id="87de6-534">Gorących partycji jest taki, który odbiera nieproporcjonalnie ruchu do konta, a nie może być o zrównoważonym obciążeniu ponieważ jest on jednej partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-534">A hot partition is one that is receiving a disproportionate percentage of the traffic to an account, and cannot be load balanced because it is a single partition.</span></span>  <span data-ttu-id="87de6-535">Ogólnie rzecz biorąc gorących partycje są tworzone dwa sposoby:</span><span class="sxs-lookup"><span data-stu-id="87de6-535">In general, hot partitions are created one of two ways:</span></span>  

##### <span data-ttu-id="87de6-536"><a name="subheading28"></a>Tylko dołączyć i dołączy tylko wzorce</span><span class="sxs-lookup"><span data-stu-id="87de6-536"><a name="subheading28"></a>Append Only and Prepend Only patterns</span></span>
<span data-ttu-id="87de6-537">Wzorzec "Dołącz tylko" jest jednym gdzie (większość lub wszystkie) ruchu na PK danego ułatwia i zmniejsza zgodnie z bieżącą godzinę.</span><span class="sxs-lookup"><span data-stu-id="87de6-537">The "Append Only" pattern is one where all (or nearly all) of the traffic to a given PK increases and decreases according to the current time.</span></span>  <span data-ttu-id="87de6-538">Przykładem jest, jeśli jako klucza partycji dla danych dziennika aplikacji używana bieżącą datę.</span><span class="sxs-lookup"><span data-stu-id="87de6-538">An example is if your application used the current date as a partition key for log data.</span></span>  <span data-ttu-id="87de6-539">W efekcie wszystkie wstawia przerywaj ostatniej partycji w tabeli, a system nie może załadować saldo, ponieważ wszystkie zapisów będzie koniec tabeli.</span><span class="sxs-lookup"><span data-stu-id="87de6-539">This results in all of the inserts going to the last partition in your table, and the system cannot load balance because all of the writes are going to the end of your table.</span></span>  <span data-ttu-id="87de6-540">Jeśli wielkość ruchu sieciowego do tej partycji przekracza docelowy skalowalność poziomu partycji, a następnie spowoduje ograniczania.</span><span class="sxs-lookup"><span data-stu-id="87de6-540">If the volume of traffic to that partition exceeds the partition-level scalability target, then it will result in throttling.</span></span>  <span data-ttu-id="87de6-541">Zaleca się upewnić się, że ruch wysyłany do wielu partycji, aby włączyć usługę równoważenia obciążenia żądań w tabeli.</span><span class="sxs-lookup"><span data-stu-id="87de6-541">It's better to ensure that traffic is sent to multiple partitions, to enable load balance the requests across your table.</span></span>  

##### <span data-ttu-id="87de6-542"><a name="subheading29"></a>Dane o dużym natężeniu ruchu</span><span class="sxs-lookup"><span data-stu-id="87de6-542"><a name="subheading29"></a>High-Traffic Data</span></span>
<span data-ttu-id="87de6-543">Jeśli Twoje schemat partycjonowania powoduje jednej partycji, zawierający tylko dane używane znacznie bardziej niż pozostałe partycje, może również zostać wyświetlony ograniczenie w postaci partycji zbliża się cel skalowalność dla jednej partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-543">If your partitioning scheme results in a single partition that just has data that is far more used than other partitions, you may also see throttling as that partition approaches the scalability target for a single partition.</span></span>  <span data-ttu-id="87de6-544">Zaleca się upewnić się, że schematem partycji powoduje nie jednej partycji zbliża się wartości docelowe skalowalności.</span><span class="sxs-lookup"><span data-stu-id="87de6-544">It's better to make sure that your partition scheme results in no single partition approaching the scalability targets.</span></span>  

#### <a name="querying"></a><span data-ttu-id="87de6-545">Wykonywanie zapytania</span><span class="sxs-lookup"><span data-stu-id="87de6-545">Querying</span></span>
<span data-ttu-id="87de6-546">W tej sekcji opisano sprawdzonych rozwiązań do wykonywania zapytań w usłudze tabel.</span><span class="sxs-lookup"><span data-stu-id="87de6-546">This section describes proven practices for querying the table service.</span></span>  

##### <span data-ttu-id="87de6-547"><a name="subheading30"></a>Zakres kwerendy</span><span class="sxs-lookup"><span data-stu-id="87de6-547"><a name="subheading30"></a>Query Scope</span></span>
<span data-ttu-id="87de6-548">Istnieje kilka sposobów, aby określić zakres jednostek do zapytania.</span><span class="sxs-lookup"><span data-stu-id="87de6-548">There are several ways to specify the range of entities to query.</span></span>  <span data-ttu-id="87de6-549">Poniżej przedstawiono omówienie używa każdego z nich.</span><span class="sxs-lookup"><span data-stu-id="87de6-549">The following is a discussion of the uses of each.</span></span>  

<span data-ttu-id="87de6-550">Ogólnie rzecz biorąc uniknąć skanowania (większe niż pojedynczy element zapytania), ale musi podczas skanowania, spróbuj organizowania danych tak, aby Twoje skanowania pobierać dane, które wymagają bez skanowania i zwracanie znacznej ilości jednostek, które nie są potrzebne.</span><span class="sxs-lookup"><span data-stu-id="87de6-550">In general, avoid scans (queries larger than a single entity), but if you must scan, try to organize your data so that your scans retrieve the data you need without scanning or returning significant amounts of entities you don't need.</span></span>  

###### <a name="point-queries"></a><span data-ttu-id="87de6-551">Punkt zapytań</span><span class="sxs-lookup"><span data-stu-id="87de6-551">Point Queries</span></span>
<span data-ttu-id="87de6-552">Zapytanie punktu pobiera dokładnie jedną jednostkę.</span><span class="sxs-lookup"><span data-stu-id="87de6-552">A point query retrieves exactly one entity.</span></span> <span data-ttu-id="87de6-553">Robi to przez określenie klucz partycji i klucz wiersza jednostki do pobrania.</span><span class="sxs-lookup"><span data-stu-id="87de6-553">It does this by specifying both the partition key and row key of the entity to retrieve.</span></span> <span data-ttu-id="87de6-554">Te zapytania są bardzo wydajny i należy ich używać, gdy jest to możliwe.</span><span class="sxs-lookup"><span data-stu-id="87de6-554">These queries are very efficient, and you should use them wherever possible.</span></span>  

###### <a name="partition-queries"></a><span data-ttu-id="87de6-555">Zapytania partycji</span><span class="sxs-lookup"><span data-stu-id="87de6-555">Partition Queries</span></span>
<span data-ttu-id="87de6-556">Zapytanie partycji jest kwerendę, która pobiera zestawu danych, które współużytkują wspólnego klucza partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-556">A partition query is a query that retrieves a set of data that shares a common partition key.</span></span> <span data-ttu-id="87de6-557">Zazwyczaj zapytanie określa zakres wartości klucza wiersza lub zakres wartości dla niektórych właściwości jednostki, oprócz klucza partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-557">Typically, the query specifies a range of row key values or a range of values for some entity property in addition to a partition key.</span></span> <span data-ttu-id="87de6-558">Te są mniej wydajne niż punkt zapytań i powinny być używane rzadko.</span><span class="sxs-lookup"><span data-stu-id="87de6-558">These are less efficient than point queries, and should be used sparingly.</span></span>  

###### <a name="table-queries"></a><span data-ttu-id="87de6-559">Zapytania w tabeli</span><span class="sxs-lookup"><span data-stu-id="87de6-559">Table Queries</span></span>
<span data-ttu-id="87de6-560">Zapytanie tabeli jest kwerendę, która pobiera zestaw jednostek, który nie współużytkują wspólnego klucza partycji.</span><span class="sxs-lookup"><span data-stu-id="87de6-560">A table query is a query that retrieves a set of entities that does not share a common partition key.</span></span> <span data-ttu-id="87de6-561">Te zapytania nie są wydajne i nie należy ich, jeśli to możliwe.</span><span class="sxs-lookup"><span data-stu-id="87de6-561">These queries are not efficient and you should avoid them if possible.</span></span>  

##### <span data-ttu-id="87de6-562"><a name="subheading31"></a>Gęstość zapytania</span><span class="sxs-lookup"><span data-stu-id="87de6-562"><a name="subheading31"></a>Query Density</span></span>
<span data-ttu-id="87de6-563">Innym czynnikiem klucza wydajności zapytania jest liczba zwróconych w porównaniu do liczby jednostek skanowania, aby znaleźć zestaw zwrócony.</span><span class="sxs-lookup"><span data-stu-id="87de6-563">Another key factor in query efficiency is the number of entities returned as compared to the number of entities scanned to find the returned set.</span></span> <span data-ttu-id="87de6-564">Jeśli aplikacja przeprowadza zapytanie tabeli z filtrem dla wartości właściwości tylko 1% udziałów danych, zapytanie będzie zeskanować 100 jednostek dla każdej jednostki jeden, zwracana.</span><span class="sxs-lookup"><span data-stu-id="87de6-564">If your application performs a table query with a filter for a property value that only 1% of the data shares, the query will scan 100 entities for every one entity it returns.</span></span> <span data-ttu-id="87de6-565">Wartości docelowe skalowalności tabeli omówionych wcześniej wszystkich odnoszą się do liczby jednostek skanowania, a nie liczba zwróconych: gęstość niski zapytania łatwo może spowodować usługi tabel do ograniczania aplikacji, ponieważ musi skanować tak wiele podmiotów pobiera obiekt, do którego szukasz.</span><span class="sxs-lookup"><span data-stu-id="87de6-565">The table scalability targets discussed previously all relate to the number of entities scanned, and not the number of entities returned: a low query density can easily cause the table service to throttle your application because it must scan so many entities to retrieve the entity you are looking for.</span></span>  <span data-ttu-id="87de6-566">Zobacz sekcję poniżej na [denormalization](#subheading34) Aby uzyskać więcej informacji na temat tego uniknąć.</span><span class="sxs-lookup"><span data-stu-id="87de6-566">See the section below on [denormalization](#subheading34) for more information on how to avoid this.</span></span>  

##### <a name="limiting-the-amount-of-data-returned"></a><span data-ttu-id="87de6-567">Ograniczenia ilości zwracanych danych</span><span class="sxs-lookup"><span data-stu-id="87de6-567">Limiting the Amount of Data Returned</span></span>
###### <span data-ttu-id="87de6-568"><a name="subheading32"></a>Filtrowanie</span><span class="sxs-lookup"><span data-stu-id="87de6-568"><a name="subheading32"></a>Filtering</span></span>
<span data-ttu-id="87de6-569">W przypadku, gdy wiesz, że kwerendy zwróci jednostek, które nie wymagają aplikacji klienckiej, należy wziąć pod uwagę przy użyciu filtru, aby zmniejszyć rozmiar zwróconego zestawu.</span><span class="sxs-lookup"><span data-stu-id="87de6-569">Where you know that a query will return entities that you don't need in the client application, consider using a filter to reduce the size of the returned set.</span></span> <span data-ttu-id="87de6-570">Podczas jednostki nie jest zwracana do klienta wliczane nadal limity skalowalności, ze względu na rozmiar ładunku zmniejszenie sieci i ograniczoną liczbę jednostek spełniających aplikacja kliencka musi przetworzyć poprawia wydajność aplikacji.</span><span class="sxs-lookup"><span data-stu-id="87de6-570">While the entities not returned to the client still count toward the scalability limits, your application performance will improve because of the reduced network payload size and the reduced number of entities that your client application must process.</span></span>  <span data-ttu-id="87de6-571">Można znaleźć w powyższym Uwaga na [gęstość zapytania](#subheading31), jednak — wartości docelowe skalowalności odnoszą się do liczby jednostek skanowania, więc zapytania, który odfiltrowuje wiele jednostek może nadal spowodować ograniczania przepustowości, nawet jeśli są zwracane jednostki kilku.</span><span class="sxs-lookup"><span data-stu-id="87de6-571">See above note on [Query Density](#subheading31), however – the scalability targets relate to the number of entities scanned, so a query that filters out many entities may still result in throttling, even if few entities are returned.</span></span>  

###### <span data-ttu-id="87de6-572"><a name="subheading33"></a>Projekcji</span><span class="sxs-lookup"><span data-stu-id="87de6-572"><a name="subheading33"></a>Projection</span></span>
<span data-ttu-id="87de6-573">Jeśli aplikacja kliencka musi tylko ograniczony zestaw właściwości z jednostek w tabeli, można użyć projekcji Aby ograniczyć rozmiar zwróconego zestawu danych.</span><span class="sxs-lookup"><span data-stu-id="87de6-573">If your client application needs only a limited set of properties from the entities in your table, you can use projection to limit the size of the returned data set.</span></span> <span data-ttu-id="87de6-574">Podobnie jak w przypadku filtrowania, pozwala to zmniejszyć obciążenie sieci i przetwarzania klienta.</span><span class="sxs-lookup"><span data-stu-id="87de6-574">As with filtering, this helps to reduce network load and client processing.</span></span>  

##### <span data-ttu-id="87de6-575"><a name="subheading34"></a>Denormalization</span><span class="sxs-lookup"><span data-stu-id="87de6-575"><a name="subheading34"></a>Denormalization</span></span>
<span data-ttu-id="87de6-576">W przeciwieństwie do pracy z relacyjnych baz danych, sprawdzonych rozwiązań dla wydajnie przeszukiwaniem danych w tabeli prowadzić do denormalizing danych.</span><span class="sxs-lookup"><span data-stu-id="87de6-576">Unlike working with relational databases, the proven practices for efficiently querying table data lead to denormalizing your data.</span></span> <span data-ttu-id="87de6-577">Oznacza to, powielanie tych samych danych w wielu jednostek (po jednym dla każdego klucza, aby znaleźć dane, można użyć) aby zminimalizować liczbę jednostek spełniających kwerendy skanowania musi znaleźć dane klienta musi, zamiast czekać, aż do skanowania dużej liczby jednostek, aby znaleźć dane aplikacji wymaga instalowania aplikacji.</span><span class="sxs-lookup"><span data-stu-id="87de6-577">That is, duplicating the same data in multiple entities (one for each key you may use to find the data) to minimize the number of entities that a query must scan to find the data the client needs, rather than having to scan large numbers of entities to find the data your application needs.</span></span>  <span data-ttu-id="87de6-578">Na przykład w witrynie internetowej handlu elektronicznego, warto znajdowanie zamówienia obu według Identyfikatora klienta (Udostępnij ten zamówienia) oraz według daty (Udostępnij zamówień w dniu).</span><span class="sxs-lookup"><span data-stu-id="87de6-578">For example, in an e-commerce website, you may want to find an order both by the customer ID (give me this customer's orders) and by the date (give me orders on a date).</span></span>  <span data-ttu-id="87de6-579">W magazynie tabel, warto przechowywać jednostka (lub odwołanie do niej) dwukrotnie — raz z nazwą tabeli klucza podstawowego i RK, aby ułatwić znajdowanie przez klienta IDENTYFIKATORA, raz ułatwia on Znajdowanie według daty.</span><span class="sxs-lookup"><span data-stu-id="87de6-579">In Table Storage, it is best to store the entity (or a reference to it) twice – once with Table Name, PK, and RK to facilitate finding by customer ID, once to facilitate finding it by the date.</span></span>  

#### <a name="insertupdatedelete"></a><span data-ttu-id="87de6-580">Wstawiania/aktualizowania/usuwania</span><span class="sxs-lookup"><span data-stu-id="87de6-580">Insert/Update/Delete</span></span>
<span data-ttu-id="87de6-581">W tej sekcji opisano sprawdzonych rozwiązań modyfikowania jednostek przechowywanych w usłudze tabel.</span><span class="sxs-lookup"><span data-stu-id="87de6-581">This section describes proven practices for modifying entities stored in the table service.</span></span>  

##### <span data-ttu-id="87de6-582"><a name="subheading35"></a>Przetwarzanie wsadowe</span><span class="sxs-lookup"><span data-stu-id="87de6-582"><a name="subheading35"></a>Batching</span></span>
<span data-ttu-id="87de6-583">Partie transakcji są określane jako jednostki grupy transakcji (ETG) w usłudze Azure Storage; wszystkie operacje w ramach ETG musi znajdować się na jednej partycji w jednej tabeli.</span><span class="sxs-lookup"><span data-stu-id="87de6-583">Batch transactions are known as Entity Group Transactions (ETG) in Azure Storage; all the operations within an ETG must be on a single partition in a single table.</span></span> <span data-ttu-id="87de6-584">Jeśli to możliwe, należy użyć ETGs do wykonania operacji wstawiania, aktualizacji i usunięć w partiach.</span><span class="sxs-lookup"><span data-stu-id="87de6-584">Where possible, use ETGs to perform inserts, updates, and deletes in batches.</span></span> <span data-ttu-id="87de6-585">To zmniejsza liczbę rund aplikację klienta na serwerze, zmniejsza liczbę transakcji rozliczeniowy (ETG traktowana jako pojedynczej transakcji na potrzeby rozliczeń i może zawierać maksymalnie 100 operacje magazynu) i umożliwia atomic aktualizacje, (wszystkie wersje operacje powiedzie się lub nie powiedzie się w obrębie ETG).</span><span class="sxs-lookup"><span data-stu-id="87de6-585">This reduces the number of round trips from your client application to the server, reduces the number of billable transactions (an ETG counts as a single transaction for billing purposes and can contain up to 100 storage operations), and enables atomic updates (all operations succeed or all fail within an ETG).</span></span> <span data-ttu-id="87de6-586">Środowiska z wysokimi opóźnieniami, takich jak urządzenia przenośne będzie znacznie korzystać z ETGs.</span><span class="sxs-lookup"><span data-stu-id="87de6-586">Environments with high latencies such as mobile devices will benefit greatly from using ETGs.</span></span>  

##### <span data-ttu-id="87de6-587"><a name="subheading36"></a>UPSERT</span><span class="sxs-lookup"><span data-stu-id="87de6-587"><a name="subheading36"></a>Upsert</span></span>
<span data-ttu-id="87de6-588">Użyj tabeli **Upsert** operacji tam gdzie to możliwe.</span><span class="sxs-lookup"><span data-stu-id="87de6-588">Use table **Upsert** operations wherever possible.</span></span> <span data-ttu-id="87de6-589">Istnieją dwa typy **Upsert**, które może być skuteczniejsza niż tradycyjny **Wstaw** i **aktualizacji** operacje:</span><span class="sxs-lookup"><span data-stu-id="87de6-589">There are two types of **Upsert**, both of which can be more efficient than a traditional **Insert** and **Update** operations:</span></span>  

* <span data-ttu-id="87de6-590">**InsertOrMerge**: Użyj go, jeśli chcesz przekazać podzbioru właściwości jednostki, ale nie masz pewności, czy ta jednostka już istnieje.</span><span class="sxs-lookup"><span data-stu-id="87de6-590">**InsertOrMerge**: Use this when you want to upload a subset of the entity's properties, but aren't sure whether the entity already exists.</span></span> <span data-ttu-id="87de6-591">Jednostka istnieje, to wywołanie aktualizuje właściwości zawarte w **Upsert** operację i wszystkich istniejących właściwości są one, jeśli jednostka nie istnieje, Nowa jednostka do wstawienia.</span><span class="sxs-lookup"><span data-stu-id="87de6-591">If the entity exists, this call updates the properties included in the **Upsert** operation, and leaves all existing properties as they are, if the entity does not exist, it inserts the new entity.</span></span> <span data-ttu-id="87de6-592">Jest podobny do sposobu używania rzutowania w zapytaniu, w tym należy przekazać właściwości, które są zmieniane.</span><span class="sxs-lookup"><span data-stu-id="87de6-592">This is similar to using projection in a query, in that you only need to upload the properties that are changing.</span></span>
* <span data-ttu-id="87de6-593">**InsertOrReplace**: Użyj go, jeśli chcesz przekazać całkowicie nowe jednostki, ale nie masz pewności, czy już istnieje.</span><span class="sxs-lookup"><span data-stu-id="87de6-593">**InsertOrReplace**: Use this when you want to upload an entirely new entity, but you aren't sure whether it already exists.</span></span> <span data-ttu-id="87de6-594">Należy używać tylko to, gdy wiesz, że nowo przesłanym jednostki jest całkowicie prawidłowe, ponieważ całkowicie zastępuje stary jednostki.</span><span class="sxs-lookup"><span data-stu-id="87de6-594">You should only use this when you know that the newly uploaded entity is entirely correct because it completely overwrites the old entity.</span></span> <span data-ttu-id="87de6-595">Na przykład chcesz zaktualizować jednostki, która przechowuje bieżącej lokalizacji użytkownika niezależnie od tego, czy aplikacja wcześniej przechowywanych danych lokalizacji dla użytkownika; Nowa jednostka lokalizacji została ukończona, a nie są wszystkie informacje z poprzedniego jednostki.</span><span class="sxs-lookup"><span data-stu-id="87de6-595">For example, you want to update the entity that stores a user's current location regardless of whether or not the application has previously stored location data for the user; the new location entity is complete, and you do not need any information from any previous entity.</span></span>

##### <span data-ttu-id="87de6-596"><a name="subheading37"></a>Przechowywanie danych serii w pojedynczej jednostki</span><span class="sxs-lookup"><span data-stu-id="87de6-596"><a name="subheading37"></a>Storing Data Series in a Single Entity</span></span>
<span data-ttu-id="87de6-597">Czasami aplikacja przechowuje serii danych, który często musi pobrać jednocześnie: na przykład aplikacja może śledzić użycie procesora CPU w czasie do wykreślenia wykresu stopniowego dane z ostatnich 24 godzinach.</span><span class="sxs-lookup"><span data-stu-id="87de6-597">Sometimes, an application stores a series of data that it frequently needs to retrieve all at once: for example, an application might track CPU usage over time in order to plot a rolling chart of the data from the last 24 hours.</span></span> <span data-ttu-id="87de6-598">Jednym z podejść jest jedną jednostkę tabeli na godzinę, z każdej jednostki reprezentującą określoną godzinę i przechowywania użycie procesora CPU dla danej godziny.</span><span class="sxs-lookup"><span data-stu-id="87de6-598">One approach is to have one table entity per hour, with each entity representing a specific hour and storing the CPU usage for that hour.</span></span> <span data-ttu-id="87de6-599">Do wykreślenia tych danych, aplikacja musi pobrać jednostek przechowywania danych z 24 godziny ostatniego.</span><span class="sxs-lookup"><span data-stu-id="87de6-599">To plot this data, the application needs to retrieve the entities holding the data from the 24 most recent hours.</span></span>  

<span data-ttu-id="87de6-600">Alternatywnie aplikacji można przechowywać użycie procesora CPU dla każdej godziny jako osobne właściwość pojedynczej jednostki: Aby zaktualizować co godzinę, aplikacja może używać pojedynczego **InsertOrMerge Upsert** wywołania do aktualizowania wartości dla najnowszej Godzina.</span><span class="sxs-lookup"><span data-stu-id="87de6-600">Alternatively, your application could store the CPU usage for each hour as a separate property of a single entity: to update each hour, your application can use a single **InsertOrMerge Upsert** call to update the value for the most recent hour.</span></span> <span data-ttu-id="87de6-601">Do wykreślenia danych, aplikacja tylko musi pobrać pojedynczą jednostką zamiast 24, co bardzo wydajny zapytania (zobacz powyżej dyskusji na [kwerendy zakresu](#subheading30)).</span><span class="sxs-lookup"><span data-stu-id="87de6-601">To plot the data, the application only needs to retrieve a single entity instead of 24, making for a very efficient query (see above discussion on [query scope](#subheading30)).</span></span>

##### <span data-ttu-id="87de6-602"><a name="subheading38"></a>Przechowywanie danych strukturalnych w obiektach blob</span><span class="sxs-lookup"><span data-stu-id="87de6-602"><a name="subheading38"></a>Storing structured data in blobs</span></span>
<span data-ttu-id="87de6-603">Czasami strukturalnych danych tak, jak powinien znajdować się w tabelach, ale zakresy jednostek są zawsze pobierane ze sobą i można wstawiać partii.</span><span class="sxs-lookup"><span data-stu-id="87de6-603">Sometimes structured data feels like it should go in tables, but ranges of entities are always retrieved together and can be batch inserted.</span></span>  <span data-ttu-id="87de6-604">Dobrym przykładem jest plik dziennika.</span><span class="sxs-lookup"><span data-stu-id="87de6-604">A good example of this is a log file.</span></span>  <span data-ttu-id="87de6-605">W takim przypadku można partii kilka minut dzienników, umieść je i następnie kilka minut dzienników również jednocześnie są zawsze pobierane.</span><span class="sxs-lookup"><span data-stu-id="87de6-605">In this case, you can batch several minutes of logs, insert them, and then you are always retrieving several minutes of logs at a time as well.</span></span>  <span data-ttu-id="87de6-606">W takim przypadku wydajność, najlepiej użyć obiektów blob zamiast tabel, ponieważ może znacznie zmniejszyć liczbę obiektów zapisywane/zwrócona, a także zwykle liczba żądań, które muszą wprowadzone.</span><span class="sxs-lookup"><span data-stu-id="87de6-606">In this case, for performance, it's better to use blobs instead of tables, since you can significantly reduce the number of objects written/returned, as well as usually the number of requests that need made.</span></span>  

## <a name="queues"></a><span data-ttu-id="87de6-607">Kolejki</span><span class="sxs-lookup"><span data-stu-id="87de6-607">Queues</span></span>
<span data-ttu-id="87de6-608">Oprócz sprawdzonych rozwiązań dla [wszystkie usługi](#allservices) opisanych powyżej, poniżej sprawdzonych rozwiązań dotyczą przede wszystkim usługi kolejki.</span><span class="sxs-lookup"><span data-stu-id="87de6-608">In addition to the proven practices for [All Services](#allservices) described previously, the following proven practices apply specifically to the queue service.</span></span>  

### <span data-ttu-id="87de6-609"><a name="subheading39"></a>Limity skalowalności</span><span class="sxs-lookup"><span data-stu-id="87de6-609"><a name="subheading39"></a>Scalability Limits</span></span>
<span data-ttu-id="87de6-610">Kolejka może przetworzyć około 2000 wiadomości (1KB) na sekundę (każdego AddMessage, GetMessage i DeleteMessage licznik jako tutaj komunikat).</span><span class="sxs-lookup"><span data-stu-id="87de6-610">A single queue can process approximately 2,000 messages (1KB each) per second (each AddMessage, GetMessage, and DeleteMessage count as a message here).</span></span> <span data-ttu-id="87de6-611">Jeśli to jest niewystarczająca dla aplikacji, należy użyć wielu kolejek i rozmieszczenie do nich wiadomości.</span><span class="sxs-lookup"><span data-stu-id="87de6-611">If this is insufficient for your application, you should use multiple queues and spread the messages across them.</span></span>  

<span data-ttu-id="87de6-612">Wyświetl bieżące wartości docelowe skalowalności w [cele dotyczące wydajności i skalowalności magazynu Azure](storage-scalability-targets.md).</span><span class="sxs-lookup"><span data-stu-id="87de6-612">View current scalability targets at [Azure Storage Scalability and Performance Targets](storage-scalability-targets.md).</span></span>  

### <span data-ttu-id="87de6-613"><a name="subheading40"></a>Nagle'a wyłączone</span><span class="sxs-lookup"><span data-stu-id="87de6-613"><a name="subheading40"></a>Nagle Off</span></span>
<span data-ttu-id="87de6-614">Zobacz sekcję dotyczącą konfiguracji tabeli omówiono algorytm Nagle'a — algorytm Nagle'a jest zazwyczaj zły wydajności kolejki żądań i należy go wyłączyć.</span><span class="sxs-lookup"><span data-stu-id="87de6-614">See the section on table configuration that discusses the Nagle algorithm — the Nagle algorithm is generally bad for the performance of queue requests, and you should disable it.</span></span>  

### <span data-ttu-id="87de6-615"><a name="subheading41"></a>Rozmiar komunikatu</span><span class="sxs-lookup"><span data-stu-id="87de6-615"><a name="subheading41"></a>Message Size</span></span>
<span data-ttu-id="87de6-616">Wydajność i skalowalność spadku kolejki miarę zwiększania rozmiaru komunikatu.</span><span class="sxs-lookup"><span data-stu-id="87de6-616">Queue performance and scalability decreases as message size increases.</span></span> <span data-ttu-id="87de6-617">Tylko te informacje, które odbiorca musi należy umieścić w wiadomości.</span><span class="sxs-lookup"><span data-stu-id="87de6-617">You should place only the information the receiver needs in a message.</span></span>  

### <span data-ttu-id="87de6-618"><a name="subheading42"></a>Pobieranie partii</span><span class="sxs-lookup"><span data-stu-id="87de6-618"><a name="subheading42"></a>Batch Retrieval</span></span>
<span data-ttu-id="87de6-619">Można pobrać maksymalnie 32 wiadomości z kolejki w ramach jednej operacji.</span><span class="sxs-lookup"><span data-stu-id="87de6-619">You can retrieve up to 32 messages from a queue in a single operation.</span></span> <span data-ttu-id="87de6-620">To pozwala zmniejszyć liczbę dwukierunkowe przesyłanie danych z aplikacji klienta, co jest szczególnie przydatne w środowiskach, takich jak urządzenia przenośne, duże opóźnienie.</span><span class="sxs-lookup"><span data-stu-id="87de6-620">This can reduce the number of roundtrips from the client application, which is especially useful for environments, such as mobile devices, with high latency.</span></span>  

### <span data-ttu-id="87de6-621"><a name="subheading43"></a>Interwał sondowania kolejki</span><span class="sxs-lookup"><span data-stu-id="87de6-621"><a name="subheading43"></a>Queue Polling Interval</span></span>
<span data-ttu-id="87de6-622">Większość aplikacji sondować wiadomości z kolejki, które może być jedną z największych źródeł transakcje dla tej aplikacji.</span><span class="sxs-lookup"><span data-stu-id="87de6-622">Most applications poll for messages from a queue, which can be one of the largest sources of transactions for that application.</span></span> <span data-ttu-id="87de6-623">Wybierz rozsądny sposób interwału sondowania: sondowanie zbyt często może spowodować, że aplikacja do wartości docelowe skalowalności dla kolejki.</span><span class="sxs-lookup"><span data-stu-id="87de6-623">Select your polling interval wisely: polling too frequently could cause your application to approach the scalability targets for the queue.</span></span> <span data-ttu-id="87de6-624">Jednak w 200 000 transakcji dla $0,01 (w czasie zapisywania), przez pojedynczy procesor sondowania, gdy w ciągu sekundy przez miesiąc czy koszt mniej niż 15 centów, więc koszt nie jest zwykle czynnik, który ma wpływ na wybór interwału sondowania.</span><span class="sxs-lookup"><span data-stu-id="87de6-624">However, at 200,000 transactions for $0.01 (at the time of writing), a single processor polling once every second for a month would cost less than 15 cents so cost is not typically a factor that affects your choice of polling interval.</span></span>  

<span data-ttu-id="87de6-625">Koszt aktualne informacje, zobacz [cennik usługi Azure Storage](https://azure.microsoft.com/pricing/details/storage/).</span><span class="sxs-lookup"><span data-stu-id="87de6-625">For up-to-date cost information, see [Azure Storage Pricing](https://azure.microsoft.com/pricing/details/storage/).</span></span>  

### <span data-ttu-id="87de6-626"><a name="subheading44"></a>UpdateMessage</span><span class="sxs-lookup"><span data-stu-id="87de6-626"><a name="subheading44"></a>UpdateMessage</span></span>
<span data-ttu-id="87de6-627">Można użyć **UpdateMessage** Aby zwiększyć limit czasu niewidoczności lub zaktualizować informacje o stanie wiadomości.</span><span class="sxs-lookup"><span data-stu-id="87de6-627">You can use **UpdateMessage** to increase the invisibility timeout or to update state information of a message.</span></span> <span data-ttu-id="87de6-628">Jest to zaawansowane, należy pamiętać, że każdy **UpdateMessage** operacji liczy się docelowy skalowalności.</span><span class="sxs-lookup"><span data-stu-id="87de6-628">While this is powerful, remember that each **UpdateMessage** operation counts towards the scalability target.</span></span> <span data-ttu-id="87de6-629">Jednak może to być bardziej efektywnego podejścia niż w przypadku przepływu pracy, który przekazuje zadania z jednej kolejki do następnego, ponieważ każdy krok zadanie zostało zakończone.</span><span class="sxs-lookup"><span data-stu-id="87de6-629">However, this can be a much more efficient approach than having a workflow that passes a job from one queue to the next, as each step of the job is completed.</span></span> <span data-ttu-id="87de6-630">Przy użyciu **UpdateMessage** operacji pozwala aplikacji Zapisz stan zadania do wiadomości, a następnie kontynuuj pracę, zamiast ponownie usługi kolejkowania komunikatów do następnego kroku zadania za każdym razem, gdy wykonuje kroku.</span><span class="sxs-lookup"><span data-stu-id="87de6-630">Using the **UpdateMessage** operation allows your application to save the job state to the message and then continue working, instead of re-queuing the message for the next step of the job every time a step completes.</span></span>  

<span data-ttu-id="87de6-631">Aby uzyskać więcej informacji, zobacz artykuł [porady: zmiana zawartości komunikatu w kolejce](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span><span class="sxs-lookup"><span data-stu-id="87de6-631">For more information, see the article [How to: Change the contents of a queued message](storage-dotnet-how-to-use-queues.md#change-the-contents-of-a-queued-message).</span></span>  

### <span data-ttu-id="87de6-632"><a name="subheading45"></a>Architektura aplikacji</span><span class="sxs-lookup"><span data-stu-id="87de6-632"><a name="subheading45"></a>Application architecture</span></span>
<span data-ttu-id="87de6-633">Aby skalowalne architektury aplikacji należy używać kolejek.</span><span class="sxs-lookup"><span data-stu-id="87de6-633">You should use queues to make your application architecture scalable.</span></span> <span data-ttu-id="87de6-634">Poniżej wymieniono niektóre sposoby użycia kolejek dokonanie skalowalność aplikacji:</span><span class="sxs-lookup"><span data-stu-id="87de6-634">The following lists some ways you can use queues to make your application more scalable:</span></span>  

* <span data-ttu-id="87de6-635">Tworzenie zaległości pracy do przetwarzania i wygładzanie obciążeń w aplikacji, można użyć kolejki.</span><span class="sxs-lookup"><span data-stu-id="87de6-635">You can use queues to create backlogs of work for processing and smooth out workloads in your application.</span></span> <span data-ttu-id="87de6-636">Na przykład użytkownik może kolejki żądania od użytkowników do wykonywania pracy znacznym procesora, takich jak zmiana rozmiaru obrazów przekazane.</span><span class="sxs-lookup"><span data-stu-id="87de6-636">For example, you could queue up requests from users to perform processor intensive work such as resizing uploaded images.</span></span>
* <span data-ttu-id="87de6-637">Kolejek umożliwia rozdzielenie części aplikacji, dzięki czemu można je skalować niezależnie.</span><span class="sxs-lookup"><span data-stu-id="87de6-637">You can use queues to decouple parts of your application so that you can scale them independently.</span></span> <span data-ttu-id="87de6-638">Na przykład frontonu sieci web mógł umieścić wyników ankiety od użytkowników w kolejce dla nowszej analizy i magazynu.</span><span class="sxs-lookup"><span data-stu-id="87de6-638">For example, a web front-end could place survey results from users into a queue for later analysis and storage.</span></span> <span data-ttu-id="87de6-639">Można dodać więcej wystąpień roli procesu roboczego do przetwarzania danych kolejki zgodnie z potrzebami.</span><span class="sxs-lookup"><span data-stu-id="87de6-639">You could add more worker role instances to process the queue data as required.</span></span>  

## <a name="conclusion"></a><span data-ttu-id="87de6-640">Podsumowanie</span><span class="sxs-lookup"><span data-stu-id="87de6-640">Conclusion</span></span>
<span data-ttu-id="87de6-641">W tym artykule omówiono niektóre z najczęściej, sprawdzonych rozwiązań dla optymalizacji wydajności w przypadku korzystania z usługi Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="87de6-641">This article discussed some of the most common, proven practices for optimizing performance when using Azure Storage.</span></span> <span data-ttu-id="87de6-642">Zachęcamy każdego dewelopera aplikacji do oceny swoich aplikacji pod kątem powyższych rozwiązań oraz do postępowania zgodnie z zaleceniami mającymi na celu uzyskanie optymalnej wydajności aplikacji korzystających z usługi Azure Storage.</span><span class="sxs-lookup"><span data-stu-id="87de6-642">We encourage every application developer to assess their application against each of the above practices and consider acting on the recommendations to get great performance for their applications that use Azure Storage.</span></span>